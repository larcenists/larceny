(let () (begin (set! make-relative-filename (lambda .components|1 (let ((.construct|2 (unspecified))) (begin (set! .construct|2 (lambda (.l|3) (if (null? (let ((.x|4|7 .l|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7)))) .l|3 (cons (let ((.x|8|11 .l|3)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) (cons "/" (.construct|2 (let ((.x|12|15 .l|3)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))))))))) (if (null? (let ((.x|16|19 .components|1)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19)))) (let ((.x|20|23 .components|1)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))) (apply string-append (.construct|2 .components|1))))))) 'make-relative-filename))
(let () (begin (set! pathname-append (lambda .components|1 (let ((.construct|4 (unspecified))) (begin (set! .construct|4 (lambda (.l|5) (if (null? (let ((.x|7|10 .l|5)) (begin (.check! (pair? .x|7|10) 1 .x|7|10) (cdr:pair .x|7|10)))) .l|5 (if (string=? (let ((.x|12|15 .l|5)) (begin (.check! (pair? .x|12|15) 0 .x|12|15) (car:pair .x|12|15))) "") (.construct|4 (let ((.x|16|19 .l|5)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19)))) (if (char=? #\/ (string-ref (let ((.x|21|24 .l|5)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24))) (- (string-length (let ((.x|25|28 .l|5)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28)))) 1))) (cons (let ((.x|29|32 .l|5)) (begin (.check! (pair? .x|29|32) 0 .x|29|32) (car:pair .x|29|32))) (.construct|4 (let ((.x|33|36 .l|5)) (begin (.check! (pair? .x|33|36) 1 .x|33|36) (cdr:pair .x|33|36))))) (cons (let ((.x|38|41 .l|5)) (begin (.check! (pair? .x|38|41) 0 .x|38|41) (car:pair .x|38|41))) (cons "/" (.construct|4 (let ((.x|42|45 .l|5)) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45))))))))))) (let ((.n|46 (if (null? (let ((.x|47|50 .components|1)) (begin (.check! (pair? .x|47|50) 1 .x|47|50) (cdr:pair .x|47|50)))) (let ((.x|51|54 .components|1)) (begin (.check! (pair? .x|51|54) 0 .x|51|54) (car:pair .x|51|54))) (apply string-append (.construct|4 .components|1))))) (if (not (char=? #\/ (string-ref .n|46 (- (string-length .n|46) 1)))) (string-append .n|46 "/") .n|46)))))) 'pathname-append))
(let () (begin (set! make-nbuild-parameter (lambda (.dir|1 .source?|1 .verbose?|1 .hostdir|1 .hostname|1) (let ((.make-nbuild-parameter|2 0)) (begin (set! .make-nbuild-parameter|2 (lambda (.dir|3 .source?|3 .verbose?|3 .hostdir|3 .hostname|3) (let ((.parameters|6 (.cons (.cons 'compiler (pathname-append .dir|3 "Compiler")) (.cons (.cons 'util (pathname-append .dir|3 "Util")) (.cons (.cons 'build (pathname-append .dir|3 "Rts" "Build")) (.cons (.cons 'source (pathname-append .dir|3 "Lib")) (.cons (.cons 'common-source (pathname-append .dir|3 "Lib" "Common")) (.cons (.cons 'repl-source (pathname-append .dir|3 "Repl")) (.cons (.cons 'interp-source (pathname-append .dir|3 "Eval")) (.cons (.cons 'machine-source (pathname-append .dir|3 "Lib" "Sparc")) (.cons (.cons 'common-asm (pathname-append .dir|3 "Asm" "Common")) (.cons (.cons 'sparc-asm (pathname-append .dir|3 "Asm" "Sparc")) (.cons '(target-machine . sparc) (.cons '(endianness . big) (.cons '(word-size . 32) (.cons (.cons 'always-source? .source?|3) (.cons (.cons 'verbose-load? .verbose?|3) (.cons (.cons 'compatibility (pathname-append .dir|3 "Compat" .hostdir|3)) (.cons (.cons 'host-system .hostname|3) '()))))))))))))))))))) (lambda (.key|7) (let ((.probe|10 (assq .key|7 .parameters|6))) (if .probe|10 (let ((.x|11|14 .probe|10)) (begin (.check! (pair? .x|11|14) 1 .x|11|14) (cdr:pair .x|11|14))) #f)))))) (.make-nbuild-parameter|2 .dir|1 .source?|1 .verbose?|1 .hostdir|1 .hostname|1))))) 'make-nbuild-parameter))
(let () (begin (set! nbuild-parameter (make-nbuild-parameter "" #f #f "Larceny" "Larceny")) 'nbuild-parameter))
(let () (begin (set! aremq! (lambda (.key|1 .alist|1) (let ((.aremq!|2 0)) (begin (set! .aremq!|2 (lambda (.key|3 .alist|3) (if (null? .alist|3) .alist|3 (if (eq? .key|3 (let ((.x|7|10 (let ((.x|11|14 .alist|3)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14))))) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10)))) (.aremq!|2 .key|3 (let ((.x|15|18 .alist|3)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18)))) (begin (set-cdr! .alist|3 (.aremq!|2 .key|3 (let ((.x|20|23 .alist|3)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))))) .alist|3))))) (.aremq!|2 .key|1 .alist|1))))) 'aremq!))
(let () (begin (set! aremv! (lambda (.key|1 .alist|1) (let ((.aremv!|2 0)) (begin (set! .aremv!|2 (lambda (.key|3 .alist|3) (if (null? .alist|3) .alist|3 (if (eqv? .key|3 (let ((.x|8|11 (let ((.x|12|15 .alist|3)) (begin (.check! (pair? .x|12|15) 0 .x|12|15) (car:pair .x|12|15))))) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11)))) (.aremv!|2 .key|3 (let ((.x|16|19 .alist|3)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19)))) (begin (set-cdr! .alist|3 (.aremv!|2 .key|3 (let ((.x|21|24 .alist|3)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) .alist|3))))) (.aremv!|2 .key|1 .alist|1))))) 'aremv!))
(let () (begin (set! aremove! (lambda (.key|1 .alist|1) (let ((.aremove!|2 0)) (begin (set! .aremove!|2 (lambda (.key|3 .alist|3) (if (null? .alist|3) .alist|3 (if (equal? .key|3 (let ((.x|7|10 (let ((.x|11|14 .alist|3)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14))))) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10)))) (.aremove!|2 .key|3 (let ((.x|15|18 .alist|3)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18)))) (begin (set-cdr! .alist|3 (.aremove!|2 .key|3 (let ((.x|20|23 .alist|3)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))))) .alist|3))))) (.aremove!|2 .key|1 .alist|1))))) 'aremove!))
(let () (begin (set! filter (lambda (.select?|1 .list|1) (let ((.filter|2 0)) (begin (set! .filter|2 (lambda (.select?|3 .list|3) (if (null? .list|3) .list|3 (if (.select?|3 (let ((.x|6|9 .list|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9)))) (cons (let ((.x|10|13 .list|3)) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13))) (.filter|2 .select?|3 (let ((.x|14|17 .list|3)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))))) (.filter|2 .select?|3 (let ((.x|19|22 .list|3)) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22)))))))) (.filter|2 .select?|1 .list|1))))) 'filter))
(let () (begin (set! find (lambda (.selected?|1 .list|1) (let ((.find|2 0)) (begin (set! .find|2 (lambda (.selected?|3 .list|3) (if (null? .list|3) #f (if (.selected?|3 (let ((.x|6|9 .list|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9)))) (let ((.x|10|13 .list|3)) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13))) (.find|2 .selected?|3 (let ((.x|15|18 .list|3)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18)))))))) (.find|2 .selected?|1 .list|1))))) 'find))
(let () (begin (set! remove-duplicates (lambda (.list|1 .same?|1) (let ((.remove-duplicates|2 0)) (begin (set! .remove-duplicates|2 (lambda (.list|3 .same?|3) (let ((.member?|5 (unspecified))) (begin (set! .member?|5 (lambda (.x|6 .list|6) (if (null? .list|6) #f (if (.same?|3 .x|6 (let ((.x|9|12 .list|6)) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12)))) #t (.member?|5 .x|6 (let ((.x|14|17 .list|6)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17)))))))) (if (null? .list|3) .list|3 (if (.member?|5 (let ((.x|19|22 .list|3)) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22))) (let ((.x|23|26 .list|3)) (begin (.check! (pair? .x|23|26) 1 .x|23|26) (cdr:pair .x|23|26)))) (.remove-duplicates|2 (let ((.x|27|30 .list|3)) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30))) .same?|3) (cons (let ((.x|32|35 .list|3)) (begin (.check! (pair? .x|32|35) 0 .x|32|35) (car:pair .x|32|35))) (.remove-duplicates|2 (let ((.x|36|39 .list|3)) (begin (.check! (pair? .x|36|39) 1 .x|36|39) (cdr:pair .x|36|39))) .same?|3)))))))) (.remove-duplicates|2 .list|1 .same?|1))))) 'remove-duplicates))
(let () (begin (set! least (lambda (.less?|1 .list|1) (let ((.least|2 0)) (begin (set! .least|2 (lambda (.less?|3 .list|3) (reduce (lambda (.a|4 .b|4) (if (.less?|3 .a|4 .b|4) .a|4 .b|4)) #f .list|3))) (.least|2 .less?|1 .list|1))))) 'least))
(let () (begin (set! greatest (lambda (.greater?|1 .list|1) (let ((.greatest|2 0)) (begin (set! .greatest|2 (lambda (.greater?|3 .list|3) (reduce (lambda (.a|4 .b|4) (if (.greater?|3 .a|4 .b|4) .a|4 .b|4)) #f .list|3))) (.greatest|2 .greater?|1 .list|1))))) 'greatest))
(let () (begin (set! mappend (lambda (.proc|1 .l|1) (let ((.mappend|2 0)) (begin (set! .mappend|2 (lambda (.proc|3 .l|3) (apply append (let () (let ((.loop|9|12|15 (unspecified))) (begin (set! .loop|9|12|15 (lambda (.y1|4|5|16 .results|4|8|16) (if (null? .y1|4|5|16) (reverse .results|4|8|16) (begin #t (.loop|9|12|15 (let ((.x|20|23 .y1|4|5|16)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) (cons (.proc|3 (let ((.x|24|27 .y1|4|5|16)) (begin (.check! (pair? .x|24|27) 0 .x|24|27) (car:pair .x|24|27)))) .results|4|8|16)))))) (.loop|9|12|15 .l|3 '()))))))) (.mappend|2 .proc|1 .l|1))))) 'mappend))
(let () (begin (set! make-list (lambda (.nelem|1 . .rest|1) (let* ((.val|4 (if (null? .rest|1) #f (let ((.x|7|10 .rest|1)) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10))))) (.loop|5 (unspecified))) (begin (set! .loop|5 (lambda (.n|6 .l|6) (if (zero? .n|6) .l|6 (.loop|5 (- .n|6 1) (cons .val|4 .l|6))))) (.loop|5 .nelem|1 '()))))) 'make-list))
(let () (begin (set! reduce (lambda (.proc|1 .initial|1 .l|1) (let ((.reduce|2 0)) (begin (set! .reduce|2 (lambda (.proc|3 .initial|3 .l|3) (let ((.loop|5 (unspecified))) (begin (set! .loop|5 (lambda (.val|6 .l|6) (if (null? .l|6) .val|6 (.loop|5 (.proc|3 .val|6 (let ((.x|7|10 .l|6)) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10)))) (let ((.x|11|14 .l|6)) (begin (.check! (pair? .x|11|14) 1 .x|11|14) (cdr:pair .x|11|14))))))) (if (null? .l|3) .initial|3 (if (null? (let ((.x|16|19 .l|3)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19)))) (let ((.x|20|23 .l|3)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))) (.loop|5 (let ((.x|25|28 .l|3)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28))) (let ((.x|29|32 .l|3)) (begin (.check! (pair? .x|29|32) 1 .x|29|32) (cdr:pair .x|29|32)))))))))) (.reduce|2 .proc|1 .initial|1 .l|1))))) 'reduce))
(let () (begin (set! reduce-right (lambda (.proc|1 .initial|1 .l|1) (let ((.reduce-right|2 0)) (begin (set! .reduce-right|2 (lambda (.proc|3 .initial|3 .l|3) (let ((.loop|5 (unspecified))) (begin (set! .loop|5 (lambda (.l|6) (if (null? (let ((.x|7|10 .l|6)) (begin (.check! (pair? .x|7|10) 1 .x|7|10) (cdr:pair .x|7|10)))) (let ((.x|11|14 .l|6)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14))) (.proc|3 (let ((.x|15|18 .l|6)) (begin (.check! (pair? .x|15|18) 0 .x|15|18) (car:pair .x|15|18))) (.loop|5 (let ((.x|19|22 .l|6)) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22)))))))) (if (null? .l|3) .initial|3 (if (null? (let ((.x|24|27 .l|3)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27)))) (let ((.x|28|31 .l|3)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31))) (.loop|5 .l|3))))))) (.reduce-right|2 .proc|1 .initial|1 .l|1))))) 'reduce-right))
(let () (begin (set! fold-left (lambda (.proc|1 .initial|1 .l|1) (let ((.fold-left|2 0)) (begin (set! .fold-left|2 (lambda (.proc|3 .initial|3 .l|3) (if (null? .l|3) .initial|3 (.fold-left|2 .proc|3 (.proc|3 .initial|3 (let ((.x|4|7 .l|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7)))) (let ((.x|8|11 .l|3)) (begin (.check! (pair? .x|8|11) 1 .x|8|11) (cdr:pair .x|8|11))))))) (.fold-left|2 .proc|1 .initial|1 .l|1))))) 'fold-left))
(let () (begin (set! fold-right (lambda (.proc|1 .initial|1 .l|1) (let ((.fold-right|2 0)) (begin (set! .fold-right|2 (lambda (.proc|3 .initial|3 .l|3) (if (null? .l|3) .initial|3 (.proc|3 (let ((.x|4|7 .l|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))) (.fold-right|2 .proc|3 .initial|3 (let ((.x|8|11 .l|3)) (begin (.check! (pair? .x|8|11) 1 .x|8|11) (cdr:pair .x|8|11)))))))) (.fold-right|2 .proc|1 .initial|1 .l|1))))) 'fold-right))
(let () (begin (set! iota (lambda (.n|1) (let ((.iota|2 0)) (begin (set! .iota|2 (lambda (.n|3) (let ((.n|6 (- .n|3 1)) (.r|6 '())) (let () (let ((.loop|9 (unspecified))) (begin (set! .loop|9 (lambda (.n|10 .r|10) (let ((.r|13 (cons .n|10 .r|10))) (if (= .n|10 0) .r|13 (.loop|9 (- .n|10 1) .r|13))))) (.loop|9 .n|6 .r|6))))))) (.iota|2 .n|1))))) 'iota))
(let () (begin (set! list-head (lambda (.l|1 .n|1) (let ((.list-head|2 0)) (begin (set! .list-head|2 (lambda (.l|3 .n|3) (if (zero? .n|3) '() (cons (let ((.x|4|7 .l|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))) (.list-head|2 (let ((.x|8|11 .l|3)) (begin (.check! (pair? .x|8|11) 1 .x|8|11) (cdr:pair .x|8|11))) (- .n|3 1)))))) (.list-head|2 .l|1 .n|1))))) 'list-head))
(let () (begin (set! $$trace (lambda (.x|1) (let ((.$$trace|2 0)) (begin (set! .$$trace|2 (lambda (.x|3) #t)) (.$$trace|2 .x|1))))) '$$trace))
(let () (begin (set! host-system 'larceny) 'host-system))
(let () (begin (set! .check! (lambda (.flag|1 .exn|1 . .args|1) (if (not .flag|1) (apply error "Runtime check exception: " .exn|1 .args|1) (unspecified)))) '.check!))
(let () (begin (set! compat:initialize (lambda .rest|1 (if (null? .rest|1) (let ((.dir|4 (nbuild-parameter 'compatibility))) (begin (compat:load (string-append .dir|4 "compat2.sch")) (compat:load (string-append .dir|4 "../../Auxlib/list.sch")) (compat:load (string-append .dir|4 "../../Auxlib/pp.sch")))) (unspecified)))) 'compat:initialize))
(let () (begin (set! with-optimization (lambda (.level|1 .thunk|1) (let ((.with-optimization|2 0)) (begin (set! .with-optimization|2 (lambda (.level|3 .thunk|3) (.thunk|3))) (.with-optimization|2 .level|1 .thunk|1))))) 'with-optimization))
(let () (begin (set! call-with-error-control (lambda (.thunk1|1 .thunk2|1) (let ((.call-with-error-control|2 0)) (begin (set! .call-with-error-control|2 (lambda (.thunk1|3 .thunk2|3) (let ((.eh|6 (error-handler))) (begin (error-handler (lambda .args|7 (begin (error-handler .eh|6) (.thunk2|3) (apply .eh|6 .args|7)))) (.thunk1|3) (error-handler .eh|6))))) (.call-with-error-control|2 .thunk1|1 .thunk2|1))))) 'call-with-error-control))
(let () (begin (set! larc-new-extension (lambda (.fn|1 .ext|1) (let ((.larc-new-extension|2 0)) (begin (set! .larc-new-extension|2 (lambda (.fn|3 .ext|3) (let* ((.l|6 (string-length .fn|3)) (.x|9 (let ((.i|15 (- .l|6 1))) (let () (let ((.loop|18 (unspecified))) (begin (set! .loop|18 (lambda (.i|19) (if (< .i|19 0) #f (if (char=? (string-ref .fn|3 .i|19) #\.) (+ .i|19 1) (.loop|18 (- .i|19 1)))))) (.loop|18 .i|15))))))) (let () (if (not .x|9) (string-append .fn|3 "." .ext|3) (string-append (substring .fn|3 0 .x|9) .ext|3)))))) (.larc-new-extension|2 .fn|1 .ext|1))))) 'larc-new-extension))
(let () (begin (set! compat:load (lambda (.filename|1) (let ((.compat:load|2 0)) (begin (set! .compat:load|2 (lambda (.filename|3) (let ((.loadit|4 (unspecified))) (begin (set! .loadit|4 (lambda (.fn|5) (begin (if (nbuild-parameter 'verbose-load?) (format #t "~a~%" .fn|5) (unspecified)) (load .fn|5)))) (if (nbuild-parameter 'always-source?) (.loadit|4 .filename|3) (let ((.fn|8 (larc-new-extension .filename|3 "fasl"))) (if (if (file-exists? .fn|8) (compat:file-newer? .fn|8 .filename|3) #f) (.loadit|4 .fn|8) (.loadit|4 .filename|3)))))))) (.compat:load|2 .filename|1))))) 'compat:load))
(let () (begin (set! compat:file-newer? (lambda (.a|1 .b|1) (let ((.compat:file-newer?|2 0)) (begin (set! .compat:file-newer?|2 (lambda (.a|3 .b|3) (let* ((.ta|6 (file-modification-time .a|3)) (.tb|9 (file-modification-time .b|3)) (.limit|12 (let ((.v|42|45 .ta|6)) (begin (.check! (vector? .v|42|45) 42 .v|42|45) (vector-length:vec .v|42|45))))) (let () (let ((.i|18 0)) (let () (let ((.loop|21 (unspecified))) (begin (set! .loop|21 (lambda (.i|22) (if (= .i|22 .limit|12) #f (if (= (let ((.v|25|28 .ta|6) (.i|25|28 .i|22)) (begin (.check! (fixnum? .i|25|28) 40 .v|25|28 .i|25|28) (.check! (vector? .v|25|28) 40 .v|25|28 .i|25|28) (.check! (<:fix:fix .i|25|28 (vector-length:vec .v|25|28)) 40 .v|25|28 .i|25|28) (.check! (>=:fix:fix .i|25|28 0) 40 .v|25|28 .i|25|28) (vector-ref:trusted .v|25|28 .i|25|28))) (let ((.v|29|32 .tb|9) (.i|29|32 .i|22)) (begin (.check! (fixnum? .i|29|32) 40 .v|29|32 .i|29|32) (.check! (vector? .v|29|32) 40 .v|29|32 .i|29|32) (.check! (<:fix:fix .i|29|32 (vector-length:vec .v|29|32)) 40 .v|29|32 .i|29|32) (.check! (>=:fix:fix .i|29|32 0) 40 .v|29|32 .i|29|32) (vector-ref:trusted .v|29|32 .i|29|32)))) (.loop|21 (+ .i|22 1)) (> (let ((.v|34|37 .ta|6) (.i|34|37 .i|22)) (begin (.check! (fixnum? .i|34|37) 40 .v|34|37 .i|34|37) (.check! (vector? .v|34|37) 40 .v|34|37 .i|34|37) (.check! (<:fix:fix .i|34|37 (vector-length:vec .v|34|37)) 40 .v|34|37 .i|34|37) (.check! (>=:fix:fix .i|34|37 0) 40 .v|34|37 .i|34|37) (vector-ref:trusted .v|34|37 .i|34|37))) (let ((.v|38|41 .tb|9) (.i|38|41 .i|22)) (begin (.check! (fixnum? .i|38|41) 40 .v|38|41 .i|38|41) (.check! (vector? .v|38|41) 40 .v|38|41 .i|38|41) (.check! (<:fix:fix .i|38|41 (vector-length:vec .v|38|41)) 40 .v|38|41 .i|38|41) (.check! (>=:fix:fix .i|38|41 0) 40 .v|38|41 .i|38|41) (vector-ref:trusted .v|38|41 .i|38|41)))))))) (.loop|21 .i|18))))))))) (.compat:file-newer?|2 .a|1 .b|1))))) 'compat:file-newer?))
(let () (begin (set! host-system 'larceny) 'host-system))
(let () (begin (set! compat:sort (lambda (.list|1 .less?|1) (sort .list|1 .less?|1))) 'compat:sort))
(let () (begin (set! compat:char->integer char->integer) 'compat:char->integer))
(let () (begin (set! write-lop (lambda (.item|1 .port|1) (let ((.write-lop|2 0)) (begin (set! .write-lop|2 (lambda (.item|3 .port|3) (begin (lowlevel-write .item|3 .port|3) (newline .port|3) (newline .port|3)))) (.write-lop|2 .item|1 .port|1))))) 'write-lop))
(let () (begin (set! write-fasl-datum lowlevel-write) 'write-fasl-datum))
(let () (begin (set! misc->bytevector (lambda (.x|1) (let ((.misc->bytevector|2 0)) (begin (set! .misc->bytevector|2 (lambda (.x|3) (let ((.bv|6 (bytevector-like-copy .x|3))) (begin (typetag-set! .bv|6 $tag.bytevector-typetag) .bv|6)))) (.misc->bytevector|2 .x|1))))) 'misc->bytevector))
(let () (begin (set! string->bytevector misc->bytevector) 'string->bytevector))
(let () (begin (set! bignum->bytevector misc->bytevector) 'bignum->bytevector))
(let () (begin (set! flonum->bytevector (lambda (.x|1) (let ((.flonum->bytevector|2 0)) (begin (set! .flonum->bytevector|2 (lambda (.x|3) (clear-first-word (misc->bytevector .x|3)))) (.flonum->bytevector|2 .x|1))))) 'flonum->bytevector))
(let () (begin (set! compnum->bytevector (lambda (.x|1) (let ((.compnum->bytevector|2 0)) (begin (set! .compnum->bytevector|2 (lambda (.x|3) (clear-first-word (misc->bytevector .x|3)))) (.compnum->bytevector|2 .x|1))))) 'compnum->bytevector))
(let () (begin (set! clear-first-word (lambda (.bv|1) (let ((.clear-first-word|2 0)) (begin (set! .clear-first-word|2 (lambda (.bv|3) (begin (bytevector-like-set! .bv|3 0 0) (bytevector-like-set! .bv|3 1 0) (bytevector-like-set! .bv|3 2 0) (bytevector-like-set! .bv|3 3 0) .bv|3))) (.clear-first-word|2 .bv|1))))) 'clear-first-word))
(let () (begin (set! list->bytevector (lambda (.l|1) (let ((.list->bytevector|2 0)) (begin (set! .list->bytevector|2 (lambda (.l|3) (let ((.b|6 (make-bytevector (length .l|3)))) (let () (let ((.loop|7|10|13 (unspecified))) (begin (set! .loop|7|10|13 (lambda (.i|14 .l|14) (if (null? .l|14) .b|6 (begin (begin #t (bytevector-set! .b|6 .i|14 (let ((.x|17|20 .l|14)) (begin (.check! (pair? .x|17|20) 0 .x|17|20) (car:pair .x|17|20))))) (.loop|7|10|13 (+ .i|14 1) (let ((.x|21|24 .l|14)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24)))))))) (.loop|7|10|13 0 .l|3))))))) (.list->bytevector|2 .l|1))))) 'list->bytevector))
(let () (begin (set! bytevector-word-ref (let ((.two^8|3 (expt 2 8)) (.two^16|3 (expt 2 16)) (.two^24|3 (expt 2 24))) (lambda (.bv|4 .i|4) (+ (+ (+ (* (bytevector-ref .bv|4 .i|4) .two^24|3) (* (bytevector-ref .bv|4 (+ .i|4 1)) .two^16|3)) (* (bytevector-ref .bv|4 (+ .i|4 2)) .two^8|3)) (bytevector-ref .bv|4 (+ .i|4 3)))))) 'bytevector-word-ref))
(let () (begin (set! twobit-format (lambda (.fmt|1 . .rest|1) (let ((.out|4 (open-output-string))) (begin (apply format .out|4 .fmt|1 .rest|1) (get-output-string .out|4))))) 'twobit-format))
(let () (begin (set! an-arbitrary-number (lambda () (let ((.an-arbitrary-number|2 0)) (begin (set! .an-arbitrary-number|2 (lambda () (begin (system "echo \\\"`date`\\\" > a-random-number") (let ((.x|6 (string-hash (call-with-input-file "a-random-number" read)))) (begin (delete-file "a-random-number") .x|6))))) (.an-arbitrary-number|2))))) 'an-arbitrary-number))
(let () (begin (set! cerror error) 'cerror))
(let () (begin (set! empty-set (lambda () (let ((.empty-set|2 0)) (begin (set! .empty-set|2 (lambda () '())) (.empty-set|2))))) 'empty-set))
(let () (begin (set! empty-set? (lambda (.x|1) (let ((.empty-set?|2 0)) (begin (set! .empty-set?|2 (lambda (.x|3) (null? .x|3))) (.empty-set?|2 .x|1))))) 'empty-set?))
(let () (begin (set! make-set (lambda (.x|1) (let ((.make-set|2 0)) (begin (set! .make-set|2 (lambda (.x|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.x|5 .y|5) (if (null? .x|5) .y|5 (if (member (let ((.x|8|11 .x|5)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) .y|5) (.loop|4 (let ((.x|12|15 .x|5)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))) .y|5) (.loop|4 (let ((.x|17|20 .x|5)) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))) (cons (let ((.x|21|24 .x|5)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24))) .y|5)))))) (.loop|4 .x|3 '()))))) (.make-set|2 .x|1))))) 'make-set))
(let () (begin (set! set-equal? (lambda (.x|1 .y|1) (let ((.set-equal?|2 0)) (begin (set! .set-equal?|2 (lambda (.x|3 .y|3) (if (subset? .x|3 .y|3) (subset? .y|3 .x|3) #f))) (.set-equal?|2 .x|1 .y|1))))) 'set-equal?))
(let () (begin (set! subset? (lambda (.x|1 .y|1) (let ((.subset?|2 0)) (begin (set! .subset?|2 (lambda (.x|3 .y|3) (every? (lambda (.x|4) (member .x|4 .y|3)) .x|3))) (.subset?|2 .x|1 .y|1))))) 'subset?))
(let () (begin (set! apply-union (undefined)) 'apply-union))
(let () (begin (set! union (let () (let ((.union2|3 (unspecified))) (begin (set! .union2|3 (lambda (.x|4 .y|4) (if (null? .x|4) .y|4 (if (member (let ((.x|7|10 .x|4)) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10))) .y|4) (.union2|3 (let ((.x|11|14 .x|4)) (begin (.check! (pair? .x|11|14) 1 .x|11|14) (cdr:pair .x|11|14))) .y|4) (.union2|3 (let ((.x|16|19 .x|4)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19))) (cons (let ((.x|20|23 .x|4)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))) .y|4)))))) (set! apply-union (lambda (.sets|24) (let () (let ((.loop|25|28|31 (unspecified))) (begin (set! .loop|25|28|31 (lambda (.sets|32 .result|32) (if (null? .sets|32) .result|32 (begin #t (.loop|25|28|31 (let ((.x|35|38 .sets|32)) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))) (.union2|3 (let ((.x|39|42 .sets|32)) (begin (.check! (pair? .x|39|42) 0 .x|39|42) (car:pair .x|39|42))) .result|32)))))) (.loop|25|28|31 .sets|24 '())))))) (lambda .args|43 (if (null? .args|43) '() (if (null? (let ((.x|46|49 .args|43)) (begin (.check! (pair? .x|46|49) 1 .x|46|49) (cdr:pair .x|46|49)))) (let ((.x|50|53 .args|43)) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53))) (if (null? (let ((.x|56|59 (let ((.x|60|63 .args|43)) (begin (.check! (pair? .x|60|63) 1 .x|60|63) (cdr:pair .x|60|63))))) (begin (.check! (pair? .x|56|59) 1 .x|56|59) (cdr:pair .x|56|59)))) (.union2|3 (let ((.x|64|67 .args|43)) (begin (.check! (pair? .x|64|67) 0 .x|64|67) (car:pair .x|64|67))) (let ((.x|69|72 (let ((.x|73|76 .args|43)) (begin (.check! (pair? .x|73|76) 1 .x|73|76) (cdr:pair .x|73|76))))) (begin (.check! (pair? .x|69|72) 0 .x|69|72) (car:pair .x|69|72)))) (.union2|3 (.union2|3 (let ((.x|78|81 .args|43)) (begin (.check! (pair? .x|78|81) 0 .x|78|81) (car:pair .x|78|81))) (let ((.x|83|86 (let ((.x|87|90 .args|43)) (begin (.check! (pair? .x|87|90) 1 .x|87|90) (cdr:pair .x|87|90))))) (begin (.check! (pair? .x|83|86) 0 .x|83|86) (car:pair .x|83|86)))) (apply union (let ((.x|92|95 (let ((.x|96|99 .args|43)) (begin (.check! (pair? .x|96|99) 1 .x|96|99) (cdr:pair .x|96|99))))) (begin (.check! (pair? .x|92|95) 1 .x|92|95) (cdr:pair .x|92|95))))))))))))) 'union))
(let () (begin (set! intersection (let () (let ((.intersection2|3 (unspecified))) (begin (set! .intersection2|3 (lambda (.x|4 .y|4) (if (null? .x|4) '() (if (member (let ((.x|7|10 .x|4)) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10))) .y|4) (cons (let ((.x|11|14 .x|4)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14))) (.intersection2|3 (let ((.x|15|18 .x|4)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))) .y|4)) (.intersection2|3 (let ((.x|20|23 .x|4)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) .y|4))))) (lambda .args|24 (if (null? .args|24) '() (if (null? (let ((.x|27|30 .args|24)) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30)))) (let ((.x|31|34 .args|24)) (begin (.check! (pair? .x|31|34) 0 .x|31|34) (car:pair .x|31|34))) (if (null? (let ((.x|37|40 (let ((.x|41|44 .args|24)) (begin (.check! (pair? .x|41|44) 1 .x|41|44) (cdr:pair .x|41|44))))) (begin (.check! (pair? .x|37|40) 1 .x|37|40) (cdr:pair .x|37|40)))) (.intersection2|3 (let ((.x|45|48 .args|24)) (begin (.check! (pair? .x|45|48) 0 .x|45|48) (car:pair .x|45|48))) (let ((.x|50|53 (let ((.x|54|57 .args|24)) (begin (.check! (pair? .x|54|57) 1 .x|54|57) (cdr:pair .x|54|57))))) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53)))) (.intersection2|3 (.intersection2|3 (let ((.x|59|62 .args|24)) (begin (.check! (pair? .x|59|62) 0 .x|59|62) (car:pair .x|59|62))) (let ((.x|64|67 (let ((.x|68|71 .args|24)) (begin (.check! (pair? .x|68|71) 1 .x|68|71) (cdr:pair .x|68|71))))) (begin (.check! (pair? .x|64|67) 0 .x|64|67) (car:pair .x|64|67)))) (apply intersection (let ((.x|73|76 (let ((.x|77|80 .args|24)) (begin (.check! (pair? .x|77|80) 1 .x|77|80) (cdr:pair .x|77|80))))) (begin (.check! (pair? .x|73|76) 1 .x|73|76) (cdr:pair .x|73|76))))))))))))) 'intersection))
(let () (begin (set! difference (lambda (.x|1 .y|1) (let ((.difference|2 0)) (begin (set! .difference|2 (lambda (.x|3 .y|3) (if (null? .x|3) '() (if (member (let ((.x|6|9 .x|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9))) .y|3) (.difference|2 (let ((.x|10|13 .x|3)) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13))) .y|3) (cons (let ((.x|15|18 .x|3)) (begin (.check! (pair? .x|15|18) 0 .x|15|18) (car:pair .x|15|18))) (.difference|2 (let ((.x|19|22 .x|3)) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22))) .y|3)))))) (.difference|2 .x|1 .y|1))))) 'difference))
(let () (begin (set! object-hash (lambda (.x|1) 0)) 'object-hash))
(let () (begin (set! equal-hash (lambda (.x|1) 0)) 'equal-hash))
(let () (let ((.n|3 16777216) (.n-1|3 16777215) (.adj:fixnum|3 9000000) (.adj:negative|3 8000000) (.adj:large|3 7900000) (.adj:ratnum|3 7800000) (.adj:complex|3 7700000) (.adj:flonum|3 7000000) (.adj:compnum|3 6900000) (.adj:char|3 6111000) (.adj:string|3 5022200) (.adj:vector|3 4003330) (.adj:misc|3 3000444) (.adj:pair|3 2555000) (.adj:proc|3 2321001) (.adj:iport|3 2321002) (.adj:oport|3 2321003) (.adj:weird|3 2321004) (.budget0|3 32)) (let ((.hash-on-equal|4 (unspecified)) (.combine|4 (unspecified))) (begin (set! .hash-on-equal|4 (lambda (.x|5 .budget|5) (if (> .budget|5 0) (if (string? .x|5) (string-hash .x|5) (if (pair? .x|5) (let ((.budget|10 (quotient .budget|5 2))) (.combine|4 (.hash-on-equal|4 (let ((.x|11|14 .x|5)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14))) .budget|10) (.hash-on-equal|4 (let ((.x|15|18 .x|5)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))) .budget|10))) (if (vector? .x|5) (let ((.n|22 (let ((.v|35|38 .x|5)) (begin (.check! (vector? .v|35|38) 42 .v|35|38) (vector-length:vec .v|35|38)))) (.budget|22 (quotient .budget|5 4))) (if (> .n|22 0) (.combine|4 (.combine|4 (.hash-on-equal|4 (let ((.v|23|26 .x|5) (.i|23|26 0)) (begin (.check! (fixnum? .i|23|26) 40 .v|23|26 .i|23|26) (.check! (vector? .v|23|26) 40 .v|23|26 .i|23|26) (.check! (<:fix:fix .i|23|26 (vector-length:vec .v|23|26)) 40 .v|23|26 .i|23|26) (.check! (>=:fix:fix .i|23|26 0) 40 .v|23|26 .i|23|26) (vector-ref:trusted .v|23|26 .i|23|26))) .budget|22) (.hash-on-equal|4 (let ((.v|27|30 .x|5) (.i|27|30 (- .n|22 1))) (begin (.check! (fixnum? .i|27|30) 40 .v|27|30 .i|27|30) (.check! (vector? .v|27|30) 40 .v|27|30 .i|27|30) (.check! (<:fix:fix .i|27|30 (vector-length:vec .v|27|30)) 40 .v|27|30 .i|27|30) (.check! (>=:fix:fix .i|27|30 0) 40 .v|27|30 .i|27|30) (vector-ref:trusted .v|27|30 .i|27|30))) .budget|22)) (.hash-on-equal|4 (let ((.v|31|34 .x|5) (.i|31|34 (quotient .n|22 2))) (begin (.check! (fixnum? .i|31|34) 40 .v|31|34 .i|31|34) (.check! (vector? .v|31|34) 40 .v|31|34 .i|31|34) (.check! (<:fix:fix .i|31|34 (vector-length:vec .v|31|34)) 40 .v|31|34 .i|31|34) (.check! (>=:fix:fix .i|31|34 0) 40 .v|31|34 .i|31|34) (vector-ref:trusted .v|31|34 .i|31|34))) (+ .budget|22 .budget|22))) .adj:vector|3)) (object-hash .x|5)))) .adj:weird|3))) (set! .combine|4 (lambda (.hash|40 .adjustment|40) (modulo (+ (+ (+ .hash|40 .hash|40) .hash|40) .adjustment|40) 16777216))) (set! object-hash (lambda (.x|43) (if (symbol? .x|43) (symbol-hash .x|43) (if (number? .x|43) (if (exact? .x|43) (if (integer? .x|43) (if (< .x|43 0) (.combine|4 (object-hash (- 0 .x|43)) .adj:negative|3) (if (< .x|43 .n|3) (.combine|4 .x|43 .adj:fixnum|3) (.combine|4 (modulo .x|43 .n|3) .adj:large|3))) (if (rational? .x|43) (.combine|4 (.combine|4 (object-hash (numerator .x|43)) .adj:ratnum|3) (object-hash (denominator .x|43))) (if (real? .x|43) .adj:weird|3 (if (complex? .x|43) (.combine|4 (.combine|4 (object-hash (real-part .x|43)) .adj:complex|3) (object-hash (imag-part .x|43))) .adj:weird|3)))) (if #t .adj:flonum|3 (if (rational? .x|43) (.combine|4 (.combine|4 (object-hash (inexact->exact (numerator .x|43))) .adj:flonum|3) (object-hash (inexact->exact (denominator .x|43)))) (if (real? .x|43) .adj:weird|3 (if (complex? .x|43) (.combine|4 (.combine|4 (object-hash (real-part .x|43)) .adj:compnum|3) (object-hash (imag-part .x|43))) .adj:weird|3))))) (if (char? .x|43) (.combine|4 (char->integer .x|43) .adj:char|3) (if (string? .x|43) (.combine|4 (string-length .x|43) .adj:string|3) (if (vector? .x|43) (.combine|4 (let ((.v|64|67 .x|43)) (begin (.check! (vector? .v|64|67) 42 .v|64|67) (vector-length:vec .v|64|67))) .adj:vector|3) (if (eq? .x|43 #t) (.combine|4 1 .adj:misc|3) (if (eq? .x|43 #f) (.combine|4 2 .adj:misc|3) (if (null? .x|43) (.combine|4 3 .adj:misc|3) (if (pair? .x|43) .adj:pair|3 (if (procedure? .x|43) .adj:proc|3 (if (input-port? .x|43) .adj:iport|3 (if (output-port? .x|43) .adj:oport|3 .adj:weird|3)))))))))))))) (set! equal-hash (lambda (.x|76) (.hash-on-equal|4 .x|76 .budget0|3)))))))
(let () (begin (set! make-hashtable (lambda .args|1 '*)) 'make-hashtable))
(let () (begin (set! hashtable-contains? (lambda (.ht|1 .key|1) #f)) 'hashtable-contains?))
(let () (begin (set! hashtable-fetch (lambda (.ht|1 .key|1 .flag|1) .flag|1)) 'hashtable-fetch))
(let () (begin (set! hashtable-get (lambda (.ht|1 .key|1) (hashtable-fetch .ht|1 .key|1 #f))) 'hashtable-get))
(let () (begin (set! hashtable-put! (lambda (.ht|1 .key|1 .val|1) '*)) 'hashtable-put!))
(let () (begin (set! hashtable-remove! (lambda (.ht|1 .key|1) '*)) 'hashtable-remove!))
(let () (begin (set! hashtable-clear! (lambda (.ht|1) '*)) 'hashtable-clear!))
(let () (begin (set! hashtable-size (lambda (.ht|1) 0)) 'hashtable-size))
(let () (begin (set! hashtable-for-each (lambda (.ht|1 .proc|1) '*)) 'hashtable-for-each))
(let () (begin (set! hashtable-map (lambda (.ht|1 .proc|1) '())) 'hashtable-map))
(let () (begin (set! hashtable-copy (lambda (.ht|1) .ht|1)) 'hashtable-copy))
(let () (let ((.doc|3 (cons "HASHTABLE" '())) (.count|3 (lambda (.ht|484) (let ((.v|485|488 .ht|484) (.i|485|488 1)) (begin (.check! (fixnum? .i|485|488) 40 .v|485|488 .i|485|488) (.check! (vector? .v|485|488) 40 .v|485|488 .i|485|488) (.check! (<:fix:fix .i|485|488 (vector-length:vec .v|485|488)) 40 .v|485|488 .i|485|488) (.check! (>=:fix:fix .i|485|488 0) 40 .v|485|488 .i|485|488) (vector-ref:trusted .v|485|488 .i|485|488))))) (.count!|3 (lambda (.ht|489 .n|489) (let ((.v|490|493 .ht|489) (.i|490|493 1) (.x|490|493 .n|489)) (begin (.check! (fixnum? .i|490|493) 41 .v|490|493 .i|490|493 .x|490|493) (.check! (vector? .v|490|493) 41 .v|490|493 .i|490|493 .x|490|493) (.check! (<:fix:fix .i|490|493 (vector-length:vec .v|490|493)) 41 .v|490|493 .i|490|493 .x|490|493) (.check! (>=:fix:fix .i|490|493 0) 41 .v|490|493 .i|490|493 .x|490|493) (vector-set!:trusted .v|490|493 .i|490|493 .x|490|493))))) (.hasher|3 (lambda (.ht|494) (let ((.v|495|498 .ht|494) (.i|495|498 2)) (begin (.check! (fixnum? .i|495|498) 40 .v|495|498 .i|495|498) (.check! (vector? .v|495|498) 40 .v|495|498 .i|495|498) (.check! (<:fix:fix .i|495|498 (vector-length:vec .v|495|498)) 40 .v|495|498 .i|495|498) (.check! (>=:fix:fix .i|495|498 0) 40 .v|495|498 .i|495|498) (vector-ref:trusted .v|495|498 .i|495|498))))) (.searcher|3 (lambda (.ht|499) (let ((.v|500|503 .ht|499) (.i|500|503 3)) (begin (.check! (fixnum? .i|500|503) 40 .v|500|503 .i|500|503) (.check! (vector? .v|500|503) 40 .v|500|503 .i|500|503) (.check! (<:fix:fix .i|500|503 (vector-length:vec .v|500|503)) 40 .v|500|503 .i|500|503) (.check! (>=:fix:fix .i|500|503 0) 40 .v|500|503 .i|500|503) (vector-ref:trusted .v|500|503 .i|500|503))))) (.buckets|3 (lambda (.ht|504) (let ((.v|505|508 .ht|504) (.i|505|508 4)) (begin (.check! (fixnum? .i|505|508) 40 .v|505|508 .i|505|508) (.check! (vector? .v|505|508) 40 .v|505|508 .i|505|508) (.check! (<:fix:fix .i|505|508 (vector-length:vec .v|505|508)) 40 .v|505|508 .i|505|508) (.check! (>=:fix:fix .i|505|508 0) 40 .v|505|508 .i|505|508) (vector-ref:trusted .v|505|508 .i|505|508))))) (.buckets!|3 (lambda (.ht|509 .v|509) (let ((.v|510|513 .ht|509) (.i|510|513 4) (.x|510|513 .v|509)) (begin (.check! (fixnum? .i|510|513) 41 .v|510|513 .i|510|513 .x|510|513) (.check! (vector? .v|510|513) 41 .v|510|513 .i|510|513 .x|510|513) (.check! (<:fix:fix .i|510|513 (vector-length:vec .v|510|513)) 41 .v|510|513 .i|510|513 .x|510|513) (.check! (>=:fix:fix .i|510|513 0) 41 .v|510|513 .i|510|513 .x|510|513) (vector-set!:trusted .v|510|513 .i|510|513 .x|510|513))))) (.defaultn|3 10)) (let ((.hashtable?|6 (lambda (.ht|470) (if (vector? .ht|470) (if (= 5 (let ((.v|473|476 .ht|470)) (begin (.check! (vector? .v|473|476) 42 .v|473|476) (vector-length:vec .v|473|476)))) (eq? .doc|3 (let ((.v|478|481 .ht|470) (.i|478|481 0)) (begin (.check! (fixnum? .i|478|481) 40 .v|478|481 .i|478|481) (.check! (vector? .v|478|481) 40 .v|478|481 .i|478|481) (.check! (<:fix:fix .i|478|481 (vector-length:vec .v|478|481)) 40 .v|478|481 .i|478|481) (.check! (>=:fix:fix .i|478|481 0) 40 .v|478|481 .i|478|481) (vector-ref:trusted .v|478|481 .i|478|481)))) #f) #f))) (.hashtable-error|6 (lambda (.x|482) (begin (display "ERROR: Bad hash table: ") (newline) (write .x|482) (newline))))) (let ((.ht-copy|7 (unspecified)) (.ht-map|7 (unspecified)) (.ht-for-each|7 (unspecified)) (.size|7 (unspecified)) (.clear!|7 (unspecified)) (.remove!|7 (unspecified)) (.put!|7 (unspecified)) (.fetch|7 (unspecified)) (.contains?|7 (unspecified)) (.contents|7 (unspecified)) (.resize|7 (unspecified)) (.remq1|7 (unspecified)) (.substitute1|7 (unspecified)) (.make-ht|7 (unspecified))) (begin (set! .ht-copy|7 (lambda (.ht|8) (if (.hashtable?|6 .ht|8) (let* ((.newtable|11 (make-hashtable (.hasher|3 .ht|8) (.searcher|3 .ht|8) 0)) (.v|14 (.buckets|3 .ht|8)) (.n|17 (let ((.v|42|45 .v|14)) (begin (.check! (vector? .v|42|45) 42 .v|42|45) (vector-length:vec .v|42|45)))) (.newvector|20 (make-vector .n|17 '()))) (let () (begin (.count!|3 .newtable|11 (.count|3 .ht|8)) (.buckets!|3 .newtable|11 .newvector|20) (let () (let ((.loop|25|27|30 (unspecified))) (begin (set! .loop|25|27|30 (lambda (.i|31) (if (= .i|31 .n|17) (if #f #f (unspecified)) (begin (begin #t (let ((.v|34|37 .newvector|20) (.i|34|37 .i|31) (.x|34|37 (append (let ((.v|38|41 .v|14) (.i|38|41 .i|31)) (begin (.check! (fixnum? .i|38|41) 40 .v|38|41 .i|38|41) (.check! (vector? .v|38|41) 40 .v|38|41 .i|38|41) (.check! (<:fix:fix .i|38|41 (vector-length:vec .v|38|41)) 40 .v|38|41 .i|38|41) (.check! (>=:fix:fix .i|38|41 0) 40 .v|38|41 .i|38|41) (vector-ref:trusted .v|38|41 .i|38|41))) '()))) (begin (.check! (fixnum? .i|34|37) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (vector? .v|34|37) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (<:fix:fix .i|34|37 (vector-length:vec .v|34|37)) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (>=:fix:fix .i|34|37 0) 41 .v|34|37 .i|34|37 .x|34|37) (vector-set!:trusted .v|34|37 .i|34|37 .x|34|37)))) (.loop|25|27|30 (+ .i|31 1)))))) (.loop|25|27|30 0)))) .newtable|11))) (.hashtable-error|6 .ht|8)))) (set! .ht-map|7 (lambda (.f|46 .ht|46) (if (.hashtable?|6 .ht|46) (let* ((.v|49 (.contents|7 .ht|46)) (.n|52 (let ((.v|81|84 .v|49)) (begin (.check! (vector? .v|81|84) 42 .v|81|84) (vector-length:vec .v|81|84))))) (let () (let () (let ((.loop|56|59|62 (unspecified))) (begin (set! .loop|56|59|62 (lambda (.j|63 .results|63) (if (= .j|63 .n|52) (reverse .results|63) (begin #t (.loop|56|59|62 (+ .j|63 1) (let ((.x|68 (let ((.v|77|80 .v|49) (.i|77|80 .j|63)) (begin (.check! (fixnum? .i|77|80) 40 .v|77|80 .i|77|80) (.check! (vector? .v|77|80) 40 .v|77|80 .i|77|80) (.check! (<:fix:fix .i|77|80 (vector-length:vec .v|77|80)) 40 .v|77|80 .i|77|80) (.check! (>=:fix:fix .i|77|80 0) 40 .v|77|80 .i|77|80) (vector-ref:trusted .v|77|80 .i|77|80))))) (cons (.f|46 (let ((.x|69|72 .x|68)) (begin (.check! (pair? .x|69|72) 0 .x|69|72) (car:pair .x|69|72))) (let ((.x|73|76 .x|68)) (begin (.check! (pair? .x|73|76) 1 .x|73|76) (cdr:pair .x|73|76)))) .results|63))))))) (.loop|56|59|62 0 '())))))) (.hashtable-error|6 .ht|46)))) (set! .ht-for-each|7 (lambda (.f|85 .ht|85) (if (.hashtable?|6 .ht|85) (let* ((.v|88 (.contents|7 .ht|85)) (.n|91 (let ((.v|120|123 .v|88)) (begin (.check! (vector? .v|120|123) 42 .v|120|123) (vector-length:vec .v|120|123))))) (let () (let () (let ((.loop|96|98|101 (unspecified))) (begin (set! .loop|96|98|101 (lambda (.j|102) (if (= .j|102 .n|91) (if #f #f (unspecified)) (begin (begin #t (let ((.x|107 (let ((.v|116|119 .v|88) (.i|116|119 .j|102)) (begin (.check! (fixnum? .i|116|119) 40 .v|116|119 .i|116|119) (.check! (vector? .v|116|119) 40 .v|116|119 .i|116|119) (.check! (<:fix:fix .i|116|119 (vector-length:vec .v|116|119)) 40 .v|116|119 .i|116|119) (.check! (>=:fix:fix .i|116|119 0) 40 .v|116|119 .i|116|119) (vector-ref:trusted .v|116|119 .i|116|119))))) (.f|85 (let ((.x|108|111 .x|107)) (begin (.check! (pair? .x|108|111) 0 .x|108|111) (car:pair .x|108|111))) (let ((.x|112|115 .x|107)) (begin (.check! (pair? .x|112|115) 1 .x|112|115) (cdr:pair .x|112|115)))))) (.loop|96|98|101 (+ .j|102 1)))))) (.loop|96|98|101 0)))))) (.hashtable-error|6 .ht|85)))) (set! .size|7 (lambda (.ht|124) (if (.hashtable?|6 .ht|124) (.count|3 .ht|124) (.hashtable-error|6 .ht|124)))) (set! .clear!|7 (lambda (.ht|125) (if (.hashtable?|6 .ht|125) (call-without-interrupts (lambda () (begin (.count!|3 .ht|125 0) (.buckets!|3 .ht|125 (make-vector .defaultn|3 '())) #f))) (.hashtable-error|6 .ht|125)))) (set! .remove!|7 (lambda (.ht|127 .key|127) (if (.hashtable?|6 .ht|127) (call-without-interrupts (lambda () (let* ((.v|131 (.buckets|3 .ht|127)) (.n|134 (let ((.v|155|158 .v|131)) (begin (.check! (vector? .v|155|158) 42 .v|155|158) (vector-length:vec .v|155|158)))) (.h|137 (modulo ((.hasher|3 .ht|127) .key|127) .n|134)) (.b|140 (let ((.v|151|154 .v|131) (.i|151|154 .h|137)) (begin (.check! (fixnum? .i|151|154) 40 .v|151|154 .i|151|154) (.check! (vector? .v|151|154) 40 .v|151|154 .i|151|154) (.check! (<:fix:fix .i|151|154 (vector-length:vec .v|151|154)) 40 .v|151|154 .i|151|154) (.check! (>=:fix:fix .i|151|154 0) 40 .v|151|154 .i|151|154) (vector-ref:trusted .v|151|154 .i|151|154)))) (.probe|143 ((.searcher|3 .ht|127) .key|127 .b|140))) (let () (begin (if .probe|143 (begin (.count!|3 .ht|127 (- (.count|3 .ht|127) 1)) (let ((.v|147|150 .v|131) (.i|147|150 .h|137) (.x|147|150 (.remq1|7 .probe|143 .b|140))) (begin (.check! (fixnum? .i|147|150) 41 .v|147|150 .i|147|150 .x|147|150) (.check! (vector? .v|147|150) 41 .v|147|150 .i|147|150 .x|147|150) (.check! (<:fix:fix .i|147|150 (vector-length:vec .v|147|150)) 41 .v|147|150 .i|147|150 .x|147|150) (.check! (>=:fix:fix .i|147|150 0) 41 .v|147|150 .i|147|150 .x|147|150) (vector-set!:trusted .v|147|150 .i|147|150 .x|147|150))) (if (< (* 2 (+ .defaultn|3 (.count|3 .ht|127))) .n|134) (.resize|7 .ht|127) (unspecified))) (unspecified)) #f))))) (.hashtable-error|6 .ht|127)))) (set! .put!|7 (lambda (.ht|159 .key|159 .val|159) (if (.hashtable?|6 .ht|159) (call-without-interrupts (lambda () (begin (let* ((.v|163 (.buckets|3 .ht|159)) (.n|166 (let ((.v|191|194 .v|163)) (begin (.check! (vector? .v|191|194) 42 .v|191|194) (vector-length:vec .v|191|194)))) (.h|169 (modulo ((.hasher|3 .ht|159) .key|159) .n|166)) (.b|172 (let ((.v|187|190 .v|163) (.i|187|190 .h|169)) (begin (.check! (fixnum? .i|187|190) 40 .v|187|190 .i|187|190) (.check! (vector? .v|187|190) 40 .v|187|190 .i|187|190) (.check! (<:fix:fix .i|187|190 (vector-length:vec .v|187|190)) 40 .v|187|190 .i|187|190) (.check! (>=:fix:fix .i|187|190 0) 40 .v|187|190 .i|187|190) (vector-ref:trusted .v|187|190 .i|187|190)))) (.probe|175 ((.searcher|3 .ht|159) .key|159 .b|172))) (let () (if .probe|175 (let ((.v|179|182 .v|163) (.i|179|182 .h|169) (.x|179|182 (.substitute1|7 (cons .key|159 .val|159) .probe|175 .b|172))) (begin (.check! (fixnum? .i|179|182) 41 .v|179|182 .i|179|182 .x|179|182) (.check! (vector? .v|179|182) 41 .v|179|182 .i|179|182 .x|179|182) (.check! (<:fix:fix .i|179|182 (vector-length:vec .v|179|182)) 41 .v|179|182 .i|179|182 .x|179|182) (.check! (>=:fix:fix .i|179|182 0) 41 .v|179|182 .i|179|182 .x|179|182) (vector-set!:trusted .v|179|182 .i|179|182 .x|179|182))) (begin (.count!|3 .ht|159 (+ (.count|3 .ht|159) 1)) (let ((.v|183|186 .v|163) (.i|183|186 .h|169) (.x|183|186 (cons (cons .key|159 .val|159) .b|172))) (begin (.check! (fixnum? .i|183|186) 41 .v|183|186 .i|183|186 .x|183|186) (.check! (vector? .v|183|186) 41 .v|183|186 .i|183|186 .x|183|186) (.check! (<:fix:fix .i|183|186 (vector-length:vec .v|183|186)) 41 .v|183|186 .i|183|186 .x|183|186) (.check! (>=:fix:fix .i|183|186 0) 41 .v|183|186 .i|183|186 .x|183|186) (vector-set!:trusted .v|183|186 .i|183|186 .x|183|186))) (if (> (.count|3 .ht|159) .n|166) (.resize|7 .ht|159) (unspecified)))))) #f))) (.hashtable-error|6 .ht|159)))) (set! .fetch|7 (lambda (.ht|195 .key|195 .flag|195) (if (.hashtable?|6 .ht|195) (let* ((.v|198 (.buckets|3 .ht|195)) (.n|201 (let ((.v|222|225 .v|198)) (begin (.check! (vector? .v|222|225) 42 .v|222|225) (vector-length:vec .v|222|225)))) (.h|204 (modulo ((.hasher|3 .ht|195) .key|195) .n|201)) (.b|207 (let ((.v|218|221 .v|198) (.i|218|221 .h|204)) (begin (.check! (fixnum? .i|218|221) 40 .v|218|221 .i|218|221) (.check! (vector? .v|218|221) 40 .v|218|221 .i|218|221) (.check! (<:fix:fix .i|218|221 (vector-length:vec .v|218|221)) 40 .v|218|221 .i|218|221) (.check! (>=:fix:fix .i|218|221 0) 40 .v|218|221 .i|218|221) (vector-ref:trusted .v|218|221 .i|218|221)))) (.probe|210 ((.searcher|3 .ht|195) .key|195 .b|207))) (let () (if .probe|210 (let ((.x|214|217 .probe|210)) (begin (.check! (pair? .x|214|217) 1 .x|214|217) (cdr:pair .x|214|217))) .flag|195))) (.hashtable-error|6 .ht|195)))) (set! .contains?|7 (lambda (.ht|226 .key|226) (if (.hashtable?|6 .ht|226) (let* ((.v|229 (.buckets|3 .ht|226)) (.n|232 (let ((.v|246|249 .v|229)) (begin (.check! (vector? .v|246|249) 42 .v|246|249) (vector-length:vec .v|246|249)))) (.h|235 (modulo ((.hasher|3 .ht|226) .key|226) .n|232)) (.b|238 (let ((.v|242|245 .v|229) (.i|242|245 .h|235)) (begin (.check! (fixnum? .i|242|245) 40 .v|242|245 .i|242|245) (.check! (vector? .v|242|245) 40 .v|242|245 .i|242|245) (.check! (<:fix:fix .i|242|245 (vector-length:vec .v|242|245)) 40 .v|242|245 .i|242|245) (.check! (>=:fix:fix .i|242|245 0) 40 .v|242|245 .i|242|245) (vector-ref:trusted .v|242|245 .i|242|245))))) (let () (if ((.searcher|3 .ht|226) .key|226 .b|238) #t #f))) (.hashtable-error|6 .ht|226)))) (set! .contents|7 (lambda (.ht|250) (let* ((.v|253 (.buckets|3 .ht|250)) (.n|256 (let ((.v|296|299 .v|253)) (begin (.check! (vector? .v|296|299) 42 .v|296|299) (vector-length:vec .v|296|299)))) (.z|259 (make-vector (.count|3 .ht|250) '()))) (let () (let ((.loop|263 (unspecified))) (begin (set! .loop|263 (lambda (.i|264 .bucket|264 .j|264) (if (null? .bucket|264) (if (= .i|264 .n|256) (if (= .j|264 (let ((.v|265|268 .z|259)) (begin (.check! (vector? .v|265|268) 42 .v|265|268) (vector-length:vec .v|265|268)))) .z|259 (begin (display "BUG in hashtable") (newline) '#())) (.loop|263 (+ .i|264 1) (let ((.v|269|272 .v|253) (.i|269|272 .i|264)) (begin (.check! (fixnum? .i|269|272) 40 .v|269|272 .i|269|272) (.check! (vector? .v|269|272) 40 .v|269|272 .i|269|272) (.check! (<:fix:fix .i|269|272 (vector-length:vec .v|269|272)) 40 .v|269|272 .i|269|272) (.check! (>=:fix:fix .i|269|272 0) 40 .v|269|272 .i|269|272) (vector-ref:trusted .v|269|272 .i|269|272))) .j|264)) (let ((.entry|275 (let ((.x|292|295 .bucket|264)) (begin (.check! (pair? .x|292|295) 0 .x|292|295) (car:pair .x|292|295))))) (begin (let ((.v|276|279 .z|259) (.i|276|279 .j|264) (.x|276|279 (cons (let ((.x|280|283 .entry|275)) (begin (.check! (pair? .x|280|283) 0 .x|280|283) (car:pair .x|280|283))) (let ((.x|284|287 .entry|275)) (begin (.check! (pair? .x|284|287) 1 .x|284|287) (cdr:pair .x|284|287)))))) (begin (.check! (fixnum? .i|276|279) 41 .v|276|279 .i|276|279 .x|276|279) (.check! (vector? .v|276|279) 41 .v|276|279 .i|276|279 .x|276|279) (.check! (<:fix:fix .i|276|279 (vector-length:vec .v|276|279)) 41 .v|276|279 .i|276|279 .x|276|279) (.check! (>=:fix:fix .i|276|279 0) 41 .v|276|279 .i|276|279 .x|276|279) (vector-set!:trusted .v|276|279 .i|276|279 .x|276|279))) (.loop|263 .i|264 (let ((.x|288|291 .bucket|264)) (begin (.check! (pair? .x|288|291) 1 .x|288|291) (cdr:pair .x|288|291))) (+ .j|264 1))))))) (.loop|263 0 '() 0))))))) (set! .resize|7 (lambda (.ht0|300) (call-without-interrupts (lambda () (let ((.ht|304 (.make-ht|7 (.hasher|3 .ht0|300) (.searcher|3 .ht0|300) (+ 1 (* 2 (.count|3 .ht0|300)))))) (begin (.ht-for-each|7 (lambda (.key|305 .val|305) (.put!|7 .ht|304 .key|305 .val|305)) .ht0|300) (.buckets!|3 .ht0|300 (.buckets|3 .ht|304)))))))) (set! .remq1|7 (lambda (.x|306 .y|306) (if (eq? .x|306 (let ((.x|308|311 .y|306)) (begin (.check! (pair? .x|308|311) 0 .x|308|311) (car:pair .x|308|311)))) (let ((.x|312|315 .y|306)) (begin (.check! (pair? .x|312|315) 1 .x|312|315) (cdr:pair .x|312|315))) (cons (let ((.x|317|320 .y|306)) (begin (.check! (pair? .x|317|320) 0 .x|317|320) (car:pair .x|317|320))) (.remq1|7 .x|306 (let ((.x|321|324 .y|306)) (begin (.check! (pair? .x|321|324) 1 .x|321|324) (cdr:pair .x|321|324)))))))) (set! .substitute1|7 (lambda (.x|325 .y|325 .z|325) (if (eq? .y|325 (let ((.x|327|330 .z|325)) (begin (.check! (pair? .x|327|330) 0 .x|327|330) (car:pair .x|327|330)))) (cons .x|325 (let ((.x|331|334 .z|325)) (begin (.check! (pair? .x|331|334) 1 .x|331|334) (cdr:pair .x|331|334)))) (cons (let ((.x|336|339 .z|325)) (begin (.check! (pair? .x|336|339) 0 .x|336|339) (car:pair .x|336|339))) (.substitute1|7 .x|325 .y|325 (let ((.x|340|343 .z|325)) (begin (.check! (pair? .x|340|343) 1 .x|340|343) (cdr:pair .x|340|343)))))))) (set! .make-ht|7 (lambda (.hashfun|344 .searcher|344 .size|344) (let* ((.t|345|350|355 (make-vector .size|344 '())) (.t|345|349|358 .searcher|344) (.t|345|348|361 .hashfun|344) (.t|345|347|364 0) (.t|345|346|367 .doc|3) (.v|345|352|370 (make-vector 5 .t|345|350|355))) (let () (begin (let ((.v|374|377 .v|345|352|370) (.i|374|377 3) (.x|374|377 .t|345|349|358)) (begin (.check! (fixnum? .i|374|377) 41 .v|374|377 .i|374|377 .x|374|377) (.check! (vector? .v|374|377) 41 .v|374|377 .i|374|377 .x|374|377) (.check! (<:fix:fix .i|374|377 (vector-length:vec .v|374|377)) 41 .v|374|377 .i|374|377 .x|374|377) (.check! (>=:fix:fix .i|374|377 0) 41 .v|374|377 .i|374|377 .x|374|377) (vector-set!:trusted .v|374|377 .i|374|377 .x|374|377))) (let ((.v|378|381 .v|345|352|370) (.i|378|381 2) (.x|378|381 .t|345|348|361)) (begin (.check! (fixnum? .i|378|381) 41 .v|378|381 .i|378|381 .x|378|381) (.check! (vector? .v|378|381) 41 .v|378|381 .i|378|381 .x|378|381) (.check! (<:fix:fix .i|378|381 (vector-length:vec .v|378|381)) 41 .v|378|381 .i|378|381 .x|378|381) (.check! (>=:fix:fix .i|378|381 0) 41 .v|378|381 .i|378|381 .x|378|381) (vector-set!:trusted .v|378|381 .i|378|381 .x|378|381))) (let ((.v|382|385 .v|345|352|370) (.i|382|385 1) (.x|382|385 .t|345|347|364)) (begin (.check! (fixnum? .i|382|385) 41 .v|382|385 .i|382|385 .x|382|385) (.check! (vector? .v|382|385) 41 .v|382|385 .i|382|385 .x|382|385) (.check! (<:fix:fix .i|382|385 (vector-length:vec .v|382|385)) 41 .v|382|385 .i|382|385 .x|382|385) (.check! (>=:fix:fix .i|382|385 0) 41 .v|382|385 .i|382|385 .x|382|385) (vector-set!:trusted .v|382|385 .i|382|385 .x|382|385))) (let ((.v|386|389 .v|345|352|370) (.i|386|389 0) (.x|386|389 .t|345|346|367)) (begin (.check! (fixnum? .i|386|389) 41 .v|386|389 .i|386|389 .x|386|389) (.check! (vector? .v|386|389) 41 .v|386|389 .i|386|389 .x|386|389) (.check! (<:fix:fix .i|386|389 (vector-length:vec .v|386|389)) 41 .v|386|389 .i|386|389 .x|386|389) (.check! (>=:fix:fix .i|386|389 0) 41 .v|386|389 .i|386|389 .x|386|389) (vector-set!:trusted .v|386|389 .i|386|389 .x|386|389))) .v|345|352|370))))) (set! make-hashtable (lambda .args|390 (let* ((.hashfun|393 (if (null? .args|390) object-hash (let ((.x|456|459 .args|390)) (begin (.check! (pair? .x|456|459) 0 .x|456|459) (car:pair .x|456|459))))) (.searcher|396 (if (let ((.temp|438|441 (null? .args|390))) (if .temp|438|441 .temp|438|441 (null? (let ((.x|443|446 .args|390)) (begin (.check! (pair? .x|443|446) 1 .x|443|446) (cdr:pair .x|443|446)))))) assv (let ((.x|448|451 (let ((.x|452|455 .args|390)) (begin (.check! (pair? .x|452|455) 1 .x|452|455) (cdr:pair .x|452|455))))) (begin (.check! (pair? .x|448|451) 0 .x|448|451) (car:pair .x|448|451))))) (.size|399 (if (let ((.temp|403|406 (null? .args|390))) (if .temp|403|406 .temp|403|406 (let ((.temp|407|410 (null? (let ((.x|421|424 .args|390)) (begin (.check! (pair? .x|421|424) 1 .x|421|424) (cdr:pair .x|421|424)))))) (if .temp|407|410 .temp|407|410 (null? (let ((.x|413|416 (let ((.x|417|420 .args|390)) (begin (.check! (pair? .x|417|420) 1 .x|417|420) (cdr:pair .x|417|420))))) (begin (.check! (pair? .x|413|416) 1 .x|413|416) (cdr:pair .x|413|416)))))))) .defaultn|3 (let ((.x|426|429 (let ((.x|430|433 (let ((.x|434|437 .args|390)) (begin (.check! (pair? .x|434|437) 1 .x|434|437) (cdr:pair .x|434|437))))) (begin (.check! (pair? .x|430|433) 1 .x|430|433) (cdr:pair .x|430|433))))) (begin (.check! (pair? .x|426|429) 0 .x|426|429) (car:pair .x|426|429)))))) (let () (.make-ht|7 .hashfun|393 .searcher|396 .size|399))))) (set! hashtable-contains? (lambda (.ht|460 .key|460) (.contains?|7 .ht|460 .key|460))) (set! hashtable-fetch (lambda (.ht|461 .key|461 .flag|461) (.fetch|7 .ht|461 .key|461 .flag|461))) (set! hashtable-get (lambda (.ht|462 .key|462) (.fetch|7 .ht|462 .key|462 #f))) (set! hashtable-put! (lambda (.ht|463 .key|463 .val|463) (.put!|7 .ht|463 .key|463 .val|463))) (set! hashtable-remove! (lambda (.ht|464 .key|464) (.remove!|7 .ht|464 .key|464))) (set! hashtable-clear! (lambda (.ht|465) (.clear!|7 .ht|465))) (set! hashtable-size (lambda (.ht|466) (.size|7 .ht|466))) (set! hashtable-for-each (lambda (.ht|467 .proc|467) (.ht-for-each|7 .ht|467 .proc|467))) (set! hashtable-map (lambda (.ht|468 .proc|468) (.ht-map|7 .ht|468 .proc|468))) (set! hashtable-copy (lambda (.ht|469) (.ht-copy|7 .ht|469))) #f)))))
(let () (begin (set! make-hashtree (lambda .args|1 '*)) 'make-hashtree))
(let () (begin (set! hashtree-contains? (lambda (.ht|1 .key|1) #f)) 'hashtree-contains?))
(let () (begin (set! hashtree-fetch (lambda (.ht|1 .key|1 .flag|1) .flag|1)) 'hashtree-fetch))
(let () (begin (set! hashtree-get (lambda (.ht|1 .key|1) (hashtree-fetch .ht|1 .key|1 #f))) 'hashtree-get))
(let () (begin (set! hashtree-put (lambda (.ht|1 .key|1 .val|1) '*)) 'hashtree-put))
(let () (begin (set! hashtree-remove (lambda (.ht|1 .key|1) '*)) 'hashtree-remove))
(let () (begin (set! hashtree-size (lambda (.ht|1) 0)) 'hashtree-size))
(let () (begin (set! hashtree-for-each (lambda (.ht|1 .proc|1) '*)) 'hashtree-for-each))
(let () (begin (set! hashtree-map (lambda (.ht|1 .proc|1) '())) 'hashtree-map))
(let () (let ((.doc|3 (cons "hashtree" '())) (.count|3 (lambda (.ht|334) (let ((.v|335|338 .ht|334) (.i|335|338 1)) (begin (.check! (fixnum? .i|335|338) 40 .v|335|338 .i|335|338) (.check! (vector? .v|335|338) 40 .v|335|338 .i|335|338) (.check! (<:fix:fix .i|335|338 (vector-length:vec .v|335|338)) 40 .v|335|338 .i|335|338) (.check! (>=:fix:fix .i|335|338 0) 40 .v|335|338 .i|335|338) (vector-ref:trusted .v|335|338 .i|335|338))))) (.hasher|3 (lambda (.ht|339) (let ((.v|340|343 .ht|339) (.i|340|343 2)) (begin (.check! (fixnum? .i|340|343) 40 .v|340|343 .i|340|343) (.check! (vector? .v|340|343) 40 .v|340|343 .i|340|343) (.check! (<:fix:fix .i|340|343 (vector-length:vec .v|340|343)) 40 .v|340|343 .i|340|343) (.check! (>=:fix:fix .i|340|343 0) 40 .v|340|343 .i|340|343) (vector-ref:trusted .v|340|343 .i|340|343))))) (.searcher|3 (lambda (.ht|344) (let ((.v|345|348 .ht|344) (.i|345|348 3)) (begin (.check! (fixnum? .i|345|348) 40 .v|345|348 .i|345|348) (.check! (vector? .v|345|348) 40 .v|345|348 .i|345|348) (.check! (<:fix:fix .i|345|348 (vector-length:vec .v|345|348)) 40 .v|345|348 .i|345|348) (.check! (>=:fix:fix .i|345|348 0) 40 .v|345|348 .i|345|348) (vector-ref:trusted .v|345|348 .i|345|348))))) (.buckets|3 (lambda (.ht|349) (let ((.v|350|353 .ht|349) (.i|350|353 4)) (begin (.check! (fixnum? .i|350|353) 40 .v|350|353 .i|350|353) (.check! (vector? .v|350|353) 40 .v|350|353 .i|350|353) (.check! (<:fix:fix .i|350|353 (vector-length:vec .v|350|353)) 40 .v|350|353 .i|350|353) (.check! (>=:fix:fix .i|350|353 0) 40 .v|350|353 .i|350|353) (vector-ref:trusted .v|350|353 .i|350|353))))) (.make-empty-buckets|3 (lambda () '())) (.make-buckets|3 (lambda (.h|355 .alist|355 .buckets1|355 .buckets2|355) (let* ((.t1|356|359 .h|355) (.t2|356|362 (let* ((.t1|366|369 .alist|355) (.t2|366|372 (let* ((.t1|376|379 .buckets1|355) (.t2|376|382 (cons .buckets2|355 '()))) (let () (cons .t1|376|379 .t2|376|382))))) (let () (cons .t1|366|369 .t2|366|372))))) (let () (cons .t1|356|359 .t2|356|362))))) (.buckets-empty?|3 (lambda (.buckets|387) (null? .buckets|387))) (.buckets-n|3 (lambda (.buckets|388) (let ((.x|389|392 .buckets|388)) (begin (.check! (pair? .x|389|392) 0 .x|389|392) (car:pair .x|389|392))))) (.buckets-alist|3 (lambda (.buckets|393) (let ((.x|395|398 (let ((.x|399|402 .buckets|393)) (begin (.check! (pair? .x|399|402) 1 .x|399|402) (cdr:pair .x|399|402))))) (begin (.check! (pair? .x|395|398) 0 .x|395|398) (car:pair .x|395|398))))) (.buckets-left|3 (lambda (.buckets|403) (let ((.x|405|408 (let ((.x|409|412 (let ((.x|413|416 .buckets|403)) (begin (.check! (pair? .x|413|416) 1 .x|413|416) (cdr:pair .x|413|416))))) (begin (.check! (pair? .x|409|412) 1 .x|409|412) (cdr:pair .x|409|412))))) (begin (.check! (pair? .x|405|408) 0 .x|405|408) (car:pair .x|405|408))))) (.buckets-right|3 (lambda (.buckets|417) (let ((.x|419|422 (let ((.x|423|426 (let ((.x|427|430 (let ((.x|431|434 .buckets|417)) (begin (.check! (pair? .x|431|434) 1 .x|431|434) (cdr:pair .x|431|434))))) (begin (.check! (pair? .x|427|430) 1 .x|427|430) (cdr:pair .x|427|430))))) (begin (.check! (pair? .x|423|426) 1 .x|423|426) (cdr:pair .x|423|426))))) (begin (.check! (pair? .x|419|422) 0 .x|419|422) (car:pair .x|419|422)))))) (let ((.hashtree?|6 (lambda (.ht|320) (if (vector? .ht|320) (if (= 5 (let ((.v|323|326 .ht|320)) (begin (.check! (vector? .v|323|326) 42 .v|323|326) (vector-length:vec .v|323|326)))) (eq? .doc|3 (let ((.v|328|331 .ht|320) (.i|328|331 0)) (begin (.check! (fixnum? .i|328|331) 40 .v|328|331 .i|328|331) (.check! (vector? .v|328|331) 40 .v|328|331 .i|328|331) (.check! (<:fix:fix .i|328|331 (vector-length:vec .v|328|331)) 40 .v|328|331 .i|328|331) (.check! (>=:fix:fix .i|328|331 0) 40 .v|328|331 .i|328|331) (vector-ref:trusted .v|328|331 .i|328|331)))) #f) #f))) (.hashtree-error|6 (lambda (.x|332) (begin (display "ERROR: Bad hash tree: ") (newline) (write .x|332) (newline))))) (let ((.ht-map|7 (unspecified)) (.ht-for-each|7 (unspecified)) (.size|7 (unspecified)) (.remove|7 (unspecified)) (.put|7 (unspecified)) (.find-bucket|7 (unspecified)) (.fetch|7 (unspecified)) (.contains?|7 (unspecified)) (.contents|7 (unspecified)) (.remq1|7 (unspecified)) (.substitute1|7 (unspecified)) (.make-ht|7 (unspecified))) (begin (set! .ht-map|7 (lambda (.f|8 .ht|8) (if (.hashtree?|6 .ht|8) (let () (let ((.loop|14|17|20 (unspecified))) (begin (set! .loop|14|17|20 (lambda (.y1|9|10|21 .results|9|13|21) (if (null? .y1|9|10|21) (reverse .results|9|13|21) (begin #t (.loop|14|17|20 (let ((.x|25|28 .y1|9|10|21)) (begin (.check! (pair? .x|25|28) 1 .x|25|28) (cdr:pair .x|25|28))) (cons (let ((.association|29 (let ((.x|38|41 .y1|9|10|21)) (begin (.check! (pair? .x|38|41) 0 .x|38|41) (car:pair .x|38|41))))) (.f|8 (let ((.x|30|33 .association|29)) (begin (.check! (pair? .x|30|33) 0 .x|30|33) (car:pair .x|30|33))) (let ((.x|34|37 .association|29)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37))))) .results|9|13|21)))))) (.loop|14|17|20 (.contents|7 .ht|8) '())))) (.hashtree-error|6 .ht|8)))) (set! .ht-for-each|7 (lambda (.f|42 .ht|42) (if (.hashtree?|6 .ht|42) (let () (let ((.loop|48|50|53 (unspecified))) (begin (set! .loop|48|50|53 (lambda (.y1|43|44|54) (if (null? .y1|43|44|54) (if #f #f (unspecified)) (begin (begin #t (let ((.association|58 (let ((.x|67|70 .y1|43|44|54)) (begin (.check! (pair? .x|67|70) 0 .x|67|70) (car:pair .x|67|70))))) (.f|42 (let ((.x|59|62 .association|58)) (begin (.check! (pair? .x|59|62) 0 .x|59|62) (car:pair .x|59|62))) (let ((.x|63|66 .association|58)) (begin (.check! (pair? .x|63|66) 1 .x|63|66) (cdr:pair .x|63|66)))))) (.loop|48|50|53 (let ((.x|71|74 .y1|43|44|54)) (begin (.check! (pair? .x|71|74) 1 .x|71|74) (cdr:pair .x|71|74)))))))) (.loop|48|50|53 (.contents|7 .ht|42))))) (.hashtree-error|6 .ht|42)))) (set! .size|7 (lambda (.ht|75) (if (.hashtree?|6 .ht|75) (.count|3 .ht|75) (.hashtree-error|6 .ht|75)))) (set! .remove|7 (lambda (.ht|76 .key|76) (if (.hashtree?|6 .ht|76) (let ((.t|79 (.buckets|3 .ht|76)) (.h|79 ((.hasher|3 .ht|76) .key|76)) (.c|79 (.count|3 .ht|76))) (let ((.remove|82 (unspecified))) (begin (set! .remove|82 (lambda (.t|83 .h|83) (if (.buckets-empty?|3 .t|83) .t|83 (let ((.n|86 (.buckets-n|3 .t|83)) (.alist|86 (.buckets-alist|3 .t|83)) (.left|86 (.buckets-left|3 .t|83)) (.right|86 (.buckets-right|3 .t|83))) (if (< .h|83 .n|86) (.make-buckets|3 .n|86 .alist|86 (.remove|82 .left|86 .h|83) .right|86) (if (< .n|86 .h|83) (.make-buckets|3 .n|86 .alist|86 .left|86 (.remove|82 .right|86 .h|83)) (let ((.probe|92 ((.searcher|3 .ht|76) .key|76 .alist|86))) (if .probe|92 (begin (set! .c|79 (- .c|79 1)) (.make-buckets|3 .n|86 (.remq1|7 .probe|92 .alist|86) .left|86 .right|86)) .t|83)))))))) (let ((.buckets|93 (.remove|82 .t|79 .h|79))) (.make-ht|7 .c|79 (.hasher|3 .ht|76) (.searcher|3 .ht|76) .buckets|93))))) (.hashtree-error|6 .ht|76)))) (set! .put|7 (lambda (.ht|94 .key|94 .val|94) (if (.hashtree?|6 .ht|94) (let ((.t|97 (.buckets|3 .ht|94)) (.h|97 ((.hasher|3 .ht|94) .key|94)) (.association|97 (cons .key|94 .val|94)) (.c|97 (.count|3 .ht|94))) (let ((.put|100 (unspecified))) (begin (set! .put|100 (lambda (.t|101 .h|101) (if (.buckets-empty?|3 .t|101) (begin (set! .c|97 (+ .c|97 1)) (.make-buckets|3 .h|101 (cons .association|97 '()) .t|101 .t|101)) (let ((.n|105 (.buckets-n|3 .t|101)) (.alist|105 (.buckets-alist|3 .t|101)) (.left|105 (.buckets-left|3 .t|101)) (.right|105 (.buckets-right|3 .t|101))) (if (< .h|101 .n|105) (.make-buckets|3 .n|105 .alist|105 (.put|100 (.buckets-left|3 .t|101) .h|101) .right|105) (if (< .n|105 .h|101) (.make-buckets|3 .n|105 .alist|105 .left|105 (.put|100 (.buckets-right|3 .t|101) .h|101)) (let ((.probe|111 ((.searcher|3 .ht|94) .key|94 .alist|105))) (if .probe|111 (.make-buckets|3 .n|105 (.substitute1|7 .association|97 .probe|111 .alist|105) .left|105 .right|105) (begin (set! .c|97 (+ .c|97 1)) (.make-buckets|3 .n|105 (cons .association|97 .alist|105) .left|105 .right|105)))))))))) (let ((.buckets|112 (.put|100 .t|97 .h|97))) (.make-ht|7 .c|97 (.hasher|3 .ht|94) (.searcher|3 .ht|94) .buckets|112))))) (.hashtree-error|6 .ht|94)))) (set! .find-bucket|7 (lambda (.t|113 .h|113) (if (.buckets-empty?|3 .t|113) '() (let ((.n|116 (.buckets-n|3 .t|113))) (if (< .h|113 .n|116) (.find-bucket|7 (.buckets-left|3 .t|113) .h|113) (if (< .n|116 .h|113) (.find-bucket|7 (.buckets-right|3 .t|113) .h|113) (.buckets-alist|3 .t|113))))))) (set! .fetch|7 (lambda (.ht|120 .key|120 .flag|120) (if (.hashtree?|6 .ht|120) (let* ((.t|123 (.buckets|3 .ht|120)) (.h|126 ((.hasher|3 .ht|120) .key|120)) (.probe|129 ((.searcher|3 .ht|120) .key|120 (.find-bucket|7 .t|123 .h|126)))) (let () (if .probe|129 (let ((.x|133|136 .probe|129)) (begin (.check! (pair? .x|133|136) 1 .x|133|136) (cdr:pair .x|133|136))) .flag|120))) (.hashtree-error|6 .ht|120)))) (set! .contains?|7 (lambda (.ht|137 .key|137) (if (.hashtree?|6 .ht|137) (let* ((.t|140 (.buckets|3 .ht|137)) (.h|143 ((.hasher|3 .ht|137) .key|137))) (let () (if ((.searcher|3 .ht|137) .key|137 (.find-bucket|7 .t|140 .h|143)) #t #f))) (.hashtree-error|6 .ht|137)))) (set! .contents|7 (lambda (.ht|147) (let ((.t|150 (.buckets|3 .ht|147))) (let () (let ((.randomize-combine|154 (unspecified)) (.randomize3|154 (unspecified)) (.randomize2|154 (unspecified)) (.randomize1|154 (unspecified)) (.append-reverse|154 (unspecified)) (.contents|154 (unspecified))) (begin (set! .randomize-combine|154 (lambda (.alist1|155 .alist2|155 .alist3|155) (if (null? .alist2|155) .alist1|155 (if (null? .alist3|155) (.append-reverse|154 .alist2|155 .alist1|155) (.append-reverse|154 (.randomize1|154 .alist3|155 '() '() '()) (.append-reverse|154 (.randomize1|154 .alist1|155 '() '() '()) (.randomize1|154 .alist2|155 '() '() '()))))))) (set! .randomize3|154 (lambda (.alist|159 .alist1|159 .alist2|159 .alist3|159) (if (null? .alist|159) (.randomize-combine|154 .alist1|159 .alist2|159 .alist3|159) (.randomize1|154 (let ((.x|160|163 .alist|159)) (begin (.check! (pair? .x|160|163) 1 .x|160|163) (cdr:pair .x|160|163))) .alist1|159 .alist2|159 (cons (let ((.x|164|167 .alist|159)) (begin (.check! (pair? .x|164|167) 0 .x|164|167) (car:pair .x|164|167))) .alist3|159))))) (set! .randomize2|154 (lambda (.alist|168 .alist1|168 .alist2|168 .alist3|168) (if (null? .alist|168) (.randomize-combine|154 .alist1|168 .alist2|168 .alist3|168) (.randomize3|154 (let ((.x|169|172 .alist|168)) (begin (.check! (pair? .x|169|172) 1 .x|169|172) (cdr:pair .x|169|172))) .alist1|168 (cons (let ((.x|173|176 .alist|168)) (begin (.check! (pair? .x|173|176) 0 .x|173|176) (car:pair .x|173|176))) .alist2|168) .alist3|168)))) (set! .randomize1|154 (lambda (.alist|177 .alist1|177 .alist2|177 .alist3|177) (if (null? .alist|177) (.randomize-combine|154 .alist1|177 .alist2|177 .alist3|177) (.randomize2|154 (let ((.x|178|181 .alist|177)) (begin (.check! (pair? .x|178|181) 1 .x|178|181) (cdr:pair .x|178|181))) (cons (let ((.x|182|185 .alist|177)) (begin (.check! (pair? .x|182|185) 0 .x|182|185) (car:pair .x|182|185))) .alist1|177) .alist2|177 .alist3|177)))) (set! .append-reverse|154 (lambda (.x|186 .y|186) (if (null? .x|186) .y|186 (.append-reverse|154 (let ((.x|187|190 .x|186)) (begin (.check! (pair? .x|187|190) 1 .x|187|190) (cdr:pair .x|187|190))) (cons (let ((.x|191|194 .x|186)) (begin (.check! (pair? .x|191|194) 0 .x|191|194) (car:pair .x|191|194))) .y|186))))) (set! .contents|154 (lambda (.t|195 .alist|195) (if (.buckets-empty?|3 .t|195) .alist|195 (.contents|154 (.buckets-left|3 .t|195) (.contents|154 (.buckets-right|3 .t|195) (.append-reverse|154 (.buckets-alist|3 .t|195) .alist|195)))))) (.randomize1|154 (.contents|154 .t|150 '()) '() '() '()))))))) (set! .remq1|7 (lambda (.x|196 .y|196) (if (eq? .x|196 (let ((.x|198|201 .y|196)) (begin (.check! (pair? .x|198|201) 0 .x|198|201) (car:pair .x|198|201)))) (let ((.x|202|205 .y|196)) (begin (.check! (pair? .x|202|205) 1 .x|202|205) (cdr:pair .x|202|205))) (cons (let ((.x|207|210 .y|196)) (begin (.check! (pair? .x|207|210) 0 .x|207|210) (car:pair .x|207|210))) (.remq1|7 .x|196 (let ((.x|211|214 .y|196)) (begin (.check! (pair? .x|211|214) 1 .x|211|214) (cdr:pair .x|211|214)))))))) (set! .substitute1|7 (lambda (.x|215 .y|215 .z|215) (if (eq? .y|215 (let ((.x|217|220 .z|215)) (begin (.check! (pair? .x|217|220) 0 .x|217|220) (car:pair .x|217|220)))) (cons .x|215 (let ((.x|221|224 .z|215)) (begin (.check! (pair? .x|221|224) 1 .x|221|224) (cdr:pair .x|221|224)))) (cons (let ((.x|226|229 .z|215)) (begin (.check! (pair? .x|226|229) 0 .x|226|229) (car:pair .x|226|229))) (.substitute1|7 .x|215 .y|215 (let ((.x|230|233 .z|215)) (begin (.check! (pair? .x|230|233) 1 .x|230|233) (cdr:pair .x|230|233)))))))) (set! .make-ht|7 (lambda (.count|234 .hashfun|234 .searcher|234 .buckets|234) (let* ((.t|235|240|245 .buckets|234) (.t|235|239|248 .searcher|234) (.t|235|238|251 .hashfun|234) (.t|235|237|254 .count|234) (.t|235|236|257 .doc|3) (.v|235|242|260 (make-vector 5 .t|235|240|245))) (let () (begin (let ((.v|264|267 .v|235|242|260) (.i|264|267 3) (.x|264|267 .t|235|239|248)) (begin (.check! (fixnum? .i|264|267) 41 .v|264|267 .i|264|267 .x|264|267) (.check! (vector? .v|264|267) 41 .v|264|267 .i|264|267 .x|264|267) (.check! (<:fix:fix .i|264|267 (vector-length:vec .v|264|267)) 41 .v|264|267 .i|264|267 .x|264|267) (.check! (>=:fix:fix .i|264|267 0) 41 .v|264|267 .i|264|267 .x|264|267) (vector-set!:trusted .v|264|267 .i|264|267 .x|264|267))) (let ((.v|268|271 .v|235|242|260) (.i|268|271 2) (.x|268|271 .t|235|238|251)) (begin (.check! (fixnum? .i|268|271) 41 .v|268|271 .i|268|271 .x|268|271) (.check! (vector? .v|268|271) 41 .v|268|271 .i|268|271 .x|268|271) (.check! (<:fix:fix .i|268|271 (vector-length:vec .v|268|271)) 41 .v|268|271 .i|268|271 .x|268|271) (.check! (>=:fix:fix .i|268|271 0) 41 .v|268|271 .i|268|271 .x|268|271) (vector-set!:trusted .v|268|271 .i|268|271 .x|268|271))) (let ((.v|272|275 .v|235|242|260) (.i|272|275 1) (.x|272|275 .t|235|237|254)) (begin (.check! (fixnum? .i|272|275) 41 .v|272|275 .i|272|275 .x|272|275) (.check! (vector? .v|272|275) 41 .v|272|275 .i|272|275 .x|272|275) (.check! (<:fix:fix .i|272|275 (vector-length:vec .v|272|275)) 41 .v|272|275 .i|272|275 .x|272|275) (.check! (>=:fix:fix .i|272|275 0) 41 .v|272|275 .i|272|275 .x|272|275) (vector-set!:trusted .v|272|275 .i|272|275 .x|272|275))) (let ((.v|276|279 .v|235|242|260) (.i|276|279 0) (.x|276|279 .t|235|236|257)) (begin (.check! (fixnum? .i|276|279) 41 .v|276|279 .i|276|279 .x|276|279) (.check! (vector? .v|276|279) 41 .v|276|279 .i|276|279 .x|276|279) (.check! (<:fix:fix .i|276|279 (vector-length:vec .v|276|279)) 41 .v|276|279 .i|276|279 .x|276|279) (.check! (>=:fix:fix .i|276|279 0) 41 .v|276|279 .i|276|279 .x|276|279) (vector-set!:trusted .v|276|279 .i|276|279 .x|276|279))) .v|235|242|260))))) (set! make-hashtree (lambda .args|280 (let* ((.hashfun|283 (if (null? .args|280) object-hash (let ((.x|308|311 .args|280)) (begin (.check! (pair? .x|308|311) 0 .x|308|311) (car:pair .x|308|311))))) (.searcher|286 (if (let ((.temp|290|293 (null? .args|280))) (if .temp|290|293 .temp|290|293 (null? (let ((.x|295|298 .args|280)) (begin (.check! (pair? .x|295|298) 1 .x|295|298) (cdr:pair .x|295|298)))))) assv (let ((.x|300|303 (let ((.x|304|307 .args|280)) (begin (.check! (pair? .x|304|307) 1 .x|304|307) (cdr:pair .x|304|307))))) (begin (.check! (pair? .x|300|303) 0 .x|300|303) (car:pair .x|300|303)))))) (let () (.make-ht|7 0 .hashfun|283 .searcher|286 (.make-empty-buckets|3)))))) (set! hashtree-contains? (lambda (.ht|312 .key|312) (.contains?|7 .ht|312 .key|312))) (set! hashtree-fetch (lambda (.ht|313 .key|313 .flag|313) (.fetch|7 .ht|313 .key|313 .flag|313))) (set! hashtree-get (lambda (.ht|314 .key|314) (.fetch|7 .ht|314 .key|314 #f))) (set! hashtree-put (lambda (.ht|315 .key|315 .val|315) (.put|7 .ht|315 .key|315 .val|315))) (set! hashtree-remove (lambda (.ht|316 .key|316) (.remove|7 .ht|316 .key|316))) (set! hashtree-size (lambda (.ht|317) (.size|7 .ht|317))) (set! hashtree-for-each (lambda (.ht|318 .proc|318) (.ht-for-each|7 .ht|318 .proc|318))) (set! hashtree-map (lambda (.ht|319 .proc|319) (.ht-map|7 .ht|319 .proc|319))) #f)))))
(let () (begin (set! make-twobit-flag (undefined)) 'make-twobit-flag))
(let () (begin (set! display-twobit-flag (undefined)) 'display-twobit-flag))
(let () (begin (set! make-twobit-flag (lambda (.name|1) (let ((.display-flag|4 (unspecified)) (.twobit-warning|4 (unspecified))) (begin (set! .display-flag|4 (lambda (.state|5) (begin (display (if .state|5 "  + " "  - ")) (display .name|1) (display " is ") (display (if .state|5 "on" "off")) (newline)))) (set! .twobit-warning|4 (lambda () (begin (display "Error: incorrect arguments to ") (write .name|1) (newline) (reset)))) (let ((.state|7 #t)) (lambda .args|8 (if (null? .args|8) .state|7 (if (if (null? (let ((.x|12|15 .args|8)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15)))) (boolean? (let ((.x|17|20 .args|8)) (begin (.check! (pair? .x|17|20) 0 .x|17|20) (car:pair .x|17|20)))) #f) (begin (set! .state|7 (let ((.x|21|24 .args|8)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24)))) .state|7) (if (if (null? (let ((.x|27|30 .args|8)) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30)))) (eq? (let ((.x|32|35 .args|8)) (begin (.check! (pair? .x|32|35) 0 .x|32|35) (car:pair .x|32|35))) 'display) #f) (.display-flag|4 .state|7) (.twobit-warning|4)))))))))) 'make-twobit-flag))
(let () (begin (set! display-twobit-flag (lambda (.flag|1) (let ((.display-twobit-flag|2 0)) (begin (set! .display-twobit-flag|2 (lambda (.flag|3) (.flag|3 'display))) (.display-twobit-flag|2 .flag|1))))) 'display-twobit-flag))
(let () (begin (set! issue-warnings (make-twobit-flag 'issue-warnings)) 'issue-warnings))
(let () (begin (set! include-source-code (make-twobit-flag 'include-source-code)) 'include-source-code))
(let () (begin (set! include-variable-names (make-twobit-flag 'include-variable-names)) 'include-variable-names))
(let () (begin (set! include-procedure-names (make-twobit-flag 'include-procedure-names)) 'include-procedure-names))
(let () (begin (set! avoid-space-leaks (make-twobit-flag 'avoid-space-leaks)) 'avoid-space-leaks))
(let () (begin (set! integrate-usual-procedures (make-twobit-flag 'integrate-usual-procedures)) 'integrate-usual-procedures))
(let () (begin (set! control-optimization (make-twobit-flag 'control-optimization)) 'control-optimization))
(let () (begin (set! parallel-assignment-optimization (make-twobit-flag 'parallel-assignment-optimization)) 'parallel-assignment-optimization))
(let () (begin (set! lambda-optimization (make-twobit-flag 'lambda-optimization)) 'lambda-optimization))
(let () (begin (set! benchmark-mode (make-twobit-flag 'benchmark-mode)) 'benchmark-mode))
(let () (begin (set! benchmark-block-mode (make-twobit-flag 'benchmark-block-mode)) 'benchmark-block-mode))
(let () (begin (set! global-optimization (make-twobit-flag 'global-optimization)) 'global-optimization))
(let () (begin (set! interprocedural-inlining (make-twobit-flag 'interprocedural-inlining)) 'interprocedural-inlining))
(let () (begin (set! interprocedural-constant-propagation (make-twobit-flag 'interprocedural-constant-propagation)) 'interprocedural-constant-propagation))
(let () (begin (set! common-subexpression-elimination (make-twobit-flag 'common-subexpression-elimination)) 'common-subexpression-elimination))
(let () (begin (set! representation-inference (make-twobit-flag 'representation-inference)) 'representation-inference))
(let () (begin (set! local-optimization (make-twobit-flag 'local-optimization)) 'local-optimization))
(let () (begin (set! ignore-space-leaks (lambda .args|1 (if (null? .args|1) (not (avoid-space-leaks)) (avoid-space-leaks (not (let ((.x|2|5 .args|1)) (begin (.check! (pair? .x|2|5) 0 .x|2|5) (car:pair .x|2|5)))))))) 'ignore-space-leaks))
(let () (begin (set! lambda-optimizations lambda-optimization) 'lambda-optimizations))
(let () (begin (set! local-optimizations local-optimization) 'local-optimizations))
(let () (begin (set! set-compiler-flags! (lambda (.how|1) (let ((.set-compiler-flags!|2 0)) (begin (set! .set-compiler-flags!|2 (lambda (.how|3) (let ((.temp|4|7 .how|3)) (if (memv .temp|4|7 '(no-optimization)) (begin (.set-compiler-flags!|2 'standard) (avoid-space-leaks #t) (integrate-usual-procedures #f) (control-optimization #f) (parallel-assignment-optimization #f) (lambda-optimization #f) (benchmark-mode #f) (benchmark-block-mode #f) (global-optimization #f) (interprocedural-inlining #f) (interprocedural-constant-propagation #f) (common-subexpression-elimination #f) (representation-inference #f) (local-optimization #f)) (if (memv .temp|4|7 '(standard)) (begin (issue-warnings #t) (include-source-code #f) (include-procedure-names #t) (include-variable-names #t) (avoid-space-leaks #f) (runtime-safety-checking #t) (integrate-usual-procedures #f) (control-optimization #t) (parallel-assignment-optimization #t) (lambda-optimization #t) (benchmark-mode #f) (benchmark-block-mode #f) (global-optimization #t) (interprocedural-inlining #t) (interprocedural-constant-propagation #t) (common-subexpression-elimination #t) (representation-inference #t) (local-optimization #t)) (if (memv .temp|4|7 '(fast-safe)) (let ((.bbmode|13 (benchmark-block-mode))) (begin (.set-compiler-flags!|2 'standard) (integrate-usual-procedures #t) (benchmark-mode #t) (benchmark-block-mode .bbmode|13))) (if (memv .temp|4|7 '(fast-unsafe)) (begin (.set-compiler-flags!|2 'fast-safe) (runtime-safety-checking #f)) (error "set-compiler-flags!: unknown mode " .how|3)))))))) (.set-compiler-flags!|2 .how|1))))) 'set-compiler-flags!))
(let () (begin (set! display-twobit-flags (lambda (.which|1) (let ((.display-twobit-flags|2 0)) (begin (set! .display-twobit-flags|2 (lambda (.which|3) (let ((.temp|4|7 .which|3)) (if (memv .temp|4|7 '(debugging)) (begin (display-twobit-flag issue-warnings) (display-twobit-flag include-procedure-names) (display-twobit-flag include-variable-names) (display-twobit-flag include-source-code)) (if (memv .temp|4|7 '(safety)) (display-twobit-flag avoid-space-leaks) (if (memv .temp|4|7 '(optimization)) (begin (display-twobit-flag integrate-usual-procedures) (display-twobit-flag control-optimization) (display-twobit-flag parallel-assignment-optimization) (display-twobit-flag lambda-optimization) (display-twobit-flag benchmark-mode) (display-twobit-flag benchmark-block-mode) (display-twobit-flag global-optimization) (if (global-optimization) (begin (display "  ") (display-twobit-flag interprocedural-inlining) (display "  ") (display-twobit-flag interprocedural-constant-propagation) (display "  ") (display-twobit-flag common-subexpression-elimination) (display "  ") (display-twobit-flag representation-inference)) (unspecified)) (display-twobit-flag local-optimization)) #t)))))) (.display-twobit-flags|2 .which|1))))) 'display-twobit-flags))
(let () ($$trace "pass1.aux"))
(let () (begin (set! @maxargs-with-rest-arg@ 1000000) '@maxargs-with-rest-arg@))
(let () (begin (set! prim-entry (lambda (.name|1) (let ((.prim-entry|2 0)) (begin (set! .prim-entry|2 (lambda (.name|3) #f)) (.prim-entry|2 .name|1))))) 'prim-entry))
(let () (begin (set! prim-arity (lambda (.name|1) (let ((.prim-arity|2 0)) (begin (set! .prim-arity|2 (lambda (.name|3) 0)) (.prim-arity|2 .name|1))))) 'prim-arity))
(let () (begin (set! prim-opcodename (lambda (.name|1) (let ((.prim-opcodename|2 0)) (begin (set! .prim-opcodename|2 (lambda (.name|3) .name|3)) (.prim-opcodename|2 .name|1))))) 'prim-opcodename))
(let () (begin (set! m-warn (lambda (.msg|1 . .more|1) (if (issue-warnings) (begin (display "WARNING from macro expander:") (newline) (display .msg|1) (newline) (let ((.f|2|5|8 (lambda (.x|28) (begin (write .x|28) (newline))))) (let () (let ((.loop|10|12|15 (unspecified))) (begin (set! .loop|10|12|15 (lambda (.y1|2|3|16) (if (null? .y1|2|3|16) (if #f #f (unspecified)) (begin (begin #t (.f|2|5|8 (let ((.x|20|23 .y1|2|3|16)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))))) (.loop|10|12|15 (let ((.x|24|27 .y1|2|3|16)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27)))))))) (.loop|10|12|15 .more|1)))))) (unspecified)))) 'm-warn))
(let () (begin (set! m-error (lambda (.msg|1 . .more|1) (begin (display "ERROR detected during macro expansion:") (newline) (display .msg|1) (newline) (let ((.f|2|5|8 (lambda (.x|28) (begin (write .x|28) (newline))))) (let () (let ((.loop|10|12|15 (unspecified))) (begin (set! .loop|10|12|15 (lambda (.y1|2|3|16) (if (null? .y1|2|3|16) (if #f #f (unspecified)) (begin (begin #t (.f|2|5|8 (let ((.x|20|23 .y1|2|3|16)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))))) (.loop|10|12|15 (let ((.x|24|27 .y1|2|3|16)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27)))))))) (.loop|10|12|15 .more|1))))) (m-quit (make-constant #f))))) 'm-error))
(let () (begin (set! m-bug (lambda (.msg|1 . .more|1) (begin (display "BUG in macro expander: ") (newline) (display .msg|1) (newline) (let ((.f|2|5|8 (lambda (.x|28) (begin (write .x|28) (newline))))) (let () (let ((.loop|10|12|15 (unspecified))) (begin (set! .loop|10|12|15 (lambda (.y1|2|3|16) (if (null? .y1|2|3|16) (if #f #f (unspecified)) (begin (begin #t (.f|2|5|8 (let ((.x|20|23 .y1|2|3|16)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))))) (.loop|10|12|15 (let ((.x|24|27 .y1|2|3|16)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27)))))))) (.loop|10|12|15 .more|1))))) (m-quit (make-constant #f))))) 'm-bug))
(let () '(define (make-null-terminated x) (cond ((null? x) '()) ((pair? x) (cons (car x) (make-null-terminated (cdr x)))) (else (list x)))))
(let () (begin (set! safe-length (lambda (.x|1) (let ((.safe-length|2 0)) (begin (set! .safe-length|2 (lambda (.x|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.x|5 .n|5) (if (null? .x|5) .n|5 (if (pair? .x|5) (.loop|4 (let ((.x|8|11 .x|5)) (begin (.check! (pair? .x|8|11) 1 .x|8|11) (cdr:pair .x|8|11))) (+ .n|5 1)) -1)))) (.loop|4 .x|3 0))))) (.safe-length|2 .x|1))))) 'safe-length))
(let () (begin (set! filter1 (lambda (.p|1 .x|1) (let ((.filter1|2 0)) (begin (set! .filter1|2 (lambda (.p|3 .x|3) (if (null? .x|3) '() (if (.p|3 (let ((.x|6|9 .x|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9)))) (cons (let ((.x|10|13 .x|3)) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13))) (.filter1|2 .p|3 (let ((.x|14|17 .x|3)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))))) (.filter1|2 .p|3 (let ((.x|19|22 .x|3)) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22)))))))) (.filter1|2 .p|1 .x|1))))) 'filter1))
(let () (begin (set! every1? (lambda (.p|1 .x|1) (let ((.every1?|2 0)) (begin (set! .every1?|2 (lambda (.p|3 .x|3) (if (null? .x|3) #t (if (.p|3 (let ((.x|6|9 .x|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9)))) (.every1?|2 .p|3 (let ((.x|10|13 .x|3)) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13)))) #f)))) (.every1?|2 .p|1 .x|1))))) 'every1?))
(let () (begin (set! union2 (lambda (.x|1 .y|1) (let ((.union2|2 0)) (begin (set! .union2|2 (lambda (.x|3 .y|3) (if (null? .x|3) .y|3 (if (member (let ((.x|6|9 .x|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9))) .y|3) (.union2|2 (let ((.x|10|13 .x|3)) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13))) .y|3) (.union2|2 (let ((.x|15|18 .x|3)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))) (cons (let ((.x|19|22 .x|3)) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22))) .y|3)))))) (.union2|2 .x|1 .y|1))))) 'union2))
(let () (begin (set! copy-alist (lambda (.alist|1) (let ((.copy-alist|2 0)) (begin (set! .copy-alist|2 (lambda (.alist|3) (let () (let ((.loop|9|12|15 (unspecified))) (begin (set! .loop|9|12|15 (lambda (.y1|4|5|16 .results|4|8|16) (if (null? .y1|4|5|16) (reverse .results|4|8|16) (begin #t (.loop|9|12|15 (let ((.x|20|23 .y1|4|5|16)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) (cons (let ((.x|24 (let ((.x|33|36 .y1|4|5|16)) (begin (.check! (pair? .x|33|36) 0 .x|33|36) (car:pair .x|33|36))))) (cons (let ((.x|25|28 .x|24)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28))) (let ((.x|29|32 .x|24)) (begin (.check! (pair? .x|29|32) 1 .x|29|32) (cdr:pair .x|29|32))))) .results|4|8|16)))))) (.loop|9|12|15 .alist|3 '())))))) (.copy-alist|2 .alist|1))))) 'copy-alist))
(let () '(define remq! (letrec ((loop (lambda (x y prev) (cond ((null? y) #t) ((eq? x (car y)) (set-cdr! prev (cdr y)) (loop x (cdr prev) prev)) (else (loop x (cdr y) y)))))) (lambda (x y) (cond ((null? y) '()) ((eq? x (car y)) (remq! x (cdr y))) (else (loop x (cdr y) y) y))))))
(let () (begin (set! integrable? (lambda (.name|1) (let ((.integrable?|2 0)) (begin (set! .integrable?|2 (lambda (.name|3) (if (integrate-usual-procedures) (prim-entry .name|3) #f))) (.integrable?|2 .name|1))))) 'integrable?))
(let () (begin (set! make-readable (lambda (.exp|1 . .rest|1) (let ((.fancy?|4 (if (not (null? .rest|1)) (let ((.x|963|966 .rest|1)) (begin (.check! (pair? .x|963|966) 0 .x|963|966) (car:pair .x|963|966))) #f))) (let ((.make-readable-let*|5 (unspecified)) (.make-readable-let|5 (unspecified)) (.make-readable-call|5 (unspecified)) (.make-readable-quote|5 (unspecified)) (.make-readable|5 (unspecified))) (begin (set! .make-readable-let*|5 (lambda (.exp|6 .vars|6 .inits|6 .defs|6) (if (if (null? .defs|6) (if (call? .exp|6) (if (lambda? (call.proc .exp|6)) (= 1 (length (lambda.args (call.proc .exp|6)))) #f) #f) #f) (let ((.proc|13 (call.proc .exp|6)) (.arg|13 (let ((.x|92|95 (call.args .exp|6))) (begin (.check! (pair? .x|92|95) 0 .x|92|95) (car:pair .x|92|95))))) (if (if (call? .arg|13) (if (lambda? (call.proc .arg|13)) (if (= 1 (length (lambda.args (call.proc .arg|13)))) (null? (lambda.defs (call.proc .arg|13))) #f) #f) #f) (.make-readable-let*|5 (make-call .proc|13 (cons (lambda.body (call.proc .arg|13)) '())) (cons (let ((.x|19|22 (lambda.args (call.proc .arg|13)))) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22))) .vars|6) (cons (.make-readable|5 (let ((.x|23|26 (call.args .arg|13))) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26)))) .inits|6) '()) (.make-readable-let*|5 (lambda.body .proc|13) (cons (let ((.x|27|30 (lambda.args .proc|13))) (begin (.check! (pair? .x|27|30) 0 .x|27|30) (car:pair .x|27|30))) .vars|6) (cons (.make-readable|5 (let ((.x|31|34 (call.args .exp|6))) (begin (.check! (pair? .x|31|34) 0 .x|31|34) (car:pair .x|31|34)))) .inits|6) (let () (let ((.loop|40|43|46 (unspecified))) (begin (set! .loop|40|43|46 (lambda (.y1|35|36|47 .results|35|39|47) (if (null? .y1|35|36|47) (reverse .results|35|39|47) (begin #t (.loop|40|43|46 (let ((.x|51|54 .y1|35|36|47)) (begin (.check! (pair? .x|51|54) 1 .x|51|54) (cdr:pair .x|51|54))) (cons (let ((.def|55 (let ((.x|88|91 .y1|35|36|47)) (begin (.check! (pair? .x|88|91) 0 .x|88|91) (car:pair .x|88|91))))) (.cons 'define (.cons (def.lhs .def|55) (.cons (.make-readable|5 (def.rhs .def|55)) '())))) .results|35|39|47)))))) (.loop|40|43|46 (reverse (lambda.defs .proc|13)) '()))))))) (if (let ((.temp|97|100 (not (null? .vars|6)))) (if .temp|97|100 .temp|97|100 (not (null? .defs|6)))) (.cons 'let* (.cons (let () (let ((.loop|147|151|154 (unspecified))) (begin (set! .loop|147|151|154 (lambda (.y1|141|143|155 .y1|141|142|155 .results|141|146|155) (if (let ((.temp|157|160 (null? .y1|141|143|155))) (if .temp|157|160 .temp|157|160 (null? .y1|141|142|155))) (reverse .results|141|146|155) (begin #t (.loop|147|151|154 (let ((.x|163|166 .y1|141|143|155)) (begin (.check! (pair? .x|163|166) 1 .x|163|166) (cdr:pair .x|163|166))) (let ((.x|167|170 .y1|141|142|155)) (begin (.check! (pair? .x|167|170) 1 .x|167|170) (cdr:pair .x|167|170))) (cons (let* ((.t1|171|174 (let ((.x|186|189 .y1|141|143|155)) (begin (.check! (pair? .x|186|189) 0 .x|186|189) (car:pair .x|186|189)))) (.t2|171|177 (cons (let ((.x|182|185 .y1|141|142|155)) (begin (.check! (pair? .x|182|185) 0 .x|182|185) (car:pair .x|182|185))) '()))) (let () (cons .t1|171|174 .t2|171|177))) .results|141|146|155)))))) (.loop|147|151|154 (reverse .vars|6) (reverse .inits|6) '())))) (append .defs|6 (.cons (.make-readable|5 .exp|6) '())))) (if (if (call? .exp|6) (lambda? (call.proc .exp|6)) #f) (let ((.proc|195 (call.proc .exp|6))) (.cons 'let (.cons (let () (let ((.loop|241|245|248 (unspecified))) (begin (set! .loop|241|245|248 (lambda (.y1|235|237|249 .y1|235|236|249 .results|235|240|249) (if (let ((.temp|251|254 (null? .y1|235|237|249))) (if .temp|251|254 .temp|251|254 (null? .y1|235|236|249))) (reverse .results|235|240|249) (begin #t (.loop|241|245|248 (let ((.x|257|260 .y1|235|237|249)) (begin (.check! (pair? .x|257|260) 1 .x|257|260) (cdr:pair .x|257|260))) (let ((.x|261|264 .y1|235|236|249)) (begin (.check! (pair? .x|261|264) 1 .x|261|264) (cdr:pair .x|261|264))) (cons (let* ((.t1|265|268 (let ((.x|280|283 .y1|235|237|249)) (begin (.check! (pair? .x|280|283) 0 .x|280|283) (car:pair .x|280|283)))) (.t2|265|271 (cons (let ((.x|276|279 .y1|235|236|249)) (begin (.check! (pair? .x|276|279) 0 .x|276|279) (car:pair .x|276|279))) '()))) (let () (cons .t1|265|268 .t2|265|271))) .results|235|240|249)))))) (.loop|241|245|248 (lambda.args .proc|195) (let () (let ((.loop|289|292|295 (unspecified))) (begin (set! .loop|289|292|295 (lambda (.y1|284|285|296 .results|284|288|296) (if (null? .y1|284|285|296) (reverse .results|284|288|296) (begin #t (.loop|289|292|295 (let ((.x|300|303 .y1|284|285|296)) (begin (.check! (pair? .x|300|303) 1 .x|300|303) (cdr:pair .x|300|303))) (cons (.make-readable|5 (let ((.x|304|307 .y1|284|285|296)) (begin (.check! (pair? .x|304|307) 0 .x|304|307) (car:pair .x|304|307)))) .results|284|288|296)))))) (.loop|289|292|295 (call.args .exp|6) '())))) '())))) (append (let () (let ((.loop|313|316|319 (unspecified))) (begin (set! .loop|313|316|319 (lambda (.y1|308|309|320 .results|308|312|320) (if (null? .y1|308|309|320) (reverse .results|308|312|320) (begin #t (.loop|313|316|319 (let ((.x|324|327 .y1|308|309|320)) (begin (.check! (pair? .x|324|327) 1 .x|324|327) (cdr:pair .x|324|327))) (cons (let ((.def|328 (let ((.x|361|364 .y1|308|309|320)) (begin (.check! (pair? .x|361|364) 0 .x|361|364) (car:pair .x|361|364))))) (.cons 'define (.cons (def.lhs .def|328) (.cons (.make-readable|5 (def.rhs .def|328)) '())))) .results|308|312|320)))))) (.loop|313|316|319 (lambda.defs .proc|195) '())))) (.cons (.make-readable|5 (lambda.body .proc|195)) '()))))) (.make-readable|5 .exp|6)))))) (set! .make-readable-let|5 (lambda (.exp|366) (let* ((.l|369 (call.proc .exp|366)) (.formals|372 (lambda.args .l|369)) (.args|375 (let () (let ((.loop|646|649|652 (unspecified))) (begin (set! .loop|646|649|652 (lambda (.y1|641|642|653 .results|641|645|653) (if (null? .y1|641|642|653) (reverse .results|641|645|653) (begin #t (.loop|646|649|652 (let ((.x|657|660 .y1|641|642|653)) (begin (.check! (pair? .x|657|660) 1 .x|657|660) (cdr:pair .x|657|660))) (cons (.make-readable|5 (let ((.x|661|664 .y1|641|642|653)) (begin (.check! (pair? .x|661|664) 0 .x|661|664) (car:pair .x|661|664)))) .results|641|645|653)))))) (.loop|646|649|652 (call.args .exp|366) '()))))) (.body|378 (.make-readable|5 (lambda.body .l|369)))) (let () (if (if (null? (lambda.defs .l|369)) (if (= (length .args|375) 1) (if (pair? .body|378) (let ((.temp|386|389 (if (eq? (let ((.x|396|399 .body|378)) (begin (.check! (pair? .x|396|399) 0 .x|396|399) (car:pair .x|396|399))) 'let) (= (length (let ((.x|402|405 (let ((.x|406|409 .body|378)) (begin (.check! (pair? .x|406|409) 1 .x|406|409) (cdr:pair .x|406|409))))) (begin (.check! (pair? .x|402|405) 0 .x|402|405) (car:pair .x|402|405)))) 1) #f))) (if .temp|386|389 .temp|386|389 (eq? (let ((.x|391|394 .body|378)) (begin (.check! (pair? .x|391|394) 0 .x|391|394) (car:pair .x|391|394))) 'let*))) #f) #f) #f) (.cons 'let* (.cons (.cons (.cons (let ((.x|470|473 .formals|372)) (begin (.check! (pair? .x|470|473) 0 .x|470|473) (car:pair .x|470|473))) (.cons (let ((.x|474|477 .args|375)) (begin (.check! (pair? .x|474|477) 0 .x|474|477) (car:pair .x|474|477))) '())) (let ((.x|479|482 (let ((.x|483|486 .body|378)) (begin (.check! (pair? .x|483|486) 1 .x|483|486) (cdr:pair .x|483|486))))) (begin (.check! (pair? .x|479|482) 0 .x|479|482) (car:pair .x|479|482)))) (let ((.x|488|491 (let ((.x|492|495 .body|378)) (begin (.check! (pair? .x|492|495) 1 .x|492|495) (cdr:pair .x|492|495))))) (begin (.check! (pair? .x|488|491) 1 .x|488|491) (cdr:pair .x|488|491))))) (.cons 'let (.cons (let () (let ((.loop|541|545|548 (unspecified))) (begin (set! .loop|541|545|548 (lambda (.y1|535|537|549 .y1|535|536|549 .results|535|540|549) (if (let ((.temp|551|554 (null? .y1|535|537|549))) (if .temp|551|554 .temp|551|554 (null? .y1|535|536|549))) (reverse .results|535|540|549) (begin #t (.loop|541|545|548 (let ((.x|557|560 .y1|535|537|549)) (begin (.check! (pair? .x|557|560) 1 .x|557|560) (cdr:pair .x|557|560))) (let ((.x|561|564 .y1|535|536|549)) (begin (.check! (pair? .x|561|564) 1 .x|561|564) (cdr:pair .x|561|564))) (cons (let* ((.t1|565|568 (let ((.x|580|583 .y1|535|537|549)) (begin (.check! (pair? .x|580|583) 0 .x|580|583) (car:pair .x|580|583)))) (.t2|565|571 (cons (let ((.x|576|579 .y1|535|536|549)) (begin (.check! (pair? .x|576|579) 0 .x|576|579) (car:pair .x|576|579))) '()))) (let () (cons .t1|565|568 .t2|565|571))) .results|535|540|549)))))) (.loop|541|545|548 (lambda.args .l|369) .args|375 '())))) (append (let () (let ((.loop|589|592|595 (unspecified))) (begin (set! .loop|589|592|595 (lambda (.y1|584|585|596 .results|584|588|596) (if (null? .y1|584|585|596) (reverse .results|584|588|596) (begin #t (.loop|589|592|595 (let ((.x|600|603 .y1|584|585|596)) (begin (.check! (pair? .x|600|603) 1 .x|600|603) (cdr:pair .x|600|603))) (cons (let ((.def|604 (let ((.x|637|640 .y1|584|585|596)) (begin (.check! (pair? .x|637|640) 0 .x|637|640) (car:pair .x|637|640))))) (.cons 'define (.cons (def.lhs .def|604) (.cons (.make-readable|5 (def.rhs .def|604)) '())))) .results|584|588|596)))))) (.loop|589|592|595 (lambda.defs .l|369) '())))) (.cons .body|378 '()))))))))) (set! .make-readable-call|5 (lambda (.exp|665) (let ((.proc|668 (call.proc .exp|665))) (if (if .fancy?|4 (if (lambda? .proc|668) (list? (lambda.args .proc|668)) #f) #f) (.make-readable-let|5 .exp|665) (.cons (.make-readable|5 (call.proc .exp|665)) (let () (let ((.loop|696|699|702 (unspecified))) (begin (set! .loop|696|699|702 (lambda (.y1|691|692|703 .results|691|695|703) (if (null? .y1|691|692|703) (reverse .results|691|695|703) (begin #t (.loop|696|699|702 (let ((.x|707|710 .y1|691|692|703)) (begin (.check! (pair? .x|707|710) 1 .x|707|710) (cdr:pair .x|707|710))) (cons (.make-readable|5 (let ((.x|711|714 .y1|691|692|703)) (begin (.check! (pair? .x|711|714) 0 .x|711|714) (car:pair .x|711|714)))) .results|691|695|703)))))) (.loop|696|699|702 (call.args .exp|665) '()))))))))) (set! .make-readable-quote|5 (lambda (.exp|715) (let ((.x|718 (constant.value .exp|715))) (if (if .fancy?|4 (let ((.temp|721|724 (boolean? .x|718))) (if .temp|721|724 .temp|721|724 (let ((.temp|725|728 (number? .x|718))) (if .temp|725|728 .temp|725|728 (let ((.temp|729|732 (char? .x|718))) (if .temp|729|732 .temp|729|732 (string? .x|718))))))) #f) .x|718 .exp|715)))) (set! .make-readable|5 (lambda (.exp|734) (let ((.temp|735|738 (let ((.x|957|960 .exp|734)) (begin (.check! (pair? .x|957|960) 0 .x|957|960) (car:pair .x|957|960))))) (if (memv .temp|735|738 '(quote)) (.make-readable-quote|5 .exp|734) (if (memv .temp|735|738 '(lambda)) (.cons 'lambda (.cons (lambda.args .exp|734) (append (let () (let ((.loop|785|788|791 (unspecified))) (begin (set! .loop|785|788|791 (lambda (.y1|780|781|792 .results|780|784|792) (if (null? .y1|780|781|792) (reverse .results|780|784|792) (begin #t (.loop|785|788|791 (let ((.x|796|799 .y1|780|781|792)) (begin (.check! (pair? .x|796|799) 1 .x|796|799) (cdr:pair .x|796|799))) (cons (let ((.def|800 (let ((.x|833|836 .y1|780|781|792)) (begin (.check! (pair? .x|833|836) 0 .x|833|836) (car:pair .x|833|836))))) (.cons 'define (.cons (def.lhs .def|800) (.cons (.make-readable|5 (def.rhs .def|800)) '())))) .results|780|784|792)))))) (.loop|785|788|791 (lambda.defs .exp|734) '())))) (.cons (.make-readable|5 (lambda.body .exp|734)) '())))) (if (memv .temp|735|738 '(set!)) (.cons 'set! (.cons (assignment.lhs .exp|734) (.cons (.make-readable|5 (assignment.rhs .exp|734)) '()))) (if (memv .temp|735|738 '(if)) (.cons 'if (.cons (.make-readable|5 (if.test .exp|734)) (.cons (.make-readable|5 (if.then .exp|734)) (.cons (.make-readable|5 (if.else .exp|734)) '())))) (if (memv .temp|735|738 '(begin)) (if (variable? .exp|734) (variable.name .exp|734) (.cons 'begin (let () (let ((.loop|937|940|943 (unspecified))) (begin (set! .loop|937|940|943 (lambda (.y1|932|933|944 .results|932|936|944) (if (null? .y1|932|933|944) (reverse .results|932|936|944) (begin #t (.loop|937|940|943 (let ((.x|948|951 .y1|932|933|944)) (begin (.check! (pair? .x|948|951) 1 .x|948|951) (cdr:pair .x|948|951))) (cons (.make-readable|5 (let ((.x|952|955 .y1|932|933|944)) (begin (.check! (pair? .x|952|955) 0 .x|952|955) (car:pair .x|952|955)))) .results|932|936|944)))))) (.loop|937|940|943 (begin.exprs .exp|734) '())))))) (.make-readable-call|5 .exp|734))))))))) (.make-readable|5 .exp|1)))))) 'make-readable))
(let () (begin (set! make-unreadable (lambda (.exp|1) (let ((.make-unreadable|2 0)) (begin (set! .make-unreadable|2 (lambda (.exp|3) (if (symbol? .exp|3) (let* ((.t1|5|8 'begin) (.t2|5|11 (cons .exp|3 '()))) (let () (cons .t1|5|8 .t2|5|11))) (if (pair? .exp|3) (let ((.temp|17|20 (let ((.x|291|294 .exp|3)) (begin (.check! (pair? .x|291|294) 0 .x|291|294) (car:pair .x|291|294))))) (if (memv .temp|17|20 '(quote)) .exp|3 (if (memv .temp|17|20 '(lambda)) (let* ((.t1|23|26 'lambda) (.t2|23|29 (let* ((.t1|33|36 (let ((.x|105|108 (let ((.x|109|112 .exp|3)) (begin (.check! (pair? .x|109|112) 1 .x|109|112) (cdr:pair .x|109|112))))) (begin (.check! (pair? .x|105|108) 0 .x|105|108) (car:pair .x|105|108)))) (.t2|33|39 (let* ((.t1|43|46 '(begin)) (.t2|43|49 (let* ((.t1|53|56 (let* ((.t1|73|76 '()) (.t2|73|79 (let* ((.t1|83|86 '()) (.t2|83|89 (let* ((.t1|93|96 '()) (.t2|93|99 (cons '() '()))) (let () (cons .t1|93|96 .t2|93|99))))) (let () (cons .t1|83|86 .t2|83|89))))) (let () (cons .t1|73|76 .t2|73|79)))) (.t2|53|59 (cons (.make-unreadable|2 (cons 'begin (let ((.x|65|68 (let ((.x|69|72 .exp|3)) (begin (.check! (pair? .x|69|72) 1 .x|69|72) (cdr:pair .x|69|72))))) (begin (.check! (pair? .x|65|68) 1 .x|65|68) (cdr:pair .x|65|68))))) '()))) (let () (cons .t1|53|56 .t2|53|59))))) (let () (cons .t1|43|46 .t2|43|49))))) (let () (cons .t1|33|36 .t2|33|39))))) (let () (cons .t1|23|26 .t2|23|29))) (if (memv .temp|17|20 '(set!)) (let* ((.t1|114|117 'set!) (.t2|114|120 (let* ((.t1|124|127 (let ((.x|149|152 (let ((.x|153|156 .exp|3)) (begin (.check! (pair? .x|153|156) 1 .x|153|156) (cdr:pair .x|153|156))))) (begin (.check! (pair? .x|149|152) 0 .x|149|152) (car:pair .x|149|152)))) (.t2|124|130 (cons (.make-unreadable|2 (let ((.x|136|139 (let ((.x|140|143 (let ((.x|144|147 .exp|3)) (begin (.check! (pair? .x|144|147) 1 .x|144|147) (cdr:pair .x|144|147))))) (begin (.check! (pair? .x|140|143) 1 .x|140|143) (cdr:pair .x|140|143))))) (begin (.check! (pair? .x|136|139) 0 .x|136|139) (car:pair .x|136|139)))) '()))) (let () (cons .t1|124|127 .t2|124|130))))) (let () (cons .t1|114|117 .t2|114|120))) (if (memv .temp|17|20 '(if)) (let* ((.t1|158|161 'if) (.t2|158|164 (let* ((.t1|168|171 (.make-unreadable|2 (let ((.x|220|223 (let ((.x|224|227 .exp|3)) (begin (.check! (pair? .x|224|227) 1 .x|224|227) (cdr:pair .x|224|227))))) (begin (.check! (pair? .x|220|223) 0 .x|220|223) (car:pair .x|220|223))))) (.t2|168|174 (let* ((.t1|178|181 (.make-unreadable|2 (let ((.x|207|210 (let ((.x|211|214 (let ((.x|215|218 .exp|3)) (begin (.check! (pair? .x|215|218) 1 .x|215|218) (cdr:pair .x|215|218))))) (begin (.check! (pair? .x|211|214) 1 .x|211|214) (cdr:pair .x|211|214))))) (begin (.check! (pair? .x|207|210) 0 .x|207|210) (car:pair .x|207|210))))) (.t2|178|184 (cons (if (= (length .exp|3) 3) '(unspecified) (.make-unreadable|2 (let ((.x|190|193 (let ((.x|194|197 (let ((.x|198|201 (let ((.x|202|205 .exp|3)) (begin (.check! (pair? .x|202|205) 1 .x|202|205) (cdr:pair .x|202|205))))) (begin (.check! (pair? .x|198|201) 1 .x|198|201) (cdr:pair .x|198|201))))) (begin (.check! (pair? .x|194|197) 1 .x|194|197) (cdr:pair .x|194|197))))) (begin (.check! (pair? .x|190|193) 0 .x|190|193) (car:pair .x|190|193))))) '()))) (let () (cons .t1|178|181 .t2|178|184))))) (let () (cons .t1|168|171 .t2|168|174))))) (let () (cons .t1|158|161 .t2|158|164))) (if (memv .temp|17|20 '(begin)) (if (= (length .exp|3) 2) (.make-unreadable|2 (let ((.x|230|233 (let ((.x|234|237 .exp|3)) (begin (.check! (pair? .x|234|237) 1 .x|234|237) (cdr:pair .x|234|237))))) (begin (.check! (pair? .x|230|233) 0 .x|230|233) (car:pair .x|230|233)))) (cons 'begin (let () (let ((.loop|243|246|249 (unspecified))) (begin (set! .loop|243|246|249 (lambda (.y1|238|239|250 .results|238|242|250) (if (null? .y1|238|239|250) (reverse .results|238|242|250) (begin #t (.loop|243|246|249 (let ((.x|254|257 .y1|238|239|250)) (begin (.check! (pair? .x|254|257) 1 .x|254|257) (cdr:pair .x|254|257))) (cons (.make-unreadable|2 (let ((.x|258|261 .y1|238|239|250)) (begin (.check! (pair? .x|258|261) 0 .x|258|261) (car:pair .x|258|261)))) .results|238|242|250)))))) (.loop|243|246|249 (let ((.x|262|265 .exp|3)) (begin (.check! (pair? .x|262|265) 1 .x|262|265) (cdr:pair .x|262|265))) '())))))) (let () (let ((.loop|272|275|278 (unspecified))) (begin (set! .loop|272|275|278 (lambda (.y1|267|268|279 .results|267|271|279) (if (null? .y1|267|268|279) (reverse .results|267|271|279) (begin #t (.loop|272|275|278 (let ((.x|283|286 .y1|267|268|279)) (begin (.check! (pair? .x|283|286) 1 .x|283|286) (cdr:pair .x|283|286))) (cons (.make-unreadable|2 (let ((.x|287|290 .y1|267|268|279)) (begin (.check! (pair? .x|287|290) 0 .x|287|290) (car:pair .x|287|290)))) .results|267|271|279)))))) (.loop|272|275|278 .exp|3 '())))))))))) (let* ((.t1|296|299 'quote) (.t2|296|302 (cons .exp|3 '()))) (let () (cons .t1|296|299 .t2|296|302))))))) (.make-unreadable|2 .exp|1))))) 'make-unreadable))
(let () ($$trace "pass2.aux"))
(let () (begin (set! constant? (lambda (.exp|1) (let ((.constant?|2 0)) (begin (set! .constant?|2 (lambda (.exp|3) (eq? (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))) 'quote))) (.constant?|2 .exp|1))))) 'constant?))
(let () (begin (set! variable? (lambda (.exp|1) (let ((.variable?|2 0)) (begin (set! .variable?|2 (lambda (.exp|3) (if (eq? (let ((.x|5|8 .exp|3)) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))) 'begin) (null? (let ((.x|11|14 (let ((.x|15|18 .exp|3)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))))) (begin (.check! (pair? .x|11|14) 1 .x|11|14) (cdr:pair .x|11|14)))) #f))) (.variable?|2 .exp|1))))) 'variable?))
(let () (begin (set! lambda? (lambda (.exp|1) (let ((.lambda?|2 0)) (begin (set! .lambda?|2 (lambda (.exp|3) (eq? (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))) 'lambda))) (.lambda?|2 .exp|1))))) 'lambda?))
(let () (begin (set! call? (lambda (.exp|1) (let ((.call?|2 0)) (begin (set! .call?|2 (lambda (.exp|3) (pair? (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7)))))) (.call?|2 .exp|1))))) 'call?))
(let () (begin (set! assignment? (lambda (.exp|1) (let ((.assignment?|2 0)) (begin (set! .assignment?|2 (lambda (.exp|3) (eq? (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))) 'set!))) (.assignment?|2 .exp|1))))) 'assignment?))
(let () (begin (set! conditional? (lambda (.exp|1) (let ((.conditional?|2 0)) (begin (set! .conditional?|2 (lambda (.exp|3) (eq? (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))) 'if))) (.conditional?|2 .exp|1))))) 'conditional?))
(let () (begin (set! begin? (lambda (.exp|1) (let ((.begin?|2 0)) (begin (set! .begin?|2 (lambda (.exp|3) (if (eq? (let ((.x|5|8 .exp|3)) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))) 'begin) (not (null? (let ((.x|11|14 (let ((.x|15|18 .exp|3)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))))) (begin (.check! (pair? .x|11|14) 1 .x|11|14) (cdr:pair .x|11|14))))) #f))) (.begin?|2 .exp|1))))) 'begin?))
(let () (begin (set! make-constant (lambda (.value|1) (let ((.make-constant|2 0)) (begin (set! .make-constant|2 (lambda (.value|3) (let* ((.t1|4|7 'quote) (.t2|4|10 (cons .value|3 '()))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-constant|2 .value|1))))) 'make-constant))
(let () (begin (set! make-variable (lambda (.name|1) (let ((.make-variable|2 0)) (begin (set! .make-variable|2 (lambda (.name|3) (let* ((.t1|4|7 'begin) (.t2|4|10 (cons .name|3 '()))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-variable|2 .name|1))))) 'make-variable))
(let () (begin (set! make-lambda (lambda (.formals|1 .defs|1 .r|1 .f|1 .g|1 .decls|1 .doc|1 .body|1) (let ((.make-lambda|2 0)) (begin (set! .make-lambda|2 (lambda (.formals|3 .defs|3 .r|3 .f|3 .g|3 .decls|3 .doc|3 .body|3) (let* ((.t1|4|7 'lambda) (.t2|4|10 (let* ((.t1|14|17 .formals|3) (.t2|14|20 (let* ((.t1|24|27 (cons 'begin .defs|3)) (.t2|24|30 (let* ((.t1|34|37 (let* ((.t1|45|48 'quote) (.t2|45|51 (cons (let* ((.t1|56|59 .r|3) (.t2|56|62 (let* ((.t1|66|69 .f|3) (.t2|66|72 (let* ((.t1|76|79 .g|3) (.t2|76|82 (let* ((.t1|86|89 .decls|3) (.t2|86|92 (cons .doc|3 '()))) (let () (cons .t1|86|89 .t2|86|92))))) (let () (cons .t1|76|79 .t2|76|82))))) (let () (cons .t1|66|69 .t2|66|72))))) (let () (cons .t1|56|59 .t2|56|62))) '()))) (let () (cons .t1|45|48 .t2|45|51)))) (.t2|34|40 (cons .body|3 '()))) (let () (cons .t1|34|37 .t2|34|40))))) (let () (cons .t1|24|27 .t2|24|30))))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-lambda|2 .formals|1 .defs|1 .r|1 .f|1 .g|1 .decls|1 .doc|1 .body|1))))) 'make-lambda))
(let () (begin (set! make-call (lambda (.proc|1 .args|1) (let ((.make-call|2 0)) (begin (set! .make-call|2 (lambda (.proc|3 .args|3) (cons .proc|3 (append .args|3 '())))) (.make-call|2 .proc|1 .args|1))))) 'make-call))
(let () (begin (set! make-assignment (lambda (.lhs|1 .rhs|1) (let ((.make-assignment|2 0)) (begin (set! .make-assignment|2 (lambda (.lhs|3 .rhs|3) (let* ((.t1|4|7 'set!) (.t2|4|10 (let* ((.t1|14|17 .lhs|3) (.t2|14|20 (cons .rhs|3 '()))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-assignment|2 .lhs|1 .rhs|1))))) 'make-assignment))
(let () (begin (set! make-conditional (lambda (.e0|1 .e1|1 .e2|1) (let ((.make-conditional|2 0)) (begin (set! .make-conditional|2 (lambda (.e0|3 .e1|3 .e2|3) (let* ((.t1|4|7 'if) (.t2|4|10 (let* ((.t1|14|17 .e0|3) (.t2|14|20 (let* ((.t1|24|27 .e1|3) (.t2|24|30 (cons .e2|3 '()))) (let () (cons .t1|24|27 .t2|24|30))))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-conditional|2 .e0|1 .e1|1 .e2|1))))) 'make-conditional))
(let () (begin (set! make-begin (lambda (.exprs|1) (let ((.make-begin|2 0)) (begin (set! .make-begin|2 (lambda (.exprs|3) (if (null? (let ((.x|4|7 .exprs|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7)))) (let ((.x|8|11 .exprs|3)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) (cons 'begin (append .exprs|3 '()))))) (.make-begin|2 .exprs|1))))) 'make-begin))
(let () (begin (set! make-definition (lambda (.lhs|1 .rhs|1) (let ((.make-definition|2 0)) (begin (set! .make-definition|2 (lambda (.lhs|3 .rhs|3) (let* ((.t1|4|7 'define) (.t2|4|10 (let* ((.t1|14|17 .lhs|3) (.t2|14|20 (cons .rhs|3 '()))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-definition|2 .lhs|1 .rhs|1))))) 'make-definition))
(let () (begin (set! constant.value (lambda (.exp|1) (let ((.constant.value|2 0)) (begin (set! .constant.value|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 .exp|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.constant.value|2 .exp|1))))) 'constant.value))
(let () (begin (set! variable.name (lambda (.exp|1) (let ((.variable.name|2 0)) (begin (set! .variable.name|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 .exp|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.variable.name|2 .exp|1))))) 'variable.name))
(let () (begin (set! lambda.args (lambda (.exp|1) (let ((.lambda.args|2 0)) (begin (set! .lambda.args|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 .exp|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.lambda.args|2 .exp|1))))) 'lambda.args))
(let () (begin (set! lambda.defs (lambda (.exp|1) (let ((.lambda.defs|2 0)) (begin (set! .lambda.defs|2 (lambda (.exp|3) (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 .exp|3)) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))))) (.lambda.defs|2 .exp|1))))) 'lambda.defs))
(let () (begin (set! lambda.r (lambda (.exp|1) (let ((.lambda.r|2 0)) (begin (set! .lambda.r|2 (lambda (.exp|3) (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|18|21 (let ((.x|22|25 (let ((.x|26|29 (let ((.x|30|33 .exp|3)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))))) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.lambda.r|2 .exp|1))))) 'lambda.r))
(let () (begin (set! lambda.f (lambda (.exp|1) (let ((.lambda.f|2 0)) (begin (set! .lambda.f|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|14|17 (let ((.x|18|21 (let ((.x|23|26 (let ((.x|27|30 (let ((.x|31|34 (let ((.x|35|38 .exp|3)) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))))) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34))))) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30))))) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26))))) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21))))) (begin (.check! (pair? .x|14|17) 0 .x|14|17) (car:pair .x|14|17))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.lambda.f|2 .exp|1))))) 'lambda.f))
(let () (begin (set! lambda.g (lambda (.exp|1) (let ((.lambda.g|2 0)) (begin (set! .lambda.g|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|18|21 (let ((.x|22|25 (let ((.x|27|30 (let ((.x|31|34 (let ((.x|35|38 (let ((.x|39|42 .exp|3)) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))))) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34))))) (begin (.check! (pair? .x|27|30) 0 .x|27|30) (car:pair .x|27|30))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.lambda.g|2 .exp|1))))) 'lambda.g))
(let () (begin (set! lambda.decls (lambda (.exp|1) (let ((.lambda.decls|2 0)) (begin (set! .lambda.decls|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|22|25 (let ((.x|26|29 (let ((.x|31|34 (let ((.x|35|38 (let ((.x|39|42 (let ((.x|43|46 .exp|3)) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46))))) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))))) (begin (.check! (pair? .x|31|34) 0 .x|31|34) (car:pair .x|31|34))))) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 0 .x|22|25) (car:pair .x|22|25))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.lambda.decls|2 .exp|1))))) 'lambda.decls))
(let () (begin (set! lambda.doc (lambda (.exp|1) (let ((.lambda.doc|2 0)) (begin (set! .lambda.doc|2 (lambda (.exp|3) (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|21|24 (let ((.x|26|29 (let ((.x|30|33 (let ((.x|35|38 (let ((.x|39|42 (let ((.x|43|46 (let ((.x|47|50 .exp|3)) (begin (.check! (pair? .x|47|50) 1 .x|47|50) (cdr:pair .x|47|50))))) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46))))) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 0 .x|35|38) (car:pair .x|35|38))))) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))))) (begin (.check! (pair? .x|26|29) 0 .x|26|29) (car:pair .x|26|29))))) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.lambda.doc|2 .exp|1))))) 'lambda.doc))
(let () (begin (set! lambda.body (lambda (.exp|1) (let ((.lambda.body|2 0)) (begin (set! .lambda.body|2 (lambda (.exp|3) (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|21|24 .exp|3)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.lambda.body|2 .exp|1))))) 'lambda.body))
(let () (begin (set! call.proc (lambda (.exp|1) (let ((.call.proc|2 0)) (begin (set! .call.proc|2 (lambda (.exp|3) (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.call.proc|2 .exp|1))))) 'call.proc))
(let () (begin (set! call.args (lambda (.exp|1) (let ((.call.args|2 0)) (begin (set! .call.args|2 (lambda (.exp|3) (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))))) (.call.args|2 .exp|1))))) 'call.args))
(let () (begin (set! assignment.lhs (lambda (.exp|1) (let ((.assignment.lhs|2 0)) (begin (set! .assignment.lhs|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 .exp|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.assignment.lhs|2 .exp|1))))) 'assignment.lhs))
(let () (begin (set! assignment.rhs (lambda (.exp|1) (let ((.assignment.rhs|2 0)) (begin (set! .assignment.rhs|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .exp|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.assignment.rhs|2 .exp|1))))) 'assignment.rhs))
(let () (begin (set! if.test (lambda (.exp|1) (let ((.if.test|2 0)) (begin (set! .if.test|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 .exp|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.if.test|2 .exp|1))))) 'if.test))
(let () (begin (set! if.then (lambda (.exp|1) (let ((.if.then|2 0)) (begin (set! .if.then|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .exp|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.if.then|2 .exp|1))))) 'if.then))
(let () (begin (set! if.else (lambda (.exp|1) (let ((.if.else|2 0)) (begin (set! .if.else|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 .exp|3)) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.if.else|2 .exp|1))))) 'if.else))
(let () (begin (set! begin.exprs (lambda (.exp|1) (let ((.begin.exprs|2 0)) (begin (set! .begin.exprs|2 (lambda (.exp|3) (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))))) (.begin.exprs|2 .exp|1))))) 'begin.exprs))
(let () (begin (set! def.lhs (lambda (.exp|1) (let ((.def.lhs|2 0)) (begin (set! .def.lhs|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 .exp|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.def.lhs|2 .exp|1))))) 'def.lhs))
(let () (begin (set! def.rhs (lambda (.exp|1) (let ((.def.rhs|2 0)) (begin (set! .def.rhs|2 (lambda (.exp|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .exp|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.def.rhs|2 .exp|1))))) 'def.rhs))
(let () (begin (set! variable-set! (lambda (.exp|1 .newexp|1) (let ((.variable-set!|2 0)) (begin (set! .variable-set!|2 (lambda (.exp|3 .newexp|3) (begin (set-car! .exp|3 (let ((.x|4|7 .newexp|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7)))) (set-cdr! .exp|3 (append (let ((.x|8|11 .newexp|3)) (begin (.check! (pair? .x|8|11) 1 .x|8|11) (cdr:pair .x|8|11))) '()))))) (.variable-set!|2 .exp|1 .newexp|1))))) 'variable-set!))
(let () (begin (set! lambda.args-set! (lambda (.exp|1 .args|1) (let ((.lambda.args-set!|2 0)) (begin (set! .lambda.args-set!|2 (lambda (.exp|3 .args|3) (set-car! (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .args|3))) (.lambda.args-set!|2 .exp|1 .args|1))))) 'lambda.args-set!))
(let () (begin (set! lambda.defs-set! (lambda (.exp|1 .defs|1) (let ((.lambda.defs-set!|2 0)) (begin (set! .lambda.defs-set!|2 (lambda (.exp|3 .defs|3) (set-cdr! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .exp|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))) .defs|3))) (.lambda.defs-set!|2 .exp|1 .defs|1))))) 'lambda.defs-set!))
(let () (begin (set! lambda.r-set! (lambda (.exp|1 .r|1) (let ((.lambda.r-set!|2 0)) (begin (set! .lambda.r-set!|2 (lambda (.exp|3 .r|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|14|17 (let ((.x|18|21 (let ((.x|22|25 (let ((.x|26|29 .exp|3)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21))))) (begin (.check! (pair? .x|14|17) 0 .x|14|17) (car:pair .x|14|17))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))) .r|3))) (.lambda.r-set!|2 .exp|1 .r|1))))) 'lambda.r-set!))
(let () (begin (set! lambda.f-set! (lambda (.exp|1 .f|1) (let ((.lambda.f-set!|2 0)) (begin (set! .lambda.f-set!|2 (lambda (.exp|3 .f|3) (set-car! (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|18|21 (let ((.x|22|25 (let ((.x|26|29 (let ((.x|30|33 .exp|3)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))))) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .f|3))) (.lambda.f-set!|2 .exp|1 .f|1))))) 'lambda.f-set!))
(let () (begin (set! lambda.g-set! (lambda (.exp|1 .g|1) (let ((.lambda.g-set!|2 0)) (begin (set! .lambda.g-set!|2 (lambda (.exp|3 .g|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|14|17 (let ((.x|18|21 (let ((.x|23|26 (let ((.x|27|30 (let ((.x|31|34 (let ((.x|35|38 .exp|3)) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))))) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34))))) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30))))) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26))))) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21))))) (begin (.check! (pair? .x|14|17) 0 .x|14|17) (car:pair .x|14|17))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .g|3))) (.lambda.g-set!|2 .exp|1 .g|1))))) 'lambda.g-set!))
(let () (begin (set! lambda.decls-set! (lambda (.exp|1 .decls|1) (let ((.lambda.decls-set!|2 0)) (begin (set! .lambda.decls-set!|2 (lambda (.exp|3 .decls|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|18|21 (let ((.x|22|25 (let ((.x|27|30 (let ((.x|31|34 (let ((.x|35|38 (let ((.x|39|42 .exp|3)) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))))) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34))))) (begin (.check! (pair? .x|27|30) 0 .x|27|30) (car:pair .x|27|30))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .decls|3))) (.lambda.decls-set!|2 .exp|1 .decls|1))))) 'lambda.decls-set!))
(let () (begin (set! lambda.doc-set! (lambda (.exp|1 .doc|1) (let ((.lambda.doc-set!|2 0)) (begin (set! .lambda.doc-set!|2 (lambda (.exp|3 .doc|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|22|25 (let ((.x|26|29 (let ((.x|31|34 (let ((.x|35|38 (let ((.x|39|42 (let ((.x|43|46 .exp|3)) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46))))) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))))) (begin (.check! (pair? .x|31|34) 0 .x|31|34) (car:pair .x|31|34))))) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 0 .x|22|25) (car:pair .x|22|25))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .doc|3))) (.lambda.doc-set!|2 .exp|1 .doc|1))))) 'lambda.doc-set!))
(let () (begin (set! lambda.body-set! (lambda (.exp|1 .exp0|1) (let ((.lambda.body-set!|2 0)) (begin (set! .lambda.body-set!|2 (lambda (.exp|3 .exp0|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 .exp|3)) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .exp0|3))) (.lambda.body-set!|2 .exp|1 .exp0|1))))) 'lambda.body-set!))
(let () (begin (set! call.proc-set! (lambda (.exp|1 .exp0|1) (let ((.call.proc-set!|2 0)) (begin (set! .call.proc-set!|2 (lambda (.exp|3 .exp0|3) (set-car! .exp|3 .exp0|3))) (.call.proc-set!|2 .exp|1 .exp0|1))))) 'call.proc-set!))
(let () (begin (set! call.args-set! (lambda (.exp|1 .exprs|1) (let ((.call.args-set!|2 0)) (begin (set! .call.args-set!|2 (lambda (.exp|3 .exprs|3) (set-cdr! .exp|3 .exprs|3))) (.call.args-set!|2 .exp|1 .exprs|1))))) 'call.args-set!))
(let () (begin (set! assignment.rhs-set! (lambda (.exp|1 .exp0|1) (let ((.assignment.rhs-set!|2 0)) (begin (set! .assignment.rhs-set!|2 (lambda (.exp|3 .exp0|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 .exp|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .exp0|3))) (.assignment.rhs-set!|2 .exp|1 .exp0|1))))) 'assignment.rhs-set!))
(let () (begin (set! if.test-set! (lambda (.exp|1 .exp0|1) (let ((.if.test-set!|2 0)) (begin (set! .if.test-set!|2 (lambda (.exp|3 .exp0|3) (set-car! (let ((.x|4|7 .exp|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .exp0|3))) (.if.test-set!|2 .exp|1 .exp0|1))))) 'if.test-set!))
(let () (begin (set! if.then-set! (lambda (.exp|1 .exp0|1) (let ((.if.then-set!|2 0)) (begin (set! .if.then-set!|2 (lambda (.exp|3 .exp0|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 .exp|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .exp0|3))) (.if.then-set!|2 .exp|1 .exp0|1))))) 'if.then-set!))
(let () (begin (set! if.else-set! (lambda (.exp|1 .exp0|1) (let ((.if.else-set!|2 0)) (begin (set! .if.else-set!|2 (lambda (.exp|3 .exp0|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .exp|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .exp0|3))) (.if.else-set!|2 .exp|1 .exp0|1))))) 'if.else-set!))
(let () (begin (set! begin.exprs-set! (lambda (.exp|1 .exprs|1) (let ((.begin.exprs-set!|2 0)) (begin (set! .begin.exprs-set!|2 (lambda (.exp|3 .exprs|3) (set-cdr! .exp|3 .exprs|3))) (.begin.exprs-set!|2 .exp|1 .exprs|1))))) 'begin.exprs-set!))
(let () (begin (set! expression-set! variable-set!) 'expression-set!))
(let () (begin (set! make-doc (lambda (.name|1 .arity|1 .formals|1 .source-code|1 .filename|1 .filepos|1) (let ((.make-doc|2 0)) (begin (set! .make-doc|2 (lambda (.name|3 .arity|3 .formals|3 .source-code|3 .filename|3 .filepos|3) (let* ((.t|4|10|15 .formals|3) (.t|4|9|18 .filepos|3) (.t|4|8|21 .filename|3) (.t|4|7|24 .arity|3) (.t|4|6|27 .source-code|3) (.t|4|5|30 .name|3) (.v|4|12|33 (make-vector 6 .t|4|10|15))) (let () (begin (let ((.v|37|40 .v|4|12|33) (.i|37|40 4) (.x|37|40 .t|4|9|18)) (begin (.check! (fixnum? .i|37|40) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (vector? .v|37|40) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (<:fix:fix .i|37|40 (vector-length:vec .v|37|40)) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (>=:fix:fix .i|37|40 0) 41 .v|37|40 .i|37|40 .x|37|40) (vector-set!:trusted .v|37|40 .i|37|40 .x|37|40))) (let ((.v|41|44 .v|4|12|33) (.i|41|44 3) (.x|41|44 .t|4|8|21)) (begin (.check! (fixnum? .i|41|44) 41 .v|41|44 .i|41|44 .x|41|44) (.check! (vector? .v|41|44) 41 .v|41|44 .i|41|44 .x|41|44) (.check! (<:fix:fix .i|41|44 (vector-length:vec .v|41|44)) 41 .v|41|44 .i|41|44 .x|41|44) (.check! (>=:fix:fix .i|41|44 0) 41 .v|41|44 .i|41|44 .x|41|44) (vector-set!:trusted .v|41|44 .i|41|44 .x|41|44))) (let ((.v|45|48 .v|4|12|33) (.i|45|48 2) (.x|45|48 .t|4|7|24)) (begin (.check! (fixnum? .i|45|48) 41 .v|45|48 .i|45|48 .x|45|48) (.check! (vector? .v|45|48) 41 .v|45|48 .i|45|48 .x|45|48) (.check! (<:fix:fix .i|45|48 (vector-length:vec .v|45|48)) 41 .v|45|48 .i|45|48 .x|45|48) (.check! (>=:fix:fix .i|45|48 0) 41 .v|45|48 .i|45|48 .x|45|48) (vector-set!:trusted .v|45|48 .i|45|48 .x|45|48))) (let ((.v|49|52 .v|4|12|33) (.i|49|52 1) (.x|49|52 .t|4|6|27)) (begin (.check! (fixnum? .i|49|52) 41 .v|49|52 .i|49|52 .x|49|52) (.check! (vector? .v|49|52) 41 .v|49|52 .i|49|52 .x|49|52) (.check! (<:fix:fix .i|49|52 (vector-length:vec .v|49|52)) 41 .v|49|52 .i|49|52 .x|49|52) (.check! (>=:fix:fix .i|49|52 0) 41 .v|49|52 .i|49|52 .x|49|52) (vector-set!:trusted .v|49|52 .i|49|52 .x|49|52))) (let ((.v|53|56 .v|4|12|33) (.i|53|56 0) (.x|53|56 .t|4|5|30)) (begin (.check! (fixnum? .i|53|56) 41 .v|53|56 .i|53|56 .x|53|56) (.check! (vector? .v|53|56) 41 .v|53|56 .i|53|56 .x|53|56) (.check! (<:fix:fix .i|53|56 (vector-length:vec .v|53|56)) 41 .v|53|56 .i|53|56 .x|53|56) (.check! (>=:fix:fix .i|53|56 0) 41 .v|53|56 .i|53|56 .x|53|56) (vector-set!:trusted .v|53|56 .i|53|56 .x|53|56))) .v|4|12|33))))) (.make-doc|2 .name|1 .arity|1 .formals|1 .source-code|1 .filename|1 .filepos|1))))) 'make-doc))
(let () (begin (set! doc.name (lambda (.d|1) (let ((.doc.name|2 0)) (begin (set! .doc.name|2 (lambda (.d|3) (let ((.v|4|7 .d|3) (.i|4|7 0)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.doc.name|2 .d|1))))) 'doc.name))
(let () (begin (set! doc.code (lambda (.d|1) (let ((.doc.code|2 0)) (begin (set! .doc.code|2 (lambda (.d|3) (let ((.v|4|7 .d|3) (.i|4|7 1)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.doc.code|2 .d|1))))) 'doc.code))
(let () (begin (set! doc.arity (lambda (.d|1) (let ((.doc.arity|2 0)) (begin (set! .doc.arity|2 (lambda (.d|3) (let ((.v|4|7 .d|3) (.i|4|7 2)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.doc.arity|2 .d|1))))) 'doc.arity))
(let () (begin (set! doc.file (lambda (.d|1) (let ((.doc.file|2 0)) (begin (set! .doc.file|2 (lambda (.d|3) (let ((.v|4|7 .d|3) (.i|4|7 3)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.doc.file|2 .d|1))))) 'doc.file))
(let () (begin (set! doc.filepos (lambda (.d|1) (let ((.doc.filepos|2 0)) (begin (set! .doc.filepos|2 (lambda (.d|3) (let ((.v|4|7 .d|3) (.i|4|7 4)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.doc.filepos|2 .d|1))))) 'doc.filepos))
(let () (begin (set! doc.formals (lambda (.d|1) (let ((.doc.formals|2 0)) (begin (set! .doc.formals|2 (lambda (.d|3) (let ((.v|4|7 .d|3) (.i|4|7 5)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.doc.formals|2 .d|1))))) 'doc.formals))
(let () (begin (set! doc.name-set! (lambda (.d|1 .x|1) (let ((.doc.name-set!|2 0)) (begin (set! .doc.name-set!|2 (lambda (.d|3 .x|3) (if .d|3 (let ((.v|4|7 .d|3) (.i|4|7 0) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))) (unspecified)))) (.doc.name-set!|2 .d|1 .x|1))))) 'doc.name-set!))
(let () (begin (set! doc.code-set! (lambda (.d|1 .x|1) (let ((.doc.code-set!|2 0)) (begin (set! .doc.code-set!|2 (lambda (.d|3 .x|3) (if .d|3 (let ((.v|4|7 .d|3) (.i|4|7 1) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))) (unspecified)))) (.doc.code-set!|2 .d|1 .x|1))))) 'doc.code-set!))
(let () (begin (set! doc.arity-set! (lambda (.d|1 .x|1) (let ((.doc.arity-set!|2 0)) (begin (set! .doc.arity-set!|2 (lambda (.d|3 .x|3) (if .d|3 (let ((.v|4|7 .d|3) (.i|4|7 2) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))) (unspecified)))) (.doc.arity-set!|2 .d|1 .x|1))))) 'doc.arity-set!))
(let () (begin (set! doc.file-set! (lambda (.d|1 .x|1) (let ((.doc.file-set!|2 0)) (begin (set! .doc.file-set!|2 (lambda (.d|3 .x|3) (if .d|3 (let ((.v|4|7 .d|3) (.i|4|7 3) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))) (unspecified)))) (.doc.file-set!|2 .d|1 .x|1))))) 'doc.file-set!))
(let () (begin (set! doc.filepos-set! (lambda (.d|1 .x|1) (let ((.doc.filepos-set!|2 0)) (begin (set! .doc.filepos-set!|2 (lambda (.d|3 .x|3) (if .d|3 (let ((.v|4|7 .d|3) (.i|4|7 4) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))) (unspecified)))) (.doc.filepos-set!|2 .d|1 .x|1))))) 'doc.filepos-set!))
(let () (begin (set! doc.formals-set! (lambda (.d|1 .x|1) (let ((.doc.formals-set!|2 0)) (begin (set! .doc.formals-set!|2 (lambda (.d|3 .x|3) (if .d|3 (let ((.v|4|7 .d|3) (.i|4|7 5) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))) (unspecified)))) (.doc.formals-set!|2 .d|1 .x|1))))) 'doc.formals-set!))
(let () (begin (set! doc-copy (lambda (.d|1) (let ((.doc-copy|2 0)) (begin (set! .doc-copy|2 (lambda (.d|3) (list->vector (vector->list .d|3)))) (.doc-copy|2 .d|1))))) 'doc-copy))
(let () (begin (set! ignored? (lambda (.name|1) (let ((.ignored?|2 0)) (begin (set! .ignored?|2 (lambda (.name|3) (eq? .name|3 name:ignored))) (.ignored?|2 .name|1))))) 'ignored?))
(let () (begin (set! flag-as-ignored (lambda (.name|1 .l|1) (let ((.flag-as-ignored|2 0)) (begin (set! .flag-as-ignored|2 (lambda (.name|3 .l|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.name|5 .formals|5) (if (null? .formals|5) #t (if (symbol? .formals|5) #t (if (eq? .name|5 (let ((.x|9|12 .formals|5)) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12)))) (begin (set-car! .formals|5 name:ignored) (if (not (local? (lambda.r .l|3) name:ignored)) (lambda.r-set! .l|3 (cons (make-r-entry name:ignored '() '() '()) (lambda.r .l|3))) (unspecified))) (.loop|4 .name|5 (let ((.x|14|17 .formals|5)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))))))))) (.loop|4 .name|3 (lambda.args .l|3)))))) (.flag-as-ignored|2 .name|1 .l|1))))) 'flag-as-ignored))
(let () (begin (set! make-null-terminated (lambda (.formals|1) (let ((.make-null-terminated|2 0)) (begin (set! .make-null-terminated|2 (lambda (.formals|3) (if (null? .formals|3) '() (if (symbol? .formals|3) (cons .formals|3 '()) (cons (let ((.x|8|11 .formals|3)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) (.make-null-terminated|2 (let ((.x|12|15 .formals|3)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))))))))) (.make-null-terminated|2 .formals|1))))) 'make-null-terminated))
(let () (begin (set! list-head (lambda (.x|1 .n|1) (let ((.list-head|2 0)) (begin (set! .list-head|2 (lambda (.x|3 .n|3) (if (zero? .n|3) '() (cons (let ((.x|6|9 .x|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9))) (.list-head|2 (let ((.x|10|13 .x|3)) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13))) (- .n|3 1)))))) (.list-head|2 .x|1 .n|1))))) 'list-head))
(let () (begin (set! remq (lambda (.x|1 .y|1) (let ((.remq|2 0)) (begin (set! .remq|2 (lambda (.x|3 .y|3) (if (null? .y|3) '() (if (eq? .x|3 (let ((.x|6|9 .y|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9)))) (.remq|2 .x|3 (let ((.x|10|13 .y|3)) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13)))) (cons (let ((.x|15|18 .y|3)) (begin (.check! (pair? .x|15|18) 0 .x|15|18) (car:pair .x|15|18))) (.remq|2 .x|3 (let ((.x|19|22 .y|3)) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22))))))))) (.remq|2 .x|1 .y|1))))) 'remq))
(let () (begin (set! make-call-to-list (lambda (.args|1) (let ((.make-call-to-list|2 0)) (begin (set! .make-call-to-list|2 (lambda (.args|3) (if (null? .args|3) (make-constant '()) (if (null? (let ((.x|6|9 .args|3)) (begin (.check! (pair? .x|6|9) 1 .x|6|9) (cdr:pair .x|6|9)))) (make-call (make-variable name:cons) (let* ((.t1|10|13 (let ((.x|21|24 .args|3)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24)))) (.t2|10|16 (cons (make-constant '()) '()))) (let () (cons .t1|10|13 .t2|10|16)))) (make-call (make-variable name:list) .args|3))))) (.make-call-to-list|2 .args|1))))) 'make-call-to-list))
(let () (begin (set! pass2-error (lambda (.i|1 . .etc|1) (apply cerror (cons (let ((.v|2|5 pass2-error-messages) (.i|2|5 .i|1)) (begin (.check! (fixnum? .i|2|5) 40 .v|2|5 .i|2|5) (.check! (vector? .v|2|5) 40 .v|2|5 .i|2|5) (.check! (<:fix:fix .i|2|5 (vector-length:vec .v|2|5)) 40 .v|2|5 .i|2|5) (.check! (>=:fix:fix .i|2|5 0) 40 .v|2|5 .i|2|5) (vector-ref:trusted .v|2|5 .i|2|5))) .etc|1)))) 'pass2-error))
(let () (begin (set! pass2-error-messages '#("System error: violation of an invariant in pass 2" "Wrong number of arguments to known procedure")) 'pass2-error-messages))
(let () (begin (set! p2error:violation-of-invariant 0) 'p2error:violation-of-invariant))
(let () (begin (set! p2error:wna 1) 'p2error:wna))
(let () (begin (set! make-r-entry (lambda (.name|1 .refs|1 .assigns|1 .calls|1) (let ((.make-r-entry|2 0)) (begin (set! .make-r-entry|2 (lambda (.name|3 .refs|3 .assigns|3 .calls|3) (let* ((.t1|4|7 .name|3) (.t2|4|10 (let* ((.t1|14|17 .refs|3) (.t2|14|20 (let* ((.t1|24|27 .assigns|3) (.t2|24|30 (cons .calls|3 '()))) (let () (cons .t1|24|27 .t2|24|30))))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-r-entry|2 .name|1 .refs|1 .assigns|1 .calls|1))))) 'make-r-entry))
(let () (begin (set! r-entry.name (lambda (.x|1) (let ((.r-entry.name|2 0)) (begin (set! .r-entry.name|2 (lambda (.x|3) (let ((.x|4|7 .x|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.r-entry.name|2 .x|1))))) 'r-entry.name))
(let () (begin (set! r-entry.references (lambda (.x|1) (let ((.r-entry.references|2 0)) (begin (set! .r-entry.references|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 .x|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.r-entry.references|2 .x|1))))) 'r-entry.references))
(let () (begin (set! r-entry.assignments (lambda (.x|1) (let ((.r-entry.assignments|2 0)) (begin (set! .r-entry.assignments|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .x|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.r-entry.assignments|2 .x|1))))) 'r-entry.assignments))
(let () (begin (set! r-entry.calls (lambda (.x|1) (let ((.r-entry.calls|2 0)) (begin (set! .r-entry.calls|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 .x|3)) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.r-entry.calls|2 .x|1))))) 'r-entry.calls))
(let () (begin (set! r-entry.references-set! (lambda (.x|1 .refs|1) (let ((.r-entry.references-set!|2 0)) (begin (set! .r-entry.references-set!|2 (lambda (.x|3 .refs|3) (set-car! (let ((.x|4|7 .x|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .refs|3))) (.r-entry.references-set!|2 .x|1 .refs|1))))) 'r-entry.references-set!))
(let () (begin (set! r-entry.assignments-set! (lambda (.x|1 .assignments|1) (let ((.r-entry.assignments-set!|2 0)) (begin (set! .r-entry.assignments-set!|2 (lambda (.x|3 .assignments|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 .x|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .assignments|3))) (.r-entry.assignments-set!|2 .x|1 .assignments|1))))) 'r-entry.assignments-set!))
(let () (begin (set! r-entry.calls-set! (lambda (.x|1 .calls|1) (let ((.r-entry.calls-set!|2 0)) (begin (set! .r-entry.calls-set!|2 (lambda (.x|3 .calls|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .x|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .calls|3))) (.r-entry.calls-set!|2 .x|1 .calls|1))))) 'r-entry.calls-set!))
(let () (begin (set! local? (lambda (.r|1 .i|1) (let ((.local?|2 0)) (begin (set! .local?|2 (lambda (.r|3 .i|3) (assq .i|3 .r|3))) (.local?|2 .r|1 .i|1))))) 'local?))
(let () (begin (set! r-entry (lambda (.r|1 .i|1) (let ((.r-entry|2 0)) (begin (set! .r-entry|2 (lambda (.r|3 .i|3) (assq .i|3 .r|3))) (.r-entry|2 .r|1 .i|1))))) 'r-entry))
(let () (begin (set! r-lookup (lambda (.r|1 .i|1) (let ((.r-lookup|2 0)) (begin (set! .r-lookup|2 (lambda (.r|3 .i|3) (let ((.temp|4|7 (assq .i|3 .r|3))) (if .temp|4|7 .temp|4|7 (pass2-error p2error:violation-of-invariant .r|3 .i|3))))) (.r-lookup|2 .r|1 .i|1))))) 'r-lookup))
(let () (begin (set! references (lambda (.r|1 .i|1) (let ((.references|2 0)) (begin (set! .references|2 (lambda (.r|3 .i|3) (let ((.x|5|8 (let ((.x|9|12 (r-lookup .r|3 .i|3))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.references|2 .r|1 .i|1))))) 'references))
(let () (begin (set! assignments (lambda (.r|1 .i|1) (let ((.assignments|2 0)) (begin (set! .assignments|2 (lambda (.r|3 .i|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (r-lookup .r|3 .i|3))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.assignments|2 .r|1 .i|1))))) 'assignments))
(let () (begin (set! calls (lambda (.r|1 .i|1) (let ((.calls|2 0)) (begin (set! .calls|2 (lambda (.r|3 .i|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (r-lookup .r|3 .i|3))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.calls|2 .r|1 .i|1))))) 'calls))
(let () (begin (set! references-set! (lambda (.r|1 .i|1 .x|1) (let ((.references-set!|2 0)) (begin (set! .references-set!|2 (lambda (.r|3 .i|3 .x|3) (set-car! (let ((.x|4|7 (r-lookup .r|3 .i|3))) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .x|3))) (.references-set!|2 .r|1 .i|1 .x|1))))) 'references-set!))
(let () (begin (set! assignments-set! (lambda (.r|1 .i|1 .x|1) (let ((.assignments-set!|2 0)) (begin (set! .assignments-set!|2 (lambda (.r|3 .i|3 .x|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (r-lookup .r|3 .i|3))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .x|3))) (.assignments-set!|2 .r|1 .i|1 .x|1))))) 'assignments-set!))
(let () (begin (set! calls-set! (lambda (.r|1 .i|1 .x|1) (let ((.calls-set!|2 0)) (begin (set! .calls-set!|2 (lambda (.r|3 .i|3 .x|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (r-lookup .r|3 .i|3))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .x|3))) (.calls-set!|2 .r|1 .i|1 .x|1))))) 'calls-set!))
(let () (begin (set! make-notepad (lambda (.l|1) (let ((.make-notepad|2 0)) (begin (set! .make-notepad|2 (lambda (.l|3) (let* ((.t|4|8|13 '()) (.t|4|7|16 '()) (.t|4|6|19 '()) (.t|4|5|22 .l|3) (.v|4|10|25 (make-vector 4 .t|4|8|13))) (let () (begin (let ((.v|29|32 .v|4|10|25) (.i|29|32 2) (.x|29|32 .t|4|7|16)) (begin (.check! (fixnum? .i|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (vector? .v|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (<:fix:fix .i|29|32 (vector-length:vec .v|29|32)) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (>=:fix:fix .i|29|32 0) 41 .v|29|32 .i|29|32 .x|29|32) (vector-set!:trusted .v|29|32 .i|29|32 .x|29|32))) (let ((.v|33|36 .v|4|10|25) (.i|33|36 1) (.x|33|36 .t|4|6|19)) (begin (.check! (fixnum? .i|33|36) 41 .v|33|36 .i|33|36 .x|33|36) (.check! (vector? .v|33|36) 41 .v|33|36 .i|33|36 .x|33|36) (.check! (<:fix:fix .i|33|36 (vector-length:vec .v|33|36)) 41 .v|33|36 .i|33|36 .x|33|36) (.check! (>=:fix:fix .i|33|36 0) 41 .v|33|36 .i|33|36 .x|33|36) (vector-set!:trusted .v|33|36 .i|33|36 .x|33|36))) (let ((.v|37|40 .v|4|10|25) (.i|37|40 0) (.x|37|40 .t|4|5|22)) (begin (.check! (fixnum? .i|37|40) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (vector? .v|37|40) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (<:fix:fix .i|37|40 (vector-length:vec .v|37|40)) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (>=:fix:fix .i|37|40 0) 41 .v|37|40 .i|37|40 .x|37|40) (vector-set!:trusted .v|37|40 .i|37|40 .x|37|40))) .v|4|10|25))))) (.make-notepad|2 .l|1))))) 'make-notepad))
(let () (begin (set! notepad.parent (lambda (.np|1) (let ((.notepad.parent|2 0)) (begin (set! .notepad.parent|2 (lambda (.np|3) (let ((.v|4|7 .np|3) (.i|4|7 0)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.notepad.parent|2 .np|1))))) 'notepad.parent))
(let () (begin (set! notepad.lambdas (lambda (.np|1) (let ((.notepad.lambdas|2 0)) (begin (set! .notepad.lambdas|2 (lambda (.np|3) (let ((.v|4|7 .np|3) (.i|4|7 1)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.notepad.lambdas|2 .np|1))))) 'notepad.lambdas))
(let () (begin (set! notepad.nonescaping (lambda (.np|1) (let ((.notepad.nonescaping|2 0)) (begin (set! .notepad.nonescaping|2 (lambda (.np|3) (let ((.v|4|7 .np|3) (.i|4|7 2)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.notepad.nonescaping|2 .np|1))))) 'notepad.nonescaping))
(let () (begin (set! notepad.vars (lambda (.np|1) (let ((.notepad.vars|2 0)) (begin (set! .notepad.vars|2 (lambda (.np|3) (let ((.v|4|7 .np|3) (.i|4|7 3)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.notepad.vars|2 .np|1))))) 'notepad.vars))
(let () (begin (set! notepad.lambdas-set! (lambda (.np|1 .x|1) (let ((.notepad.lambdas-set!|2 0)) (begin (set! .notepad.lambdas-set!|2 (lambda (.np|3 .x|3) (let ((.v|4|7 .np|3) (.i|4|7 1) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))))) (.notepad.lambdas-set!|2 .np|1 .x|1))))) 'notepad.lambdas-set!))
(let () (begin (set! notepad.nonescaping-set! (lambda (.np|1 .x|1) (let ((.notepad.nonescaping-set!|2 0)) (begin (set! .notepad.nonescaping-set!|2 (lambda (.np|3 .x|3) (let ((.v|4|7 .np|3) (.i|4|7 2) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))))) (.notepad.nonescaping-set!|2 .np|1 .x|1))))) 'notepad.nonescaping-set!))
(let () (begin (set! notepad.vars-set! (lambda (.np|1 .x|1) (let ((.notepad.vars-set!|2 0)) (begin (set! .notepad.vars-set!|2 (lambda (.np|3 .x|3) (let ((.v|4|7 .np|3) (.i|4|7 3) (.x|4|7 .x|3)) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))))) (.notepad.vars-set!|2 .np|1 .x|1))))) 'notepad.vars-set!))
(let () (begin (set! notepad-lambda-add! (lambda (.np|1 .l|1) (let ((.notepad-lambda-add!|2 0)) (begin (set! .notepad-lambda-add!|2 (lambda (.np|3 .l|3) (notepad.lambdas-set! .np|3 (cons .l|3 (notepad.lambdas .np|3))))) (.notepad-lambda-add!|2 .np|1 .l|1))))) 'notepad-lambda-add!))
(let () (begin (set! notepad-nonescaping-add! (lambda (.np|1 .l|1) (let ((.notepad-nonescaping-add!|2 0)) (begin (set! .notepad-nonescaping-add!|2 (lambda (.np|3 .l|3) (notepad.nonescaping-set! .np|3 (cons .l|3 (notepad.nonescaping .np|3))))) (.notepad-nonescaping-add!|2 .np|1 .l|1))))) 'notepad-nonescaping-add!))
(let () (begin (set! notepad-var-add! (lambda (.np|1 .i|1) (let ((.notepad-var-add!|2 0)) (begin (set! .notepad-var-add!|2 (lambda (.np|3 .i|3) (let ((.vars|6 (notepad.vars .np|3))) (if (not (memq .i|3 .vars|6)) (notepad.vars-set! .np|3 (cons .i|3 .vars|6)) (unspecified))))) (.notepad-var-add!|2 .np|1 .i|1))))) 'notepad-var-add!))
(let () (begin (set! notepad-captured-variables (lambda (.np|1) (let ((.notepad-captured-variables|2 0)) (begin (set! .notepad-captured-variables|2 (lambda (.np|3) (let ((.nonescaping|6 (notepad.nonescaping .np|3))) (apply-union (let () (let ((.loop|12|15|18 (unspecified))) (begin (set! .loop|12|15|18 (lambda (.y1|7|8|19 .results|7|11|19) (if (null? .y1|7|8|19) (reverse .results|7|11|19) (begin #t (.loop|12|15|18 (let ((.x|23|26 .y1|7|8|19)) (begin (.check! (pair? .x|23|26) 1 .x|23|26) (cdr:pair .x|23|26))) (cons (let ((.l|27 (let ((.x|28|31 .y1|7|8|19)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31))))) (if (memq .l|27 .nonescaping|6) (lambda.g .l|27) (lambda.f .l|27))) .results|7|11|19)))))) (.loop|12|15|18 (notepad.lambdas .np|3) '())))))))) (.notepad-captured-variables|2 .np|1))))) 'notepad-captured-variables))
(let () (begin (set! notepad-free-variables (lambda (.np|1) (let ((.notepad-free-variables|2 0)) (begin (set! .notepad-free-variables|2 (lambda (.np|3) (let () (let ((.loop|4|7|10 (unspecified))) (begin (set! .loop|4|7|10 (lambda (.lambdas|11 .fv|11) (if (null? .lambdas|11) .fv|11 (begin #t (.loop|4|7|10 (let ((.x|14|17 .lambdas|11)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))) (let ((.l|20 (let ((.x|21|24 .lambdas|11)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24))))) (union (difference (lambda.f .l|20) (make-null-terminated (lambda.args .l|20))) .fv|11))))))) (.loop|4|7|10 (notepad.lambdas .np|3) (notepad.vars .np|3))))))) (.notepad-free-variables|2 .np|1))))) 'notepad-free-variables))
(let () ($$trace "prefs"))
(let () (begin (set! begin1 (string->symbol "Begin")) 'begin1))
(let () (begin (set! define1 (string->symbol "Define")) 'define1))
(let () (begin (set! quote1 (string->symbol "Quote")) 'quote1))
(let () (begin (set! lambda1 (string->symbol "Lambda")) 'lambda1))
(let () (begin (set! if1 (string->symbol "If")) 'if1))
(let () (begin (set! set!1 (string->symbol "Set!")) 'set!1))
(let () (begin (set! undefined1 (cons (string->symbol "Undefined") '())) 'undefined1))
(let () (begin (set! renaming-prefix-character #\.) 'renaming-prefix-character))
(let () (begin (set! renaming-suffix-character #\|) 'renaming-suffix-character))
(let () (begin (set! renaming-prefix (string renaming-prefix-character)) 'renaming-prefix))
(let () (begin (set! renaming-suffix (string renaming-suffix-character)) 'renaming-suffix))
(let () (begin (set! make-toplevel-definition (lambda (.id|1 .exp|1) (let ((.make-toplevel-definition|2 0)) (begin (set! .make-toplevel-definition|2 (lambda (.id|3 .exp|3) (begin (if (lambda? .exp|3) (doc.name-set! (lambda.doc .exp|3) .id|3) (unspecified)) (make-begin (let* ((.t1|4|7 (make-assignment .id|3 .exp|3)) (.t2|4|10 (cons (make-constant .id|3) '()))) (let () (cons .t1|4|7 .t2|4|10))))))) (.make-toplevel-definition|2 .id|1 .exp|1))))) 'make-toplevel-definition))
(let () (begin (set! make-undefined (lambda () (let ((.make-undefined|2 0)) (begin (set! .make-undefined|2 (lambda () (make-call (make-variable 'undefined) '()))) (.make-undefined|2))))) 'make-undefined))
(let () (begin (set! make-unspecified (lambda () (let ((.make-unspecified|2 0)) (begin (set! .make-unspecified|2 (lambda () (make-call (make-variable 'unspecified) '()))) (.make-unspecified|2))))) 'make-unspecified))
(let () ($$trace "syntaxenv"))
(let () (begin (set! standard-syntactic-environment '((quote special quote) (lambda special lambda) (if special if) (set! special set!) (begin special begin) (define special define) (define-inline special define-inline) (define-syntax special define-syntax) (let-syntax special let-syntax) (letrec-syntax special letrec-syntax) (syntax-rules special syntax-rules))) 'standard-syntactic-environment))
(let () (begin (set! lambda0 (string->symbol " lambda ")) 'lambda0))
(let () (begin (set! set!0 (string->symbol " set! ")) 'set!0))
(let () (begin (set! syntactic-copy (lambda (.env|1) (let ((.syntactic-copy|2 0)) (begin (set! .syntactic-copy|2 (lambda (.env|3) (copy-alist .env|3))) (.syntactic-copy|2 .env|1))))) 'syntactic-copy))
(let () (begin (set! make-basic-syntactic-environment (lambda () (let ((.make-basic-syntactic-environment|2 0)) (begin (set! .make-basic-syntactic-environment|2 (lambda () (cons (cons lambda0 (let ((.x|4|7 (assq 'lambda standard-syntactic-environment))) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7)))) (cons (cons set!0 (let ((.x|8|11 (assq 'set! standard-syntactic-environment))) (begin (.check! (pair? .x|8|11) 1 .x|8|11) (cdr:pair .x|8|11)))) (syntactic-copy standard-syntactic-environment))))) (.make-basic-syntactic-environment|2))))) 'make-basic-syntactic-environment))
(let () (begin (set! global-syntactic-environment (make-basic-syntactic-environment)) 'global-syntactic-environment))
(let () (begin (set! global-syntactic-environment-set! (lambda (.env|1) (let ((.global-syntactic-environment-set!|2 0)) (begin (set! .global-syntactic-environment-set!|2 (lambda (.env|3) (begin (set-cdr! global-syntactic-environment .env|3) #t))) (.global-syntactic-environment-set!|2 .env|1))))) 'global-syntactic-environment-set!))
(let () (begin (set! syntactic-bind-globally! (lambda (.id|1 .denotation|1) (let ((.syntactic-bind-globally!|2 0)) (begin (set! .syntactic-bind-globally!|2 (lambda (.id|3 .denotation|3) (if (if (identifier-denotation? .denotation|3) (eq? .id|3 (identifier-name .denotation|3)) #f) (let () (let ((.remove-bindings-for-id|8 (unspecified))) (begin (set! .remove-bindings-for-id|8 (lambda (.bindings|9) (if (null? .bindings|9) '() (if (eq? (let ((.x|13|16 (let ((.x|17|20 .bindings|9)) (begin (.check! (pair? .x|17|20) 0 .x|17|20) (car:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 0 .x|13|16) (car:pair .x|13|16))) .id|3) (.remove-bindings-for-id|8 (let ((.x|21|24 .bindings|9)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24)))) (cons (let ((.x|26|29 .bindings|9)) (begin (.check! (pair? .x|26|29) 0 .x|26|29) (car:pair .x|26|29))) (.remove-bindings-for-id|8 (let ((.x|30|33 .bindings|9)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))))))))) (global-syntactic-environment-set! (.remove-bindings-for-id|8 (let ((.x|34|37 global-syntactic-environment)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37)))))))) (let ((.x|40 (assq .id|3 global-syntactic-environment))) (if .x|40 (begin (set-cdr! .x|40 .denotation|3) #t) (global-syntactic-environment-set! (cons (cons .id|3 .denotation|3) (let ((.x|41|44 global-syntactic-environment)) (begin (.check! (pair? .x|41|44) 1 .x|41|44) (cdr:pair .x|41|44)))))))))) (.syntactic-bind-globally!|2 .id|1 .denotation|1))))) 'syntactic-bind-globally!))
(let () (begin (set! syntactic-divert (lambda (.env1|1 .env2|1) (let ((.syntactic-divert|2 0)) (begin (set! .syntactic-divert|2 (lambda (.env1|3 .env2|3) (append .env2|3 .env1|3))) (.syntactic-divert|2 .env1|1 .env2|1))))) 'syntactic-divert))
(let () (begin (set! syntactic-extend (lambda (.env|1 .ids|1 .denotations|1) (let ((.syntactic-extend|2 0)) (begin (set! .syntactic-extend|2 (lambda (.env|3 .ids|3 .denotations|3) (syntactic-divert .env|3 (let () (let ((.loop|10|14|17 (unspecified))) (begin (set! .loop|10|14|17 (lambda (.y1|4|6|18 .y1|4|5|18 .results|4|9|18) (if (let ((.temp|20|23 (null? .y1|4|6|18))) (if .temp|20|23 .temp|20|23 (null? .y1|4|5|18))) (reverse .results|4|9|18) (begin #t (.loop|10|14|17 (let ((.x|26|29 .y1|4|6|18)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))) (let ((.x|30|33 .y1|4|5|18)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))) (cons (cons (let ((.x|34|37 .y1|4|6|18)) (begin (.check! (pair? .x|34|37) 0 .x|34|37) (car:pair .x|34|37))) (let ((.x|38|41 .y1|4|5|18)) (begin (.check! (pair? .x|38|41) 0 .x|38|41) (car:pair .x|38|41)))) .results|4|9|18)))))) (.loop|10|14|17 .ids|3 .denotations|3 '()))))))) (.syntactic-extend|2 .env|1 .ids|1 .denotations|1))))) 'syntactic-extend))
(let () (begin (set! syntactic-lookup (lambda (.env|1 .id|1) (let ((.syntactic-lookup|2 0)) (begin (set! .syntactic-lookup|2 (lambda (.env|3 .id|3) (let ((.entry|6 (assq .id|3 .env|3))) (if .entry|6 (let ((.x|7|10 .entry|6)) (begin (.check! (pair? .x|7|10) 1 .x|7|10) (cdr:pair .x|7|10))) (make-identifier-denotation .id|3))))) (.syntactic-lookup|2 .env|1 .id|1))))) 'syntactic-lookup))
(let () (begin (set! syntactic-assign! (lambda (.env|1 .id|1 .denotation|1) (let ((.syntactic-assign!|2 0)) (begin (set! .syntactic-assign!|2 (lambda (.env|3 .id|3 .denotation|3) (let ((.entry|6 (assq .id|3 .env|3))) (if .entry|6 (set-cdr! .entry|6 .denotation|3) (m-bug "Bug detected in syntactic-assign!" .env|3 .id|3 .denotation|3))))) (.syntactic-assign!|2 .env|1 .id|1 .denotation|1))))) 'syntactic-assign!))
(let () (begin (set! denotation-class car) 'denotation-class))
(let () (begin (set! special-denotation? (lambda (.denotation|1) (let ((.special-denotation?|2 0)) (begin (set! .special-denotation?|2 (lambda (.denotation|3) (eq? (denotation-class .denotation|3) 'special))) (.special-denotation?|2 .denotation|1))))) 'special-denotation?))
(let () (begin (set! macro-denotation? (lambda (.denotation|1) (let ((.macro-denotation?|2 0)) (begin (set! .macro-denotation?|2 (lambda (.denotation|3) (eq? (denotation-class .denotation|3) 'macro))) (.macro-denotation?|2 .denotation|1))))) 'macro-denotation?))
(let () (begin (set! inline-denotation? (lambda (.denotation|1) (let ((.inline-denotation?|2 0)) (begin (set! .inline-denotation?|2 (lambda (.denotation|3) (eq? (denotation-class .denotation|3) 'inline))) (.inline-denotation?|2 .denotation|1))))) 'inline-denotation?))
(let () (begin (set! identifier-denotation? (lambda (.denotation|1) (let ((.identifier-denotation?|2 0)) (begin (set! .identifier-denotation?|2 (lambda (.denotation|3) (eq? (denotation-class .denotation|3) 'identifier))) (.identifier-denotation?|2 .denotation|1))))) 'identifier-denotation?))
(let () (begin (set! make-macro-denotation (lambda (.rules|1 .env|1) (let ((.make-macro-denotation|2 0)) (begin (set! .make-macro-denotation|2 (lambda (.rules|3 .env|3) (let* ((.t1|4|7 'macro) (.t2|4|10 (let* ((.t1|14|17 .rules|3) (.t2|14|20 (cons .env|3 '()))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-macro-denotation|2 .rules|1 .env|1))))) 'make-macro-denotation))
(let () (begin (set! make-inline-denotation (lambda (.id|1 .rules|1 .env|1) (let ((.make-inline-denotation|2 0)) (begin (set! .make-inline-denotation|2 (lambda (.id|3 .rules|3 .env|3) (let* ((.t1|4|7 'inline) (.t2|4|10 (let* ((.t1|14|17 .rules|3) (.t2|14|20 (let* ((.t1|24|27 .env|3) (.t2|24|30 (cons .id|3 '()))) (let () (cons .t1|24|27 .t2|24|30))))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-inline-denotation|2 .id|1 .rules|1 .env|1))))) 'make-inline-denotation))
(let () (begin (set! make-identifier-denotation (lambda (.id|1) (let ((.make-identifier-denotation|2 0)) (begin (set! .make-identifier-denotation|2 (lambda (.id|3) (let* ((.t1|4|7 'identifier) (.t2|4|10 (let* ((.t1|14|17 .id|3) (.t2|14|20 (let* ((.t1|24|27 '()) (.t2|24|30 (let* ((.t1|34|37 '()) (.t2|34|40 (cons '() '()))) (let () (cons .t1|34|37 .t2|34|40))))) (let () (cons .t1|24|27 .t2|24|30))))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-identifier-denotation|2 .id|1))))) 'make-identifier-denotation))
(let () (begin (set! macro-rules cadr) 'macro-rules))
(let () (begin (set! macro-env caddr) 'macro-env))
(let () (begin (set! inline-rules macro-rules) 'inline-rules))
(let () (begin (set! inline-env macro-env) 'inline-env))
(let () (begin (set! inline-name cadddr) 'inline-name))
(let () (begin (set! identifier-name cadr) 'identifier-name))
(let () (begin (set! identifier-r-entry cdr) 'identifier-r-entry))
(let () (begin (set! same-denotation? (lambda (.d1|1 .d2|1) (let ((.same-denotation?|2 0)) (begin (set! .same-denotation?|2 (lambda (.d1|3 .d2|3) (let ((.temp|4|7 (eq? .d1|3 .d2|3))) (if .temp|4|7 .temp|4|7 (if (identifier-denotation? .d1|3) (if (identifier-denotation? .d2|3) (eq? (identifier-name .d1|3) (identifier-name .d2|3)) #f) #f))))) (.same-denotation?|2 .d1|1 .d2|1))))) 'same-denotation?))
(let () (begin (set! denotation-of-quote (syntactic-lookup standard-syntactic-environment 'quote)) 'denotation-of-quote))
(let () (begin (set! denotation-of-lambda (syntactic-lookup standard-syntactic-environment 'lambda)) 'denotation-of-lambda))
(let () (begin (set! denotation-of-if (syntactic-lookup standard-syntactic-environment 'if)) 'denotation-of-if))
(let () (begin (set! denotation-of-set! (syntactic-lookup standard-syntactic-environment 'set!)) 'denotation-of-set!))
(let () (begin (set! denotation-of-begin (syntactic-lookup standard-syntactic-environment 'begin)) 'denotation-of-begin))
(let () (begin (set! denotation-of-define (syntactic-lookup standard-syntactic-environment 'define)) 'denotation-of-define))
(let () (begin (set! denotation-of-define-inline (syntactic-lookup standard-syntactic-environment 'define-inline)) 'denotation-of-define-inline))
(let () (begin (set! denotation-of-define-syntax (syntactic-lookup standard-syntactic-environment 'define-syntax)) 'denotation-of-define-syntax))
(let () (begin (set! denotation-of-let-syntax (syntactic-lookup standard-syntactic-environment 'let-syntax)) 'denotation-of-let-syntax))
(let () (begin (set! denotation-of-letrec-syntax (syntactic-lookup standard-syntactic-environment 'letrec-syntax)) 'denotation-of-letrec-syntax))
(let () (begin (set! denotation-of-syntax-rules (syntactic-lookup standard-syntactic-environment 'syntax-rules)) 'denotation-of-syntax-rules))
(let () (begin (set! denotation-of-... (syntactic-lookup standard-syntactic-environment '...)) 'denotation-of-...))
(let () (begin (set! denotation-of-transformer (syntactic-lookup standard-syntactic-environment 'transformer)) 'denotation-of-transformer))
(let () (begin (set! syntactic-alias (lambda (.env|1 .alist|1 .env2|1) (let ((.syntactic-alias|2 0)) (begin (set! .syntactic-alias|2 (lambda (.env|3 .alist|3 .env2|3) (syntactic-divert .env|3 (let () (let ((.loop|9|12|15 (unspecified))) (begin (set! .loop|9|12|15 (lambda (.y1|4|5|16 .results|4|8|16) (if (null? .y1|4|5|16) (reverse .results|4|8|16) (begin #t (.loop|9|12|15 (let ((.x|20|23 .y1|4|5|16)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) (cons (let ((.name-pair|24 (let ((.x|36|39 .y1|4|5|16)) (begin (.check! (pair? .x|36|39) 0 .x|36|39) (car:pair .x|36|39))))) (let ((.old-name|27 (let ((.x|28|31 .name-pair|24)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31)))) (.new-name|27 (let ((.x|32|35 .name-pair|24)) (begin (.check! (pair? .x|32|35) 1 .x|32|35) (cdr:pair .x|32|35))))) (cons .new-name|27 (syntactic-lookup .env2|3 .old-name|27)))) .results|4|8|16)))))) (.loop|9|12|15 .alist|3 '()))))))) (.syntactic-alias|2 .env|1 .alist|1 .env2|1))))) 'syntactic-alias))
(let () (begin (set! syntactic-rename (lambda (.env|1 .alist|1) (let ((.syntactic-rename|2 0)) (begin (set! .syntactic-rename|2 (lambda (.env|3 .alist|3) (if (null? .alist|3) .env|3 (let* ((.old|6 (let ((.x|30|33 (let ((.x|34|37 .alist|3)) (begin (.check! (pair? .x|34|37) 0 .x|34|37) (car:pair .x|34|37))))) (begin (.check! (pair? .x|30|33) 0 .x|30|33) (car:pair .x|30|33)))) (.new|9 (let ((.x|21|24 (let ((.x|25|28 .alist|3)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28))))) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24)))) (.denotation|12 (make-identifier-denotation .new|9))) (let () (.syntactic-rename|2 (cons (cons .old|6 .denotation|12) (cons (cons .new|9 .denotation|12) .env|3)) (let ((.x|16|19 .alist|3)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19))))))))) (.syntactic-rename|2 .env|1 .alist|1))))) 'syntactic-rename))
(let () (begin (set! renaming-counter 0) 'renaming-counter))
(let () (begin (set! make-rename-procedure (lambda () (let ((.make-rename-procedure|2 0)) (begin (set! .make-rename-procedure|2 (lambda () (begin (set! renaming-counter (+ renaming-counter 1)) (let ((.suffix|6 (string-append renaming-suffix (number->string renaming-counter)))) (lambda (.sym|7) (if (symbol? .sym|7) (let ((.s|10 (symbol->string .sym|7))) (if (if (> (string-length .s|10) 0) (char=? (string-ref .s|10 0) renaming-prefix-character) #f) (string->symbol (string-append .s|10 .suffix|6)) (string->symbol (string-append renaming-prefix .s|10 .suffix|6)))) (m-warn "Illegal use of rename procedure" 'ok:fixme .sym|7))))))) (.make-rename-procedure|2))))) 'make-rename-procedure))
(let () (begin (set! m-strip (lambda (.x|1) (let ((.m-strip|2 0)) (begin (set! .m-strip|2 (lambda (.x|3) (let ((.original-symbol|5 (unspecified))) (begin (set! .original-symbol|5 (lambda (.x|6) (let ((.loop|9 (unspecified))) (begin (set! .loop|9 (lambda (.sym|10 .s|10 .i|10 .n|10) (if (= .i|10 .n|10) .sym|10 (if (char=? (string-ref .s|10 .i|10) renaming-suffix-character) (string->symbol (substring .s|10 1 .i|10)) (.loop|9 .sym|10 .s|10 (+ .i|10 1) .n|10))))) (let ((.s|14 (symbol->string .x|6))) (if (if (> (string-length .s|14) 0) (char=? (string-ref .s|14 0) renaming-prefix-character) #f) (.loop|9 .x|6 .s|14 0 (string-length .s|14)) .x|6)))))) (if (symbol? .x|3) (.original-symbol|5 .x|3) (if (pair? .x|3) (let ((.a|21 (.m-strip|2 (let ((.x|32|35 .x|3)) (begin (.check! (pair? .x|32|35) 0 .x|32|35) (car:pair .x|32|35))))) (.b|21 (.m-strip|2 (let ((.x|36|39 .x|3)) (begin (.check! (pair? .x|36|39) 1 .x|36|39) (cdr:pair .x|36|39)))))) (if (if (eq? .a|21 (let ((.x|23|26 .x|3)) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26)))) (eq? .b|21 (let ((.x|28|31 .x|3)) (begin (.check! (pair? .x|28|31) 1 .x|28|31) (cdr:pair .x|28|31)))) #f) .x|3 (cons .a|21 .b|21))) (if (vector? .x|3) (let* ((.v|43 (vector->list .x|3)) (.v2|46 (let () (let ((.loop|55|58|61 (unspecified))) (begin (set! .loop|55|58|61 (lambda (.y1|50|51|62 .results|50|54|62) (if (null? .y1|50|51|62) (reverse .results|50|54|62) (begin #t (.loop|55|58|61 (let ((.x|66|69 .y1|50|51|62)) (begin (.check! (pair? .x|66|69) 1 .x|66|69) (cdr:pair .x|66|69))) (cons (.m-strip|2 (let ((.x|70|73 .y1|50|51|62)) (begin (.check! (pair? .x|70|73) 0 .x|70|73) (car:pair .x|70|73)))) .results|50|54|62)))))) (.loop|55|58|61 .v|43 '())))))) (let () (if (equal? .v|43 .v2|46) .x|3 (list->vector .v2|46)))) .x|3))))))) (.m-strip|2 .x|1))))) 'm-strip))
(let () (begin (set! rename-vars (lambda (.original-vars|1) (let ((.rename-vars|2 0)) (begin (set! .rename-vars|2 (lambda (.original-vars|3) (let* ((.rename|6 (make-rename-procedure)) (.loop|7 (unspecified))) (begin (set! .loop|7 (lambda (.vars|8 .newvars|8) (if (null? .vars|8) (reverse .newvars|8) (if (pair? .vars|8) (let ((.var|13 (let ((.x|18|21 .vars|8)) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))))) (if (symbol? .var|13) (.loop|7 (let ((.x|14|17 .vars|8)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))) (cons (cons .var|13 (.rename|6 .var|13)) .newvars|8)) (m-error "Illegal variable" .var|13))) (if (symbol? .vars|8) (.loop|7 (cons .vars|8 '()) .newvars|8) (m-error "Malformed parameter list" .original-vars|3)))))) (.loop|7 .original-vars|3 '()))))) (.rename-vars|2 .original-vars|1))))) 'rename-vars))
(let () (begin (set! rename-formals (lambda (.formals|1 .alist|1) (let ((.rename-formals|2 0)) (begin (set! .rename-formals|2 (lambda (.formals|3 .alist|3) (if (null? .formals|3) '() (if (pair? .formals|3) (cons (let ((.x|6|9 (assq (let ((.x|10|13 .formals|3)) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13))) .alist|3))) (begin (.check! (pair? .x|6|9) 1 .x|6|9) (cdr:pair .x|6|9))) (.rename-formals|2 (let ((.x|14|17 .formals|3)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))) .alist|3)) (let ((.x|19|22 (assq .formals|3 .alist|3))) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22))))))) (.rename-formals|2 .formals|1 .alist|1))))) 'rename-formals))
(let () ($$trace "syntaxrules"))
(let () (begin (set! pattern-variable-flag (cons 'v '())) 'pattern-variable-flag))
(let () (begin (set! ellipsis-pattern-flag (cons 'e '())) 'ellipsis-pattern-flag))
(let () (begin (set! ellipsis-template-flag ellipsis-pattern-flag) 'ellipsis-template-flag))
(let () (begin (set! make-patternvar (lambda (.v|1 .rank|1) (let ((.make-patternvar|2 0)) (begin (set! .make-patternvar|2 (lambda (.v|3 .rank|3) (let* ((.t|4|7|12 .rank|3) (.t|4|6|15 .v|3) (.t|4|5|18 pattern-variable-flag) (.v|4|9|21 (make-vector 3 .t|4|7|12))) (let () (begin (let ((.v|25|28 .v|4|9|21) (.i|25|28 1) (.x|25|28 .t|4|6|15)) (begin (.check! (fixnum? .i|25|28) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (vector? .v|25|28) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (<:fix:fix .i|25|28 (vector-length:vec .v|25|28)) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (>=:fix:fix .i|25|28 0) 41 .v|25|28 .i|25|28 .x|25|28) (vector-set!:trusted .v|25|28 .i|25|28 .x|25|28))) (let ((.v|29|32 .v|4|9|21) (.i|29|32 0) (.x|29|32 .t|4|5|18)) (begin (.check! (fixnum? .i|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (vector? .v|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (<:fix:fix .i|29|32 (vector-length:vec .v|29|32)) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (>=:fix:fix .i|29|32 0) 41 .v|29|32 .i|29|32 .x|29|32) (vector-set!:trusted .v|29|32 .i|29|32 .x|29|32))) .v|4|9|21))))) (.make-patternvar|2 .v|1 .rank|1))))) 'make-patternvar))
(let () (begin (set! make-ellipsis-pattern (lambda (.p|1 .vars|1) (let ((.make-ellipsis-pattern|2 0)) (begin (set! .make-ellipsis-pattern|2 (lambda (.p|3 .vars|3) (let* ((.t|4|7|12 .vars|3) (.t|4|6|15 .p|3) (.t|4|5|18 ellipsis-pattern-flag) (.v|4|9|21 (make-vector 3 .t|4|7|12))) (let () (begin (let ((.v|25|28 .v|4|9|21) (.i|25|28 1) (.x|25|28 .t|4|6|15)) (begin (.check! (fixnum? .i|25|28) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (vector? .v|25|28) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (<:fix:fix .i|25|28 (vector-length:vec .v|25|28)) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (>=:fix:fix .i|25|28 0) 41 .v|25|28 .i|25|28 .x|25|28) (vector-set!:trusted .v|25|28 .i|25|28 .x|25|28))) (let ((.v|29|32 .v|4|9|21) (.i|29|32 0) (.x|29|32 .t|4|5|18)) (begin (.check! (fixnum? .i|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (vector? .v|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (<:fix:fix .i|29|32 (vector-length:vec .v|29|32)) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (>=:fix:fix .i|29|32 0) 41 .v|29|32 .i|29|32 .x|29|32) (vector-set!:trusted .v|29|32 .i|29|32 .x|29|32))) .v|4|9|21))))) (.make-ellipsis-pattern|2 .p|1 .vars|1))))) 'make-ellipsis-pattern))
(let () (begin (set! make-ellipsis-template (lambda (.t|1 .vars|1) (let ((.make-ellipsis-template|2 0)) (begin (set! .make-ellipsis-template|2 (lambda (.t|3 .vars|3) (let* ((.t|4|7|12 .vars|3) (.t|4|6|15 .t|3) (.t|4|5|18 ellipsis-template-flag) (.v|4|9|21 (make-vector 3 .t|4|7|12))) (let () (begin (let ((.v|25|28 .v|4|9|21) (.i|25|28 1) (.x|25|28 .t|4|6|15)) (begin (.check! (fixnum? .i|25|28) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (vector? .v|25|28) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (<:fix:fix .i|25|28 (vector-length:vec .v|25|28)) 41 .v|25|28 .i|25|28 .x|25|28) (.check! (>=:fix:fix .i|25|28 0) 41 .v|25|28 .i|25|28 .x|25|28) (vector-set!:trusted .v|25|28 .i|25|28 .x|25|28))) (let ((.v|29|32 .v|4|9|21) (.i|29|32 0) (.x|29|32 .t|4|5|18)) (begin (.check! (fixnum? .i|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (vector? .v|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (<:fix:fix .i|29|32 (vector-length:vec .v|29|32)) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (>=:fix:fix .i|29|32 0) 41 .v|29|32 .i|29|32 .x|29|32) (vector-set!:trusted .v|29|32 .i|29|32 .x|29|32))) .v|4|9|21))))) (.make-ellipsis-template|2 .t|1 .vars|1))))) 'make-ellipsis-template))
(let () (begin (set! patternvar? (lambda (.x|1) (let ((.patternvar?|2 0)) (begin (set! .patternvar?|2 (lambda (.x|3) (if (vector? .x|3) (if (= (let ((.v|6|9 .x|3)) (begin (.check! (vector? .v|6|9) 42 .v|6|9) (vector-length:vec .v|6|9))) 3) (eq? (let ((.v|11|14 .x|3) (.i|11|14 0)) (begin (.check! (fixnum? .i|11|14) 40 .v|11|14 .i|11|14) (.check! (vector? .v|11|14) 40 .v|11|14 .i|11|14) (.check! (<:fix:fix .i|11|14 (vector-length:vec .v|11|14)) 40 .v|11|14 .i|11|14) (.check! (>=:fix:fix .i|11|14 0) 40 .v|11|14 .i|11|14) (vector-ref:trusted .v|11|14 .i|11|14))) pattern-variable-flag) #f) #f))) (.patternvar?|2 .x|1))))) 'patternvar?))
(let () (begin (set! ellipsis-pattern? (lambda (.x|1) (let ((.ellipsis-pattern?|2 0)) (begin (set! .ellipsis-pattern?|2 (lambda (.x|3) (if (vector? .x|3) (if (= (let ((.v|6|9 .x|3)) (begin (.check! (vector? .v|6|9) 42 .v|6|9) (vector-length:vec .v|6|9))) 3) (eq? (let ((.v|11|14 .x|3) (.i|11|14 0)) (begin (.check! (fixnum? .i|11|14) 40 .v|11|14 .i|11|14) (.check! (vector? .v|11|14) 40 .v|11|14 .i|11|14) (.check! (<:fix:fix .i|11|14 (vector-length:vec .v|11|14)) 40 .v|11|14 .i|11|14) (.check! (>=:fix:fix .i|11|14 0) 40 .v|11|14 .i|11|14) (vector-ref:trusted .v|11|14 .i|11|14))) ellipsis-pattern-flag) #f) #f))) (.ellipsis-pattern?|2 .x|1))))) 'ellipsis-pattern?))
(let () (begin (set! ellipsis-template? (lambda (.x|1) (let ((.ellipsis-template?|2 0)) (begin (set! .ellipsis-template?|2 (lambda (.x|3) (if (vector? .x|3) (if (= (let ((.v|6|9 .x|3)) (begin (.check! (vector? .v|6|9) 42 .v|6|9) (vector-length:vec .v|6|9))) 3) (eq? (let ((.v|11|14 .x|3) (.i|11|14 0)) (begin (.check! (fixnum? .i|11|14) 40 .v|11|14 .i|11|14) (.check! (vector? .v|11|14) 40 .v|11|14 .i|11|14) (.check! (<:fix:fix .i|11|14 (vector-length:vec .v|11|14)) 40 .v|11|14 .i|11|14) (.check! (>=:fix:fix .i|11|14 0) 40 .v|11|14 .i|11|14) (vector-ref:trusted .v|11|14 .i|11|14))) ellipsis-template-flag) #f) #f))) (.ellipsis-template?|2 .x|1))))) 'ellipsis-template?))
(let () (begin (set! patternvar-name (lambda (.v|1) (let ((.patternvar-name|2 0)) (begin (set! .patternvar-name|2 (lambda (.v|3) (let ((.v|4|7 .v|3) (.i|4|7 1)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.patternvar-name|2 .v|1))))) 'patternvar-name))
(let () (begin (set! patternvar-rank (lambda (.v|1) (let ((.patternvar-rank|2 0)) (begin (set! .patternvar-rank|2 (lambda (.v|3) (let ((.v|4|7 .v|3) (.i|4|7 2)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.patternvar-rank|2 .v|1))))) 'patternvar-rank))
(let () (begin (set! ellipsis-pattern (lambda (.p|1) (let ((.ellipsis-pattern|2 0)) (begin (set! .ellipsis-pattern|2 (lambda (.p|3) (let ((.v|4|7 .p|3) (.i|4|7 1)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.ellipsis-pattern|2 .p|1))))) 'ellipsis-pattern))
(let () (begin (set! ellipsis-pattern-vars (lambda (.p|1) (let ((.ellipsis-pattern-vars|2 0)) (begin (set! .ellipsis-pattern-vars|2 (lambda (.p|3) (let ((.v|4|7 .p|3) (.i|4|7 2)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.ellipsis-pattern-vars|2 .p|1))))) 'ellipsis-pattern-vars))
(let () (begin (set! ellipsis-template (lambda (.t|1) (let ((.ellipsis-template|2 0)) (begin (set! .ellipsis-template|2 (lambda (.t|3) (let ((.v|4|7 .t|3) (.i|4|7 1)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.ellipsis-template|2 .t|1))))) 'ellipsis-template))
(let () (begin (set! ellipsis-template-vars (lambda (.t|1) (let ((.ellipsis-template-vars|2 0)) (begin (set! .ellipsis-template-vars|2 (lambda (.t|3) (let ((.v|4|7 .t|3) (.i|4|7 2)) (begin (.check! (fixnum? .i|4|7) 40 .v|4|7 .i|4|7) (.check! (vector? .v|4|7) 40 .v|4|7 .i|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 40 .v|4|7 .i|4|7) (.check! (>=:fix:fix .i|4|7 0) 40 .v|4|7 .i|4|7) (vector-ref:trusted .v|4|7 .i|4|7))))) (.ellipsis-template-vars|2 .t|1))))) 'ellipsis-template-vars))
(let () (begin (set! pattern-variable (lambda (.v|1 .vars|1) (let ((.pattern-variable|2 0)) (begin (set! .pattern-variable|2 (lambda (.v|3 .vars|3) (if (null? .vars|3) #f (if (eq? .v|3 (patternvar-name (let ((.x|6|9 .vars|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9))))) (let ((.x|10|13 .vars|3)) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13))) (.pattern-variable|2 .v|3 (let ((.x|15|18 .vars|3)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18)))))))) (.pattern-variable|2 .v|1 .vars|1))))) 'pattern-variable))
(let () (begin (set! m-compile-transformer-spec (lambda (.spec|1 .env|1) (let ((.m-compile-transformer-spec|2 0)) (begin (set! .m-compile-transformer-spec|2 (lambda (.spec|3 .env|3) (if (if (> (safe-length .spec|3) 1) (eq? (syntactic-lookup .env|3 (let ((.x|6|9 .spec|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9)))) denotation-of-syntax-rules) #f) (let ((.literals|12 (let ((.x|72|75 (let ((.x|76|79 .spec|3)) (begin (.check! (pair? .x|76|79) 1 .x|76|79) (cdr:pair .x|76|79))))) (begin (.check! (pair? .x|72|75) 0 .x|72|75) (car:pair .x|72|75)))) (.rules|12 (let ((.x|81|84 (let ((.x|85|88 .spec|3)) (begin (.check! (pair? .x|85|88) 1 .x|85|88) (cdr:pair .x|85|88))))) (begin (.check! (pair? .x|81|84) 1 .x|81|84) (cdr:pair .x|81|84))))) (begin (if (let ((.temp|13|16 (not (list? .literals|12)))) (if .temp|13|16 .temp|13|16 (not (every1? (lambda (.rule|18) (if (= (safe-length .rule|18) 2) (pair? (let ((.x|21|24 .rule|18)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24)))) #f)) .rules|12)))) (m-error "Malformed syntax-rules" .spec|3) (unspecified)) (let* ((.t1|25|28 'macro) (.t2|25|31 (let* ((.t1|35|38 (let () (let ((.loop|51|54|57 (unspecified))) (begin (set! .loop|51|54|57 (lambda (.y1|46|47|58 .results|46|50|58) (if (null? .y1|46|47|58) (reverse .results|46|50|58) (begin #t (.loop|51|54|57 (let ((.x|62|65 .y1|46|47|58)) (begin (.check! (pair? .x|62|65) 1 .x|62|65) (cdr:pair .x|62|65))) (cons (let ((.rule|66 (let ((.x|67|70 .y1|46|47|58)) (begin (.check! (pair? .x|67|70) 0 .x|67|70) (car:pair .x|67|70))))) (m-compile-rule .rule|66 .literals|12 .env|3)) .results|46|50|58)))))) (.loop|51|54|57 .rules|12 '()))))) (.t2|35|41 (cons .env|3 '()))) (let () (cons .t1|35|38 .t2|35|41))))) (let () (cons .t1|25|28 .t2|25|31))))) (m-error "Malformed syntax-rules" .spec|3)))) (.m-compile-transformer-spec|2 .spec|1 .env|1))))) 'm-compile-transformer-spec))
(let () (begin (set! m-compile-rule (lambda (.rule|1 .literals|1 .env|1) (let ((.m-compile-rule|2 0)) (begin (set! .m-compile-rule|2 (lambda (.rule|3 .literals|3 .env|3) (m-compile-pattern (let ((.x|4|7 (let ((.x|8|11 .rule|3)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))))) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .literals|3 .env|3 (lambda (.compiled-rule|12 .patternvars|12) (cons .compiled-rule|12 (m-compile-template (let ((.x|14|17 (let ((.x|18|21 .rule|3)) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21))))) (begin (.check! (pair? .x|14|17) 0 .x|14|17) (car:pair .x|14|17))) .patternvars|12 .env|3)))))) (.m-compile-rule|2 .rule|1 .literals|1 .env|1))))) 'm-compile-rule))
(let () (begin (set! m-compile-pattern (lambda (.p|1 .literals|1 .env|1 .k|1) (let ((.m-compile-pattern|2 0)) (begin (set! .m-compile-pattern|2 (lambda (.p|3 .literals|3 .env|3 .k|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.p|5 .vars|5 .rank|5 .k|5) (if (symbol? .p|5) (if (memq .p|5 .literals|3) (.k|5 .p|5 .vars|5) (let ((.var|9 (make-patternvar .p|5 .rank|5))) (.k|5 .var|9 (cons .var|9 .vars|5)))) (if (null? .p|5) (.k|5 '() .vars|5) (if (pair? .p|5) (if (if (pair? (let ((.x|13|16 .p|5)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16)))) (if (symbol? (let ((.x|19|22 (let ((.x|23|26 .p|5)) (begin (.check! (pair? .x|23|26) 1 .x|23|26) (cdr:pair .x|23|26))))) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22)))) (same-denotation? (syntactic-lookup .env|3 (let ((.x|29|32 (let ((.x|33|36 .p|5)) (begin (.check! (pair? .x|33|36) 1 .x|33|36) (cdr:pair .x|33|36))))) (begin (.check! (pair? .x|29|32) 0 .x|29|32) (car:pair .x|29|32)))) denotation-of-...) #f) #f) (if (null? (let ((.x|38|41 (let ((.x|42|45 .p|5)) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45))))) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41)))) (.loop|4 (let ((.x|46|49 .p|5)) (begin (.check! (pair? .x|46|49) 0 .x|46|49) (car:pair .x|46|49))) '() (+ .rank|5 1) (lambda (.p|50 .vars1|50) (.k|5 (make-ellipsis-pattern .p|50 .vars1|50) (union2 .vars1|50 .vars|5)))) (m-error "Malformed pattern" .p|5)) (.loop|4 (let ((.x|51|54 .p|5)) (begin (.check! (pair? .x|51|54) 0 .x|51|54) (car:pair .x|51|54))) .vars|5 .rank|5 (lambda (.p1|55 .vars|55) (.loop|4 (let ((.x|56|59 .p|5)) (begin (.check! (pair? .x|56|59) 1 .x|56|59) (cdr:pair .x|56|59))) .vars|55 .rank|5 (lambda (.p2|60 .vars|60) (.k|5 (cons .p1|55 .p2|60) .vars|60)))))) (if (vector? .p|5) (.loop|4 (vector->list .p|5) .vars|5 .rank|5 (lambda (.p|62 .vars|62) (.k|5 (make-vector 1 .p|62) .vars|62))) (.k|5 .p|5 .vars|5))))))) (.loop|4 .p|3 '() 0 .k|3))))) (.m-compile-pattern|2 .p|1 .literals|1 .env|1 .k|1))))) 'm-compile-pattern))
(let () (begin (set! m-compile-template (lambda (.t|1 .vars|1 .env|1) (let ((.m-compile-template|2 0)) (begin (set! .m-compile-template|2 (lambda (.t|3 .vars|3 .env|3) (let ((.loop1|4 (unspecified)) (.loop|4 (unspecified))) (begin (set! .loop1|4 (lambda (.t|5 .inserted|5 .referenced|5 .rank|5 .escaped?|5 .k|5) (.loop|4 (let ((.x|6|9 .t|5)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9))) .inserted|5 '() (+ .rank|5 1) .escaped?|5 (lambda (.t1|10 .inserted|10 .referenced1|10) (.loop|4 (let ((.x|12|15 (let ((.x|16|19 .t|5)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19))))) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))) .inserted|10 (append .referenced1|10 .referenced|5) .rank|5 .escaped?|5 (lambda (.t2|20 .inserted|20 .referenced|20) (.k|5 (cons (make-ellipsis-template .t1|10 (filter1 (lambda (.var|21) (> (patternvar-rank .var|21) .rank|5)) .referenced1|10)) .t2|20) .inserted|20 .referenced|20))))))) (set! .loop|4 (lambda (.t|22 .inserted|22 .referenced|22 .rank|22 .escaped?|22 .k|22) (if (symbol? .t|22) (let ((.x|26 (pattern-variable .t|22 .vars|3))) (if .x|26 (if (>= .rank|22 (patternvar-rank .x|26)) (.k|22 .x|26 .inserted|22 (cons .x|26 .referenced|22)) (m-error "Too few ellipses follow pattern variable in template" (patternvar-name .x|26))) (.k|22 .t|22 (cons .t|22 .inserted|22) .referenced|22))) (if (null? .t|22) (.k|22 '() .inserted|22 .referenced|22) (if (pair? .t|22) (if (if (not .escaped?|22) (if (symbol? (let ((.x|32|35 .t|22)) (begin (.check! (pair? .x|32|35) 0 .x|32|35) (car:pair .x|32|35)))) (if (same-denotation? (syntactic-lookup .env|3 (let ((.x|37|40 .t|22)) (begin (.check! (pair? .x|37|40) 0 .x|37|40) (car:pair .x|37|40)))) denotation-of-...) (if (pair? (let ((.x|42|45 .t|22)) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45)))) (null? (let ((.x|48|51 (let ((.x|52|55 .t|22)) (begin (.check! (pair? .x|52|55) 1 .x|52|55) (cdr:pair .x|52|55))))) (begin (.check! (pair? .x|48|51) 1 .x|48|51) (cdr:pair .x|48|51)))) #f) #f) #f) #f) (.loop|4 (let ((.x|57|60 (let ((.x|61|64 .t|22)) (begin (.check! (pair? .x|61|64) 1 .x|61|64) (cdr:pair .x|61|64))))) (begin (.check! (pair? .x|57|60) 0 .x|57|60) (car:pair .x|57|60))) .inserted|22 .referenced|22 .rank|22 #t .k|22) (if (if (not .escaped?|22) (if (pair? (let ((.x|68|71 .t|22)) (begin (.check! (pair? .x|68|71) 1 .x|68|71) (cdr:pair .x|68|71)))) (if (symbol? (let ((.x|74|77 (let ((.x|78|81 .t|22)) (begin (.check! (pair? .x|78|81) 1 .x|78|81) (cdr:pair .x|78|81))))) (begin (.check! (pair? .x|74|77) 0 .x|74|77) (car:pair .x|74|77)))) (same-denotation? (syntactic-lookup .env|3 (let ((.x|84|87 (let ((.x|88|91 .t|22)) (begin (.check! (pair? .x|88|91) 1 .x|88|91) (cdr:pair .x|88|91))))) (begin (.check! (pair? .x|84|87) 0 .x|84|87) (car:pair .x|84|87)))) denotation-of-...) #f) #f) #f) (.loop1|4 .t|22 .inserted|22 .referenced|22 .rank|22 .escaped?|22 .k|22) (.loop|4 (let ((.x|93|96 .t|22)) (begin (.check! (pair? .x|93|96) 0 .x|93|96) (car:pair .x|93|96))) .inserted|22 .referenced|22 .rank|22 .escaped?|22 (lambda (.t1|97 .inserted|97 .referenced|97) (.loop|4 (let ((.x|98|101 .t|22)) (begin (.check! (pair? .x|98|101) 1 .x|98|101) (cdr:pair .x|98|101))) .inserted|97 .referenced|97 .rank|22 .escaped?|22 (lambda (.t2|102 .inserted|102 .referenced|102) (.k|22 (cons .t1|97 .t2|102) .inserted|102 .referenced|102))))))) (if (vector? .t|22) (.loop|4 (vector->list .t|22) .inserted|22 .referenced|22 .rank|22 .escaped?|22 (lambda (.t|104 .inserted|104 .referenced|104) (.k|22 (make-vector 1 .t|104) .inserted|104 .referenced|104))) (.k|22 .t|22 .inserted|22 .referenced|22))))))) (.loop|4 .t|3 '() '() 0 #f (lambda (.t|107 .inserted|107 .referenced|107) (let* ((.t1|108|111 .t|107) (.t2|108|114 (cons .inserted|107 '()))) (let () (cons .t1|108|111 .t2|108|114))))))))) (.m-compile-template|2 .t|1 .vars|1 .env|1))))) 'm-compile-template))
(let () (begin (set! empty-pattern-variable-environment (cons (make-patternvar (string->symbol "") 0) '())) 'empty-pattern-variable-environment))
(let () (begin (set! m-match (lambda (.f|1 .p|1 .env-def|1 .env-use|1) (let ((.m-match|2 0)) (begin (set! .m-match|2 (lambda (.f|3 .p|3 .env-def|3 .env-use|3) (let ((.match1|4 (unspecified)) (.match|4 (unspecified))) (begin (set! .match1|4 (lambda (.f|5 .p|5 .answer|5 .rank|5) (if (not (list? .f|5)) #f (if (null? .f|5) (append (let () (let ((.loop|13|16|19 (unspecified))) (begin (set! .loop|13|16|19 (lambda (.y1|8|9|20 .results|8|12|20) (if (null? .y1|8|9|20) (reverse .results|8|12|20) (begin #t (.loop|13|16|19 (let ((.x|24|27 .y1|8|9|20)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27))) (cons (let ((.var|28 (let ((.x|29|32 .y1|8|9|20)) (begin (.check! (pair? .x|29|32) 0 .x|29|32) (car:pair .x|29|32))))) (cons .var|28 '())) .results|8|12|20)))))) (.loop|13|16|19 (ellipsis-pattern-vars .p|5) '())))) .answer|5) (let* ((.p1|36 (ellipsis-pattern .p|5)) (.answers|39 (let () (let ((.loop|103|106|109 (unspecified))) (begin (set! .loop|103|106|109 (lambda (.y1|98|99|110 .results|98|102|110) (if (null? .y1|98|99|110) (reverse .results|98|102|110) (begin #t (.loop|103|106|109 (let ((.x|114|117 .y1|98|99|110)) (begin (.check! (pair? .x|114|117) 1 .x|114|117) (cdr:pair .x|114|117))) (cons (let ((.f|118 (let ((.x|119|122 .y1|98|99|110)) (begin (.check! (pair? .x|119|122) 0 .x|119|122) (car:pair .x|119|122))))) (.match|4 .f|118 .p1|36 .answer|5 .rank|5)) .results|98|102|110)))))) (.loop|103|106|109 .f|5 '())))))) (let () (if (every1? (lambda (.answer|43) .answer|43) .answers|39) (append (let () (let ((.loop|49|52|55 (unspecified))) (begin (set! .loop|49|52|55 (lambda (.y1|44|45|56 .results|44|48|56) (if (null? .y1|44|45|56) (reverse .results|44|48|56) (begin #t (.loop|49|52|55 (let ((.x|60|63 .y1|44|45|56)) (begin (.check! (pair? .x|60|63) 1 .x|60|63) (cdr:pair .x|60|63))) (cons (let ((.var|64 (let ((.x|94|97 .y1|44|45|56)) (begin (.check! (pair? .x|94|97) 0 .x|94|97) (car:pair .x|94|97))))) (cons .var|64 (let () (let ((.loop|70|73|76 (unspecified))) (begin (set! .loop|70|73|76 (lambda (.y1|65|66|77 .results|65|69|77) (if (null? .y1|65|66|77) (reverse .results|65|69|77) (begin #t (.loop|70|73|76 (let ((.x|81|84 .y1|65|66|77)) (begin (.check! (pair? .x|81|84) 1 .x|81|84) (cdr:pair .x|81|84))) (cons (let* ((.answer|85 (let ((.x|90|93 .y1|65|66|77)) (begin (.check! (pair? .x|90|93) 0 .x|90|93) (car:pair .x|90|93)))) (.x|86|89 (assq .var|64 .answer|85))) (begin (.check! (pair? .x|86|89) 1 .x|86|89) (cdr:pair .x|86|89))) .results|65|69|77)))))) (.loop|70|73|76 .answers|39 '())))))) .results|44|48|56)))))) (.loop|49|52|55 (ellipsis-pattern-vars .p|5) '())))) .answer|5) #f))))))) (set! .match|4 (lambda (.f|123 .p|123 .answer|123 .rank|123) (if (null? .p|123) (if (null? .f|123) .answer|123 #f) (if (pair? .p|123) (if (pair? .f|123) (let ((.answer|132 (.match|4 (let ((.x|143|146 .f|123)) (begin (.check! (pair? .x|143|146) 0 .x|143|146) (car:pair .x|143|146))) (let ((.x|147|150 .p|123)) (begin (.check! (pair? .x|147|150) 0 .x|147|150) (car:pair .x|147|150))) .answer|123 .rank|123))) (if .answer|132 (.match|4 (let ((.x|135|138 .f|123)) (begin (.check! (pair? .x|135|138) 1 .x|135|138) (cdr:pair .x|135|138))) (let ((.x|139|142 .p|123)) (begin (.check! (pair? .x|139|142) 1 .x|139|142) (cdr:pair .x|139|142))) .answer|132 .rank|123) #f)) #f) (if (symbol? .p|123) (if (symbol? .f|123) (if (same-denotation? (syntactic-lookup .env-def|3 .p|123) (syntactic-lookup .env-use|3 .f|123)) .answer|123 #f) #f) (if (patternvar? .p|123) (cons (cons .p|123 .f|123) .answer|123) (if (ellipsis-pattern? .p|123) (.match1|4 .f|123 .p|123 .answer|123 (+ .rank|123 1)) (if (vector? .p|123) (if (vector? .f|123) (.match|4 (vector->list .f|123) (let ((.v|160|163 .p|123) (.i|160|163 0)) (begin (.check! (fixnum? .i|160|163) 40 .v|160|163 .i|160|163) (.check! (vector? .v|160|163) 40 .v|160|163 .i|160|163) (.check! (<:fix:fix .i|160|163 (vector-length:vec .v|160|163)) 40 .v|160|163 .i|160|163) (.check! (>=:fix:fix .i|160|163 0) 40 .v|160|163 .i|160|163) (vector-ref:trusted .v|160|163 .i|160|163))) .answer|123 .rank|123) #f) (if (equal? .f|123 .p|123) .answer|123 #f))))))))) (.match|4 .f|3 .p|3 empty-pattern-variable-environment 0))))) (.m-match|2 .f|1 .p|1 .env-def|1 .env-use|1))))) 'm-match))
(let () (begin (set! m-rewrite (lambda (.t|1 .alist|1) (let ((.m-rewrite|2 0)) (begin (set! .m-rewrite|2 (lambda (.t|3 .alist|3) (let ((.make-columns|4 (unspecified)) (.rewrite1|4 (unspecified)) (.rewrite|4 (unspecified))) (begin (set! .make-columns|4 (lambda (.vars|5 .rows|5 .alist|5) (let ((.loop|6 (unspecified))) (begin (set! .loop|6 (lambda (.rows|7) (if (null? (let ((.x|8|11 .rows|7)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11)))) '() (cons (append (let () (let ((.loop|18|22|25 (unspecified))) (begin (set! .loop|18|22|25 (lambda (.y1|12|14|26 .y1|12|13|26 .results|12|17|26) (if (let ((.temp|28|31 (null? .y1|12|14|26))) (if .temp|28|31 .temp|28|31 (null? .y1|12|13|26))) (reverse .results|12|17|26) (begin #t (.loop|18|22|25 (let ((.x|34|37 .y1|12|14|26)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37))) (let ((.x|38|41 .y1|12|13|26)) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41))) (cons (let ((.var|42 (let ((.x|47|50 .y1|12|14|26)) (begin (.check! (pair? .x|47|50) 0 .x|47|50) (car:pair .x|47|50)))) (.row|42 (let ((.x|51|54 .y1|12|13|26)) (begin (.check! (pair? .x|51|54) 0 .x|51|54) (car:pair .x|51|54))))) (cons .var|42 (let ((.x|43|46 .row|42)) (begin (.check! (pair? .x|43|46) 0 .x|43|46) (car:pair .x|43|46))))) .results|12|17|26)))))) (.loop|18|22|25 .vars|5 .rows|7 '())))) .alist|5) (.loop|6 (let () (let ((.loop|60|63|66 (unspecified))) (begin (set! .loop|60|63|66 (lambda (.y1|55|56|67 .results|55|59|67) (if (null? .y1|55|56|67) (reverse .results|55|59|67) (begin #t (.loop|60|63|66 (let ((.x|71|74 .y1|55|56|67)) (begin (.check! (pair? .x|71|74) 1 .x|71|74) (cdr:pair .x|71|74))) (cons (let ((.x|75|78 (let ((.x|79|82 .y1|55|56|67)) (begin (.check! (pair? .x|79|82) 0 .x|79|82) (car:pair .x|79|82))))) (begin (.check! (pair? .x|75|78) 1 .x|75|78) (cdr:pair .x|75|78))) .results|55|59|67)))))) (.loop|60|63|66 .rows|7 '()))))))))) (if (let ((.temp|83|86 (null? (let ((.x|112|115 .rows|5)) (begin (.check! (pair? .x|112|115) 1 .x|112|115) (cdr:pair .x|112|115)))))) (if .temp|83|86 .temp|83|86 (apply = (let () (let ((.loop|93|96|99 (unspecified))) (begin (set! .loop|93|96|99 (lambda (.y1|88|89|100 .results|88|92|100) (if (null? .y1|88|89|100) (reverse .results|88|92|100) (begin #t (.loop|93|96|99 (let ((.x|104|107 .y1|88|89|100)) (begin (.check! (pair? .x|104|107) 1 .x|104|107) (cdr:pair .x|104|107))) (cons (length (let ((.x|108|111 .y1|88|89|100)) (begin (.check! (pair? .x|108|111) 0 .x|108|111) (car:pair .x|108|111)))) .results|88|92|100)))))) (.loop|93|96|99 .rows|5 '()))))))) (.loop|6 .rows|5) (m-error "Use of macro is not consistent with definition" .vars|5 .rows|5)))))) (set! .rewrite1|4 (lambda (.t|116 .alist|116 .rank|116) (let* ((.t1|119 (ellipsis-template .t|116)) (.vars|122 (ellipsis-template-vars .t|116)) (.rows|125 (let () (let ((.loop|159|162|165 (unspecified))) (begin (set! .loop|159|162|165 (lambda (.y1|154|155|166 .results|154|158|166) (if (null? .y1|154|155|166) (reverse .results|154|158|166) (begin #t (.loop|159|162|165 (let ((.x|170|173 .y1|154|155|166)) (begin (.check! (pair? .x|170|173) 1 .x|170|173) (cdr:pair .x|170|173))) (cons (let* ((.var|174 (let ((.x|179|182 .y1|154|155|166)) (begin (.check! (pair? .x|179|182) 0 .x|179|182) (car:pair .x|179|182)))) (.x|175|178 (assq .var|174 .alist|116))) (begin (.check! (pair? .x|175|178) 1 .x|175|178) (cdr:pair .x|175|178))) .results|154|158|166)))))) (.loop|159|162|165 .vars|122 '())))))) (let () (let () (let ((.loop|134|137|140 (unspecified))) (begin (set! .loop|134|137|140 (lambda (.y1|129|130|141 .results|129|133|141) (if (null? .y1|129|130|141) (reverse .results|129|133|141) (begin #t (.loop|134|137|140 (let ((.x|145|148 .y1|129|130|141)) (begin (.check! (pair? .x|145|148) 1 .x|145|148) (cdr:pair .x|145|148))) (cons (let ((.alist|149 (let ((.x|150|153 .y1|129|130|141)) (begin (.check! (pair? .x|150|153) 0 .x|150|153) (car:pair .x|150|153))))) (.rewrite|4 .t1|119 .alist|149 .rank|116)) .results|129|133|141)))))) (.loop|134|137|140 (.make-columns|4 .vars|122 .rows|125 .alist|116) '())))))))) (set! .rewrite|4 (lambda (.t|183 .alist|183 .rank|183) (if (null? .t|183) '() (if (pair? .t|183) ((if (ellipsis-pattern? (let ((.x|186|189 .t|183)) (begin (.check! (pair? .x|186|189) 0 .x|186|189) (car:pair .x|186|189)))) append cons) (.rewrite|4 (let ((.x|190|193 .t|183)) (begin (.check! (pair? .x|190|193) 0 .x|190|193) (car:pair .x|190|193))) .alist|183 .rank|183) (.rewrite|4 (let ((.x|194|197 .t|183)) (begin (.check! (pair? .x|194|197) 1 .x|194|197) (cdr:pair .x|194|197))) .alist|183 .rank|183)) (if (symbol? .t|183) (let ((.x|199|202 (assq .t|183 .alist|183))) (begin (.check! (pair? .x|199|202) 1 .x|199|202) (cdr:pair .x|199|202))) (if (patternvar? .t|183) (let ((.x|204|207 (assq .t|183 .alist|183))) (begin (.check! (pair? .x|204|207) 1 .x|204|207) (cdr:pair .x|204|207))) (if (ellipsis-template? .t|183) (.rewrite1|4 .t|183 .alist|183 (+ .rank|183 1)) (if (vector? .t|183) (list->vector (.rewrite|4 (let ((.v|210|213 .t|183) (.i|210|213 0)) (begin (.check! (fixnum? .i|210|213) 40 .v|210|213 .i|210|213) (.check! (vector? .v|210|213) 40 .v|210|213 .i|210|213) (.check! (<:fix:fix .i|210|213 (vector-length:vec .v|210|213)) 40 .v|210|213 .i|210|213) (.check! (>=:fix:fix .i|210|213 0) 40 .v|210|213 .i|210|213) (vector-ref:trusted .v|210|213 .i|210|213))) .alist|183 .rank|183)) .t|183)))))))) (.rewrite|4 .t|3 .alist|3 0))))) (.m-rewrite|2 .t|1 .alist|1))))) 'm-rewrite))
(let () (begin (set! m-transcribe0 (lambda (.exp|1 .env-use|1 .k|1 .inline?|1) (let ((.m-transcribe0|2 0)) (begin (set! .m-transcribe0|2 (lambda (.exp|3 .env-use|3 .k|3 .inline?|3) (let* ((.m|6 (syntactic-lookup .env-use|3 (let ((.x|86|89 .exp|3)) (begin (.check! (pair? .x|86|89) 0 .x|86|89) (car:pair .x|86|89))))) (.rules|9 (macro-rules .m|6)) (.env-def|12 (macro-env .m|6)) (.f|15 (let ((.x|82|85 .exp|3)) (begin (.check! (pair? .x|82|85) 1 .x|82|85) (cdr:pair .x|82|85))))) (let () (let ((.loop|19 (unspecified))) (begin (set! .loop|19 (lambda (.rules|20) (if (null? .rules|20) (if .inline?|3 (.k|3 .exp|3 .env-use|3) (m-error "Use of macro does not match definition" .exp|3)) (let* ((.rule|23 (let ((.x|78|81 .rules|20)) (begin (.check! (pair? .x|78|81) 0 .x|78|81) (car:pair .x|78|81)))) (.pattern|26 (let ((.x|74|77 .rule|23)) (begin (.check! (pair? .x|74|77) 0 .x|74|77) (car:pair .x|74|77)))) (.alist|29 (m-match .f|15 .pattern|26 .env-def|12 .env-use|3))) (let () (if .alist|29 (let* ((.template|35 (let ((.x|62|65 (let ((.x|66|69 .rule|23)) (begin (.check! (pair? .x|66|69) 1 .x|66|69) (cdr:pair .x|66|69))))) (begin (.check! (pair? .x|62|65) 0 .x|62|65) (car:pair .x|62|65)))) (.inserted|38 (let ((.x|49|52 (let ((.x|53|56 (let ((.x|57|60 .rule|23)) (begin (.check! (pair? .x|57|60) 1 .x|57|60) (cdr:pair .x|57|60))))) (begin (.check! (pair? .x|53|56) 1 .x|53|56) (cdr:pair .x|53|56))))) (begin (.check! (pair? .x|49|52) 0 .x|49|52) (car:pair .x|49|52)))) (.alist2|41 (rename-vars .inserted|38)) (.newexp|44 (m-rewrite .template|35 (append .alist2|41 .alist|29)))) (let () (.k|3 .newexp|44 (syntactic-alias .env-use|3 .alist2|41 .env-def|12)))) (.loop|19 (let ((.x|70|73 .rules|20)) (begin (.check! (pair? .x|70|73) 1 .x|70|73) (cdr:pair .x|70|73)))))))))) (if (procedure? .rules|9) (m-transcribe-low-level .exp|3 .env-use|3 .k|3 .rules|9 .env-def|12) (.loop|19 .rules|9)))))))) (.m-transcribe0|2 .exp|1 .env-use|1 .k|1 .inline?|1))))) 'm-transcribe0))
(let () (begin (set! m-transcribe (lambda (.exp|1 .env-use|1 .k|1) (let ((.m-transcribe|2 0)) (begin (set! .m-transcribe|2 (lambda (.exp|3 .env-use|3 .k|3) (m-transcribe0 .exp|3 .env-use|3 .k|3 #f))) (.m-transcribe|2 .exp|1 .env-use|1 .k|1))))) 'm-transcribe))
(let () (begin (set! m-transcribe-inline (lambda (.exp|1 .env-use|1 .k|1) (let ((.m-transcribe-inline|2 0)) (begin (set! .m-transcribe-inline|2 (lambda (.exp|3 .env-use|3 .k|3) (m-transcribe0 .exp|3 .env-use|3 .k|3 #t))) (.m-transcribe-inline|2 .exp|1 .env-use|1 .k|1))))) 'm-transcribe-inline))
(let () ($$trace "lowlevel"))
(let () (begin (set! m-transcribe-low-level (lambda (.exp|1 .env-use|1 .k|1 .transformer|1 .env-def|1) (let ((.m-transcribe-low-level|2 0)) (begin (set! .m-transcribe-low-level|2 (lambda (.exp|3 .env-use|3 .k|3 .transformer|3 .env-def|3) (let ((.rename0|6 (make-rename-procedure)) (.renamed|6 '()) (.ok|6 #t)) (let ((.lookup|9 (unspecified))) (begin (set! .lookup|9 (lambda (.sym|10) (let ((.alist|13 .renamed|6)) (let () (let ((.loop|16 (unspecified))) (begin (set! .loop|16 (lambda (.alist|17) (if (null? .alist|17) (syntactic-lookup .env-use|3 .sym|10) (if (eq? .sym|10 (let ((.x|20|23 (let ((.x|24|27 .alist|17)) (begin (.check! (pair? .x|24|27) 0 .x|24|27) (car:pair .x|24|27))))) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23)))) (syntactic-lookup .env-def|3 (let ((.x|28|31 (let ((.x|32|35 .alist|17)) (begin (.check! (pair? .x|32|35) 0 .x|32|35) (car:pair .x|32|35))))) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31)))) (.loop|16 (let ((.x|37|40 .alist|17)) (begin (.check! (pair? .x|37|40) 1 .x|37|40) (cdr:pair .x|37|40)))))))) (.loop|16 .alist|13))))))) (let ((.rename|41 (lambda (.sym|45) (if .ok|6 (let ((.probe|48 (assq .sym|45 .renamed|6))) (if .probe|48 (let ((.x|49|52 .probe|48)) (begin (.check! (pair? .x|49|52) 1 .x|49|52) (cdr:pair .x|49|52))) (let ((.sym2|55 (.rename0|6 .sym|45))) (begin (set! .renamed|6 (cons (cons .sym|45 .sym2|55) .renamed|6)) .sym2|55)))) (m-error "Illegal use of a rename procedure" .sym|45)))) (.compare|41 (lambda (.sym1|56 .sym2|56) (same-denotation? (.lookup|9 .sym1|56) (.lookup|9 .sym2|56))))) (let ((.exp2|44 (.transformer|3 .exp|3 .rename|41 .compare|41))) (begin (set! .ok|6 #f) (.k|3 .exp2|44 (syntactic-alias .env-use|3 .renamed|6 .env-def|3)))))))))) (.m-transcribe-low-level|2 .exp|1 .env-use|1 .k|1 .transformer|1 .env-def|1))))) 'm-transcribe-low-level))
(let () (begin (set! identifier? symbol?) 'identifier?))
(let () (begin (set! identifier->symbol (lambda (.id|1) (let ((.identifier->symbol|2 0)) (begin (set! .identifier->symbol|2 (lambda (.id|3) (m-strip .id|3))) (.identifier->symbol|2 .id|1))))) 'identifier->symbol))
(let () ($$trace "expand"))
(let () (begin (set! define-syntax-scope (let ((.flag|3 'letrec)) (lambda .args|4 (if (null? .args|4) .flag|3 (if (not (null? (let ((.x|7|10 .args|4)) (begin (.check! (pair? .x|7|10) 1 .x|7|10) (cdr:pair .x|7|10))))) (apply m-warn "Too many arguments passed to define-syntax-scope" .args|4) (if (let ((.t0|12|13|16 (let ((.x|42|45 .args|4)) (begin (.check! (pair? .x|42|45) 0 .x|42|45) (car:pair .x|42|45)))) (.t1|12|13|16 '(letrec letrec* let*))) (if (eq? .t0|12|13|16 'letrec) .t1|12|13|16 (let ((.t1|12|13|20 (let ((.x|38|41 .t1|12|13|16)) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41))))) (if (eq? .t0|12|13|16 'letrec*) .t1|12|13|20 (let ((.t1|12|13|24 (let ((.x|34|37 .t1|12|13|20)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37))))) (if (eq? .t0|12|13|16 'let*) .t1|12|13|24 (let ((.t1|12|13|28 (let ((.x|30|33 .t1|12|13|24)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))))) #f))))))) (set! .flag|3 (let ((.x|46|49 .args|4)) (begin (.check! (pair? .x|46|49) 0 .x|46|49) (car:pair .x|46|49)))) (m-warn "Unrecognized argument to define-syntax-scope" (let ((.x|51|54 .args|4)) (begin (.check! (pair? .x|51|54) 0 .x|51|54) (car:pair .x|51|54)))))))))) 'define-syntax-scope))
(let () (begin (set! macro-expand (lambda (.def-or-exp|1) (let ((.macro-expand|2 0)) (begin (set! .macro-expand|2 (lambda (.def-or-exp|3) (call-with-current-continuation (lambda (.k|4) (begin (set! m-quit .k|4) (set! renaming-counter 0) (make-call (make-lambda '() '() '() '() '() '() #f (desugar-definitions .def-or-exp|3 global-syntactic-environment make-toplevel-definition)) '())))))) (.macro-expand|2 .def-or-exp|1))))) 'macro-expand))
(let () (begin (set! desugar-definitions (lambda (.exp|1 .env|1 .make-toplevel-definition|1) (let ((.desugar-definitions|2 0)) (begin (set! .desugar-definitions|2 (lambda (.exp|3 .env|3 .make-toplevel-definition|3) (let () (let ((.redefinition|6 (unspecified)) (.desugar-define|6 (unspecified)) (.define-syntax-loop|6 (unspecified)) (.define-loop|6 (unspecified))) (begin (set! .redefinition|6 (lambda (.id|7) (if (symbol? .id|7) (if (not (identifier-denotation? (syntactic-lookup global-syntactic-environment .id|7))) (if (issue-warnings) (m-warn "Redefining " .id|7) (unspecified)) (unspecified)) (m-error "Malformed variable or keyword" .id|7)))) (set! .desugar-define|6 (lambda (.exp|8 .env|8) (if (null? (let ((.x|10|13 .exp|8)) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13)))) (m-error "Malformed definition" .exp|8) (if (null? (let ((.x|16|19 (let ((.x|20|23 .exp|8)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))))) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19)))) (let ((.id|26 (let ((.x|33|36 (let ((.x|37|40 .exp|8)) (begin (.check! (pair? .x|37|40) 1 .x|37|40) (cdr:pair .x|37|40))))) (begin (.check! (pair? .x|33|36) 0 .x|33|36) (car:pair .x|33|36))))) (begin (if (let ((.temp|27|30 (null? pass1-block-inlines))) (if .temp|27|30 .temp|27|30 (not (memq .id|26 pass1-block-inlines)))) (begin (.redefinition|6 .id|26) (syntactic-bind-globally! .id|26 (make-identifier-denotation .id|26))) (unspecified)) (.make-toplevel-definition|3 .id|26 (make-undefined)))) (if (pair? (let ((.x|43|46 (let ((.x|47|50 .exp|8)) (begin (.check! (pair? .x|47|50) 1 .x|47|50) (cdr:pair .x|47|50))))) (begin (.check! (pair? .x|43|46) 0 .x|43|46) (car:pair .x|43|46)))) (.desugar-define|6 (let* ((.def|53 (let ((.x|343|346 .exp|8)) (begin (.check! (pair? .x|343|346) 0 .x|343|346) (car:pair .x|343|346)))) (.pattern|56 (let ((.x|335|338 (let ((.x|339|342 .exp|8)) (begin (.check! (pair? .x|339|342) 1 .x|339|342) (cdr:pair .x|339|342))))) (begin (.check! (pair? .x|335|338) 0 .x|335|338) (car:pair .x|335|338)))) (.f|59 (let ((.x|330|333 .pattern|56)) (begin (.check! (pair? .x|330|333) 0 .x|330|333) (car:pair .x|330|333)))) (.args|62 (let ((.x|326|329 .pattern|56)) (begin (.check! (pair? .x|326|329) 1 .x|326|329) (cdr:pair .x|326|329)))) (.body|65 (let ((.x|318|321 (let ((.x|322|325 .exp|8)) (begin (.check! (pair? .x|322|325) 1 .x|322|325) (cdr:pair .x|322|325))))) (begin (.check! (pair? .x|318|321) 1 .x|318|321) (cdr:pair .x|318|321))))) (let () (if (if (symbol? (let ((.x|70|73 (let ((.x|75|78 (let ((.x|79|82 .exp|8)) (begin (.check! (pair? .x|79|82) 1 .x|79|82) (cdr:pair .x|79|82))))) (begin (.check! (pair? .x|75|78) 0 .x|75|78) (car:pair .x|75|78))))) (begin (.check! (pair? .x|70|73) 0 .x|70|73) (car:pair .x|70|73)))) (if (benchmark-mode) (list? (let ((.x|86|89 (let ((.x|90|93 .exp|8)) (begin (.check! (pair? .x|90|93) 1 .x|90|93) (cdr:pair .x|90|93))))) (begin (.check! (pair? .x|86|89) 0 .x|86|89) (car:pair .x|86|89)))) #f) #f) (.cons .def|53 (.cons .f|59 (.cons (.cons lambda0 (.cons .args|62 (.cons (.cons (.cons lambda0 (.cons (.cons .f|59 '()) (.cons (.cons set!0 (.cons .f|59 (.cons (.cons lambda0 (.cons .args|62 .body|65)) '()))) (.cons .pattern|56 '())))) '(0)) '()))) '()))) (.cons .def|53 (.cons .f|59 (.cons (.cons lambda0 (.cons .args|62 .body|65)) '())))))) .env|8) (if (> (length .exp|8) 3) (m-error "Malformed definition" .exp|8) (let ((.id|351 (let ((.x|371|374 (let ((.x|375|378 .exp|8)) (begin (.check! (pair? .x|375|378) 1 .x|375|378) (cdr:pair .x|375|378))))) (begin (.check! (pair? .x|371|374) 0 .x|371|374) (car:pair .x|371|374))))) (begin (if (let ((.temp|352|355 (null? pass1-block-inlines))) (if .temp|352|355 .temp|352|355 (not (memq .id|351 pass1-block-inlines)))) (begin (.redefinition|6 .id|351) (syntactic-bind-globally! .id|351 (make-identifier-denotation .id|351))) (unspecified)) (.make-toplevel-definition|3 .id|351 (m-expand (let ((.x|358|361 (let ((.x|362|365 (let ((.x|366|369 .exp|8)) (begin (.check! (pair? .x|366|369) 1 .x|366|369) (cdr:pair .x|366|369))))) (begin (.check! (pair? .x|362|365) 1 .x|362|365) (cdr:pair .x|362|365))))) (begin (.check! (pair? .x|358|361) 0 .x|358|361) (car:pair .x|358|361))) .env|8)))))))))) (set! .define-syntax-loop|6 (lambda (.exp|379 .rest|379 .env|379) (if (if (pair? .exp|379) (if (symbol? (let ((.x|383|386 .exp|379)) (begin (.check! (pair? .x|383|386) 0 .x|383|386) (car:pair .x|383|386)))) (if (eq? (syntactic-lookup .env|379 (let ((.x|388|391 .exp|379)) (begin (.check! (pair? .x|388|391) 0 .x|388|391) (car:pair .x|388|391)))) denotation-of-begin) (pair? (let ((.x|393|396 .exp|379)) (begin (.check! (pair? .x|393|396) 1 .x|393|396) (cdr:pair .x|393|396)))) #f) #f) #f) (.define-syntax-loop|6 (let ((.x|398|401 (let ((.x|402|405 .exp|379)) (begin (.check! (pair? .x|402|405) 1 .x|402|405) (cdr:pair .x|402|405))))) (begin (.check! (pair? .x|398|401) 0 .x|398|401) (car:pair .x|398|401))) (append (let ((.x|407|410 (let ((.x|411|414 .exp|379)) (begin (.check! (pair? .x|411|414) 1 .x|411|414) (cdr:pair .x|411|414))))) (begin (.check! (pair? .x|407|410) 1 .x|407|410) (cdr:pair .x|407|410))) .rest|379) .env|379) (if (if (pair? .exp|379) (if (symbol? (let ((.x|418|421 .exp|379)) (begin (.check! (pair? .x|418|421) 0 .x|418|421) (car:pair .x|418|421)))) (eq? (syntactic-lookup .env|379 (let ((.x|423|426 .exp|379)) (begin (.check! (pair? .x|423|426) 0 .x|423|426) (car:pair .x|423|426)))) denotation-of-define-syntax) #f) #f) (begin (if (pair? (let ((.x|427|430 .exp|379)) (begin (.check! (pair? .x|427|430) 1 .x|427|430) (cdr:pair .x|427|430)))) (.redefinition|6 (let ((.x|432|435 (let ((.x|436|439 .exp|379)) (begin (.check! (pair? .x|436|439) 1 .x|436|439) (cdr:pair .x|436|439))))) (begin (.check! (pair? .x|432|435) 0 .x|432|435) (car:pair .x|432|435)))) (unspecified)) (if (null? .rest|379) (m-define-syntax .exp|379 .env|379) (begin (m-define-syntax .exp|379 .env|379) (.define-syntax-loop|6 (let ((.x|440|443 .rest|379)) (begin (.check! (pair? .x|440|443) 0 .x|440|443) (car:pair .x|440|443))) (let ((.x|444|447 .rest|379)) (begin (.check! (pair? .x|444|447) 1 .x|444|447) (cdr:pair .x|444|447))) .env|379)))) (if (if (pair? .exp|379) (if (symbol? (let ((.x|451|454 .exp|379)) (begin (.check! (pair? .x|451|454) 0 .x|451|454) (car:pair .x|451|454)))) (eq? (syntactic-lookup .env|379 (let ((.x|456|459 .exp|379)) (begin (.check! (pair? .x|456|459) 0 .x|456|459) (car:pair .x|456|459)))) denotation-of-define-inline) #f) #f) (begin (if (pair? (let ((.x|460|463 .exp|379)) (begin (.check! (pair? .x|460|463) 1 .x|460|463) (cdr:pair .x|460|463)))) (.redefinition|6 (let ((.x|465|468 (let ((.x|469|472 .exp|379)) (begin (.check! (pair? .x|469|472) 1 .x|469|472) (cdr:pair .x|469|472))))) (begin (.check! (pair? .x|465|468) 0 .x|465|468) (car:pair .x|465|468)))) (unspecified)) (if (null? .rest|379) (m-define-inline .exp|379 .env|379) (begin (m-define-inline .exp|379 .env|379) (.define-syntax-loop|6 (let ((.x|473|476 .rest|379)) (begin (.check! (pair? .x|473|476) 0 .x|473|476) (car:pair .x|473|476))) (let ((.x|477|480 .rest|379)) (begin (.check! (pair? .x|477|480) 1 .x|477|480) (cdr:pair .x|477|480))) .env|379)))) (if (if (pair? .exp|379) (if (symbol? (let ((.x|484|487 .exp|379)) (begin (.check! (pair? .x|484|487) 0 .x|484|487) (car:pair .x|484|487)))) (macro-denotation? (syntactic-lookup .env|379 (let ((.x|489|492 .exp|379)) (begin (.check! (pair? .x|489|492) 0 .x|489|492) (car:pair .x|489|492))))) #f) #f) (m-transcribe .exp|379 .env|379 (lambda (.exp|493 .env|493) (.define-syntax-loop|6 .exp|493 .rest|379 .env|493))) (if (if (pair? .exp|379) (if (symbol? (let ((.x|497|500 .exp|379)) (begin (.check! (pair? .x|497|500) 0 .x|497|500) (car:pair .x|497|500)))) (eq? (syntactic-lookup .env|379 (let ((.x|502|505 .exp|379)) (begin (.check! (pair? .x|502|505) 0 .x|502|505) (car:pair .x|502|505)))) denotation-of-define) #f) #f) (.define-loop|6 .exp|379 .rest|379 '() .env|379) (if (null? .rest|379) (m-expand .exp|379 .env|379) (make-begin (let () (let ((.loop|513|516|519 (unspecified))) (begin (set! .loop|513|516|519 (lambda (.y1|508|509|520 .results|508|512|520) (if (null? .y1|508|509|520) (reverse .results|508|512|520) (begin #t (.loop|513|516|519 (let ((.x|524|527 .y1|508|509|520)) (begin (.check! (pair? .x|524|527) 1 .x|524|527) (cdr:pair .x|524|527))) (cons (let ((.exp|528 (let ((.x|529|532 .y1|508|509|520)) (begin (.check! (pair? .x|529|532) 0 .x|529|532) (car:pair .x|529|532))))) (m-expand .exp|528 .env|379)) .results|508|512|520)))))) (.loop|513|516|519 (cons .exp|379 .rest|379) '()))))))))))))) (set! .define-loop|6 (lambda (.exp|533 .rest|533 .first|533 .env|533) (if (if (pair? .exp|533) (if (symbol? (let ((.x|537|540 .exp|533)) (begin (.check! (pair? .x|537|540) 0 .x|537|540) (car:pair .x|537|540)))) (if (eq? (syntactic-lookup .env|533 (let ((.x|542|545 .exp|533)) (begin (.check! (pair? .x|542|545) 0 .x|542|545) (car:pair .x|542|545)))) denotation-of-begin) (pair? (let ((.x|547|550 .exp|533)) (begin (.check! (pair? .x|547|550) 1 .x|547|550) (cdr:pair .x|547|550)))) #f) #f) #f) (.define-loop|6 (let ((.x|552|555 (let ((.x|556|559 .exp|533)) (begin (.check! (pair? .x|556|559) 1 .x|556|559) (cdr:pair .x|556|559))))) (begin (.check! (pair? .x|552|555) 0 .x|552|555) (car:pair .x|552|555))) (append (let ((.x|561|564 (let ((.x|565|568 .exp|533)) (begin (.check! (pair? .x|565|568) 1 .x|565|568) (cdr:pair .x|565|568))))) (begin (.check! (pair? .x|561|564) 1 .x|561|564) (cdr:pair .x|561|564))) .rest|533) .first|533 .env|533) (if (if (pair? .exp|533) (if (symbol? (let ((.x|572|575 .exp|533)) (begin (.check! (pair? .x|572|575) 0 .x|572|575) (car:pair .x|572|575)))) (eq? (syntactic-lookup .env|533 (let ((.x|577|580 .exp|533)) (begin (.check! (pair? .x|577|580) 0 .x|577|580) (car:pair .x|577|580)))) denotation-of-define) #f) #f) (let ((.exp|583 (.desugar-define|6 .exp|533 .env|533))) (if (if (null? .first|533) (null? .rest|533) #f) .exp|583 (if (null? .rest|533) (make-begin (reverse (cons .exp|583 .first|533))) (.define-loop|6 (let ((.x|589|592 .rest|533)) (begin (.check! (pair? .x|589|592) 0 .x|589|592) (car:pair .x|589|592))) (let ((.x|593|596 .rest|533)) (begin (.check! (pair? .x|593|596) 1 .x|593|596) (cdr:pair .x|593|596))) (cons .exp|583 .first|533) .env|533)))) (if (if (pair? .exp|533) (if (symbol? (let ((.x|600|603 .exp|533)) (begin (.check! (pair? .x|600|603) 0 .x|600|603) (car:pair .x|600|603)))) (if (let ((.temp|605|608 (eq? (syntactic-lookup .env|533 (let ((.x|614|617 .exp|533)) (begin (.check! (pair? .x|614|617) 0 .x|614|617) (car:pair .x|614|617)))) denotation-of-define-syntax))) (if .temp|605|608 .temp|605|608 (eq? (syntactic-lookup .env|533 (let ((.x|610|613 .exp|533)) (begin (.check! (pair? .x|610|613) 0 .x|610|613) (car:pair .x|610|613)))) denotation-of-define-inline))) (null? .first|533) #f) #f) #f) (.define-syntax-loop|6 .exp|533 .rest|533 .env|533) (if (if (pair? .exp|533) (if (symbol? (let ((.x|622|625 .exp|533)) (begin (.check! (pair? .x|622|625) 0 .x|622|625) (car:pair .x|622|625)))) (macro-denotation? (syntactic-lookup .env|533 (let ((.x|627|630 .exp|533)) (begin (.check! (pair? .x|627|630) 0 .x|627|630) (car:pair .x|627|630))))) #f) #f) (m-transcribe .exp|533 .env|533 (lambda (.exp|631 .env|631) (.define-loop|6 .exp|631 .rest|533 .first|533 .env|631))) (if (if (null? .first|533) (null? .rest|533) #f) (m-expand .exp|533 .env|533) (if (null? .rest|533) (make-begin (reverse (cons (m-expand .exp|533 .env|533) .first|533))) (make-begin (append (reverse .first|533) (let () (let ((.loop|642|645|648 (unspecified))) (begin (set! .loop|642|645|648 (lambda (.y1|637|638|649 .results|637|641|649) (if (null? .y1|637|638|649) (reverse .results|637|641|649) (begin #t (.loop|642|645|648 (let ((.x|653|656 .y1|637|638|649)) (begin (.check! (pair? .x|653|656) 1 .x|653|656) (cdr:pair .x|653|656))) (cons (let ((.exp|657 (let ((.x|658|661 .y1|637|638|649)) (begin (.check! (pair? .x|658|661) 0 .x|658|661) (car:pair .x|658|661))))) (m-expand .exp|657 .env|533)) .results|637|641|649)))))) (.loop|642|645|648 (cons .exp|533 .rest|533) '())))))))))))))) (.define-loop|6 .exp|3 '() '() .env|3)))))) (.desugar-definitions|2 .exp|1 .env|1 .make-toplevel-definition|1))))) 'desugar-definitions))
(let () (begin (set! m-expand (lambda (.exp|1 .env|1) (let ((.m-expand|2 0)) (begin (set! .m-expand|2 (lambda (.exp|3 .env|3) (if (not (pair? .exp|3)) (m-atom .exp|3 .env|3) (if (not (symbol? (let ((.x|6|9 .exp|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9))))) (m-application .exp|3 .env|3) (let* ((.keyword|13 (syntactic-lookup .env|3 (let ((.x|41|44 .exp|3)) (begin (.check! (pair? .x|41|44) 0 .x|41|44) (car:pair .x|41|44))))) (.temp|14|17 (denotation-class .keyword|13))) (if (memv .temp|14|17 '(special)) (if (eq? .keyword|13 denotation-of-quote) (m-quote .exp|3) (if (eq? .keyword|13 denotation-of-lambda) (m-lambda .exp|3 .env|3) (if (eq? .keyword|13 denotation-of-if) (m-if .exp|3 .env|3) (if (eq? .keyword|13 denotation-of-set!) (m-set .exp|3 .env|3) (if (eq? .keyword|13 denotation-of-begin) (m-begin .exp|3 .env|3) (if (eq? .keyword|13 denotation-of-let-syntax) (m-let-syntax .exp|3 .env|3) (if (eq? .keyword|13 denotation-of-letrec-syntax) (m-letrec-syntax .exp|3 .env|3) (if (let ((.temp|27|30 (eq? .keyword|13 denotation-of-define))) (if .temp|27|30 .temp|27|30 (let ((.temp|31|34 (eq? .keyword|13 denotation-of-define-syntax))) (if .temp|31|34 .temp|31|34 (eq? .keyword|13 denotation-of-define-inline))))) (m-error "Definition out of context" .exp|3) (m-bug "Bug detected in m-expand" .exp|3 .env|3))))))))) (if (memv .temp|14|17 '(macro)) (m-macro .exp|3 .env|3) (if (memv .temp|14|17 '(inline)) (m-inline .exp|3 .env|3) (if (memv .temp|14|17 '(identifier)) (m-application .exp|3 .env|3) (m-bug "Bug detected in m-expand" .exp|3 .env|3)))))))))) (.m-expand|2 .exp|1 .env|1))))) 'm-expand))
(let () (begin (set! m-atom (lambda (.exp|1 .env|1) (let ((.m-atom|2 0)) (begin (set! .m-atom|2 (lambda (.exp|3 .env|3) (if (not (symbol? .exp|3)) (begin (if (if (not (boolean? .exp|3)) (if (not (number? .exp|3)) (if (not (char? .exp|3)) (if (not (string? .exp|3)) (if (not (procedure? .exp|3)) (not (eq? .exp|3 (unspecified))) #f) #f) #f) #f) #f) (m-warn "Malformed constant -- should be quoted" .exp|3) (unspecified)) (make-constant .exp|3)) (let* ((.denotation|14 (syntactic-lookup .env|3 .exp|3)) (.temp|15|18 (denotation-class .denotation|14))) (if (memv .temp|15|18 '(special macro)) (begin (m-warn "Syntactic keyword used as a variable" .exp|3) (make-constant #t)) (if (memv .temp|15|18 '(inline)) (make-variable (inline-name .denotation|14)) (if (memv .temp|15|18 '(identifier)) (let ((.var|24 (make-variable (identifier-name .denotation|14))) (.r-entry|24 (identifier-r-entry .denotation|14))) (begin (r-entry.references-set! .r-entry|24 (cons .var|24 (r-entry.references .r-entry|24))) .var|24)) (m-bug "Bug detected by m-atom" .exp|3 .env|3)))))))) (.m-atom|2 .exp|1 .env|1))))) 'm-atom))
(let () (begin (set! m-quote (lambda (.exp|1) (let ((.m-quote|2 0)) (begin (set! .m-quote|2 (lambda (.exp|3) (if (if (pair? (let ((.x|5|8 .exp|3)) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8)))) (null? (let ((.x|11|14 (let ((.x|15|18 .exp|3)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))))) (begin (.check! (pair? .x|11|14) 1 .x|11|14) (cdr:pair .x|11|14)))) #f) (make-constant (m-strip (let ((.x|20|23 (let ((.x|24|27 .exp|3)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27))))) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))))) (m-error "Malformed quoted constant" .exp|3)))) (.m-quote|2 .exp|1))))) 'm-quote))
(let () (begin (set! m-lambda (lambda (.exp|1 .env|1) (let ((.m-lambda|2 0)) (begin (set! .m-lambda|2 (lambda (.exp|3 .env|3) (if (> (safe-length .exp|3) 2) (let* ((.formals|6 (let ((.x|242|245 (let ((.x|246|249 .exp|3)) (begin (.check! (pair? .x|246|249) 1 .x|246|249) (cdr:pair .x|246|249))))) (begin (.check! (pair? .x|242|245) 0 .x|242|245) (car:pair .x|242|245)))) (.alist|9 (rename-vars .formals|6)) (.env|12 (syntactic-rename .env|3 .alist|9)) (.body|15 (let ((.x|233|236 (let ((.x|237|240 .exp|3)) (begin (.check! (pair? .x|237|240) 1 .x|237|240) (cdr:pair .x|237|240))))) (begin (.check! (pair? .x|233|236) 1 .x|233|236) (cdr:pair .x|233|236))))) (let () (begin (let () (let ((.loop|20|22|25 (unspecified))) (begin (set! .loop|20|22|25 (lambda (.alist|26) (if (null? .alist|26) (if #f #f (unspecified)) (begin (begin #t (if (assq (let ((.x|30|33 (let ((.x|34|37 .alist|26)) (begin (.check! (pair? .x|34|37) 0 .x|34|37) (car:pair .x|34|37))))) (begin (.check! (pair? .x|30|33) 0 .x|30|33) (car:pair .x|30|33))) (let ((.x|38|41 .alist|26)) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41)))) (m-error "Malformed parameter list" .formals|6) (unspecified))) (.loop|20|22|25 (let ((.x|42|45 .alist|26)) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45)))))))) (.loop|20|22|25 .alist|9)))) (if (if (not (list? .formals|6)) (> (length .alist|9) @maxargs-with-rest-arg@) #f) (let ((.temp|50 (let ((.x|195|198 (rename-vars '(temp)))) (begin (.check! (pair? .x|195|198) 0 .x|195|198) (car:pair .x|195|198))))) (.m-lambda|2 (.cons lambda0 (.cons .temp|50 (.cons (.cons (.cons lambda0 (.cons (let () (let ((.loop|125|128|131 (unspecified))) (begin (set! .loop|125|128|131 (lambda (.y1|120|121|132 .results|120|124|132) (if (null? .y1|120|121|132) (reverse .results|120|124|132) (begin #t (.loop|125|128|131 (let ((.x|136|139 .y1|120|121|132)) (begin (.check! (pair? .x|136|139) 1 .x|136|139) (cdr:pair .x|136|139))) (cons (let ((.x|140|143 (let ((.x|144|147 .y1|120|121|132)) (begin (.check! (pair? .x|144|147) 0 .x|144|147) (car:pair .x|144|147))))) (begin (.check! (pair? .x|140|143) 0 .x|140|143) (car:pair .x|140|143))) .results|120|124|132)))))) (.loop|125|128|131 .alist|9 '())))) (let ((.x|149|152 (let ((.x|153|156 .exp|3)) (begin (.check! (pair? .x|153|156) 1 .x|153|156) (cdr:pair .x|153|156))))) (begin (.check! (pair? .x|149|152) 1 .x|149|152) (cdr:pair .x|149|152))))) (let () (let ((.loop|157|161|164 (unspecified))) (begin (set! .loop|157|161|164 (lambda (.actuals|165 .path|165 .formals|165) (if (symbol? .formals|165) (append (reverse .actuals|165) (cons .path|165 '())) (begin #t (.loop|157|161|164 (cons (let* ((.t1|169|172 name:car) (.t2|169|175 (cons .path|165 '()))) (let () (cons .t1|169|172 .t2|169|175))) .actuals|165) (let* ((.t1|180|183 name:cdr) (.t2|180|186 (cons .path|165 '()))) (let () (cons .t1|180|183 .t2|180|186))) (let ((.x|191|194 .formals|165)) (begin (.check! (pair? .x|191|194) 1 .x|191|194) (cdr:pair .x|191|194)))))))) (.loop|157|161|164 '() .temp|50 .formals|6))))) '()))) .env|12)) (make-lambda (rename-formals .formals|6 .alist|9) '() (let () (let ((.loop|204|207|210 (unspecified))) (begin (set! .loop|204|207|210 (lambda (.y1|199|200|211 .results|199|203|211) (if (null? .y1|199|200|211) (reverse .results|199|203|211) (begin #t (.loop|204|207|210 (let ((.x|215|218 .y1|199|200|211)) (begin (.check! (pair? .x|215|218) 1 .x|215|218) (cdr:pair .x|215|218))) (cons (let* ((.entry|219 (let ((.x|228|231 .y1|199|200|211)) (begin (.check! (pair? .x|228|231) 0 .x|228|231) (car:pair .x|228|231)))) (.x|220|223 (syntactic-lookup .env|12 (let ((.x|224|227 .entry|219)) (begin (.check! (pair? .x|224|227) 1 .x|224|227) (cdr:pair .x|224|227)))))) (begin (.check! (pair? .x|220|223) 1 .x|220|223) (cdr:pair .x|220|223))) .results|199|203|211)))))) (.loop|204|207|210 .alist|9 '())))) '() '() '() (make-doc #f (if (list? .formals|6) (length .alist|9) (exact->inexact (- (length .alist|9) 1))) (if (include-variable-names) .formals|6 #f) (if (include-source-code) .exp|3 #f) source-file-name source-file-position) (m-body .body|15 .env|12)))))) (m-error "Malformed lambda expression" .exp|3)))) (.m-lambda|2 .exp|1 .env|1))))) 'm-lambda))
(let () (begin (set! m-body (lambda (.body|1 .env|1) (let ((.m-body|2 0)) (begin (set! .m-body|2 (lambda (.body|3 .env|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.body|5 .env|5 .defs|5) (begin (if (null? .body|5) (m-error "Empty body") (unspecified)) (let ((.exp|8 (let ((.x|50|53 .body|5)) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53))))) (if (if (pair? .exp|8) (symbol? (let ((.x|11|14 .exp|8)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14)))) #f) (let* ((.denotation|17 (syntactic-lookup .env|5 (let ((.x|46|49 .exp|8)) (begin (.check! (pair? .x|46|49) 0 .x|46|49) (car:pair .x|46|49))))) (.temp|18|21 (denotation-class .denotation|17))) (if (memv .temp|18|21 '(special)) (if (eq? .denotation|17 denotation-of-begin) (.loop|4 (append (let ((.x|24|27 .exp|8)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27))) (let ((.x|28|31 .body|5)) (begin (.check! (pair? .x|28|31) 1 .x|28|31) (cdr:pair .x|28|31)))) .env|5 .defs|5) (if (eq? .denotation|17 denotation-of-define) (.loop|4 (let ((.x|33|36 .body|5)) (begin (.check! (pair? .x|33|36) 1 .x|33|36) (cdr:pair .x|33|36))) .env|5 (cons .exp|8 .defs|5)) (finalize-body .body|5 .env|5 .defs|5))) (if (memv .temp|18|21 '(macro)) (m-transcribe .exp|8 .env|5 (lambda (.exp|39 .env|39) (.loop|4 (cons .exp|39 (let ((.x|40|43 .body|5)) (begin (.check! (pair? .x|40|43) 1 .x|40|43) (cdr:pair .x|40|43)))) .env|39 .defs|5))) (if (memv .temp|18|21 '(inline identifier)) (finalize-body .body|5 .env|5 .defs|5) (m-bug "Bug detected in m-body" .body|5 .env|5))))) (finalize-body .body|5 .env|5 .defs|5)))))) (.loop|4 .body|3 .env|3 '()))))) (.m-body|2 .body|1 .env|1))))) 'm-body))
(let () (begin (set! finalize-body (lambda (.body|1 .env|1 .defs|1) (let ((.finalize-body|2 0)) (begin (set! .finalize-body|2 (lambda (.body|3 .env|3 .defs|3) (if (null? .defs|3) (let ((.body|6 (let () (let ((.loop|20|23|26 (unspecified))) (begin (set! .loop|20|23|26 (lambda (.y1|15|16|27 .results|15|19|27) (if (null? .y1|15|16|27) (reverse .results|15|19|27) (begin #t (.loop|20|23|26 (let ((.x|31|34 .y1|15|16|27)) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34))) (cons (let ((.exp|35 (let ((.x|36|39 .y1|15|16|27)) (begin (.check! (pair? .x|36|39) 0 .x|36|39) (car:pair .x|36|39))))) (m-expand .exp|35 .env|3)) .results|15|19|27)))))) (.loop|20|23|26 .body|3 '())))))) (if (null? (let ((.x|7|10 .body|6)) (begin (.check! (pair? .x|7|10) 1 .x|7|10) (cdr:pair .x|7|10)))) (let ((.x|11|14 .body|6)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14))) (make-begin .body|6))) (let () (let ((.expand-letrec|43 (unspecified)) (.desugar-definition|43 (unspecified)) (.sort-defs|43 (unspecified))) (begin (set! .expand-letrec|43 (lambda (.bindings|44 .body|44) (make-call (m-expand (.cons lambda0 (.cons (let () (let ((.loop|85|88|91 (unspecified))) (begin (set! .loop|85|88|91 (lambda (.y1|80|81|92 .results|80|84|92) (if (null? .y1|80|81|92) (reverse .results|80|84|92) (begin #t (.loop|85|88|91 (let ((.x|96|99 .y1|80|81|92)) (begin (.check! (pair? .x|96|99) 1 .x|96|99) (cdr:pair .x|96|99))) (cons (let ((.x|100|103 (let ((.x|104|107 .y1|80|81|92)) (begin (.check! (pair? .x|104|107) 0 .x|104|107) (car:pair .x|104|107))))) (begin (.check! (pair? .x|100|103) 0 .x|100|103) (car:pair .x|100|103))) .results|80|84|92)))))) (.loop|85|88|91 .bindings|44 '())))) (append (let () (let ((.loop|113|116|119 (unspecified))) (begin (set! .loop|113|116|119 (lambda (.y1|108|109|120 .results|108|112|120) (if (null? .y1|108|109|120) (reverse .results|108|112|120) (begin #t (.loop|113|116|119 (let ((.x|124|127 .y1|108|109|120)) (begin (.check! (pair? .x|124|127) 1 .x|124|127) (cdr:pair .x|124|127))) (cons (let ((.binding|128 (let ((.x|174|177 .y1|108|109|120)) (begin (.check! (pair? .x|174|177) 0 .x|174|177) (car:pair .x|174|177))))) (.cons set!0 (.cons (let ((.x|161|164 .binding|128)) (begin (.check! (pair? .x|161|164) 0 .x|161|164) (car:pair .x|161|164))) (.cons (let ((.x|166|169 (let ((.x|170|173 .binding|128)) (begin (.check! (pair? .x|170|173) 1 .x|170|173) (cdr:pair .x|170|173))))) (begin (.check! (pair? .x|166|169) 0 .x|166|169) (car:pair .x|166|169))) '())))) .results|108|112|120)))))) (.loop|113|116|119 .bindings|44 '())))) .body|44))) .env|3) (let () (let ((.loop|183|186|189 (unspecified))) (begin (set! .loop|183|186|189 (lambda (.y1|178|179|190 .results|178|182|190) (if (null? .y1|178|179|190) (reverse .results|178|182|190) (begin #t (.loop|183|186|189 (let ((.x|194|197 .y1|178|179|190)) (begin (.check! (pair? .x|194|197) 1 .x|194|197) (cdr:pair .x|194|197))) (cons (let ((.binding|198 (let ((.x|199|202 .y1|178|179|190)) (begin (.check! (pair? .x|199|202) 0 .x|199|202) (car:pair .x|199|202))))) (make-unspecified)) .results|178|182|190)))))) (.loop|183|186|189 .bindings|44 '()))))))) (set! .desugar-definition|43 (lambda (.def|203) (if (> (safe-length .def|203) 2) (if (pair? (let ((.x|206|209 (let ((.x|210|213 .def|203)) (begin (.check! (pair? .x|210|213) 1 .x|210|213) (cdr:pair .x|210|213))))) (begin (.check! (pair? .x|206|209) 0 .x|206|209) (car:pair .x|206|209)))) (.desugar-definition|43 (.cons (let ((.x|269|272 .def|203)) (begin (.check! (pair? .x|269|272) 0 .x|269|272) (car:pair .x|269|272))) (.cons (let ((.x|273|276 (let ((.x|278|281 (let ((.x|282|285 .def|203)) (begin (.check! (pair? .x|282|285) 1 .x|282|285) (cdr:pair .x|282|285))))) (begin (.check! (pair? .x|278|281) 0 .x|278|281) (car:pair .x|278|281))))) (begin (.check! (pair? .x|273|276) 0 .x|273|276) (car:pair .x|273|276))) (.cons (.cons lambda0 (.cons (let ((.x|286|289 (let ((.x|291|294 (let ((.x|295|298 .def|203)) (begin (.check! (pair? .x|295|298) 1 .x|295|298) (cdr:pair .x|295|298))))) (begin (.check! (pair? .x|291|294) 0 .x|291|294) (car:pair .x|291|294))))) (begin (.check! (pair? .x|286|289) 1 .x|286|289) (cdr:pair .x|286|289))) (let ((.x|300|303 (let ((.x|304|307 .def|203)) (begin (.check! (pair? .x|304|307) 1 .x|304|307) (cdr:pair .x|304|307))))) (begin (.check! (pair? .x|300|303) 1 .x|300|303) (cdr:pair .x|300|303))))) '())))) (if (if (= (length .def|203) 3) (symbol? (let ((.x|312|315 (let ((.x|316|319 .def|203)) (begin (.check! (pair? .x|316|319) 1 .x|316|319) (cdr:pair .x|316|319))))) (begin (.check! (pair? .x|312|315) 0 .x|312|315) (car:pair .x|312|315)))) #f) (let ((.x|320|323 .def|203)) (begin (.check! (pair? .x|320|323) 1 .x|320|323) (cdr:pair .x|320|323))) (m-error "Malformed definition" .def|203))) (m-error "Malformed definition" .def|203)))) (set! .sort-defs|43 (lambda (.defs|325) (let* ((.augmented|328 (let () (let ((.loop|382|385|388 (unspecified))) (begin (set! .loop|382|385|388 (lambda (.y1|377|378|389 .results|377|381|389) (if (null? .y1|377|378|389) (reverse .results|377|381|389) (begin #t (.loop|382|385|388 (let ((.x|393|396 .y1|377|378|389)) (begin (.check! (pair? .x|393|396) 1 .x|393|396) (cdr:pair .x|393|396))) (cons (let* ((.def|397 (let ((.x|420|423 .y1|377|378|389)) (begin (.check! (pair? .x|420|423) 0 .x|420|423) (car:pair .x|420|423)))) (.rhs|400 (let ((.x|412|415 (let ((.x|416|419 .def|397)) (begin (.check! (pair? .x|416|419) 1 .x|416|419) (cdr:pair .x|416|419))))) (begin (.check! (pair? .x|412|415) 0 .x|412|415) (car:pair .x|412|415))))) (if (not (pair? .rhs|400)) (cons 'trivial .def|397) (let ((.denotation|403 (syntactic-lookup .env|3 (let ((.x|407|410 .rhs|400)) (begin (.check! (pair? .x|407|410) 0 .x|407|410) (car:pair .x|407|410)))))) (if (eq? .denotation|403 denotation-of-lambda) (cons 'procedure .def|397) (if (eq? .denotation|403 denotation-of-quote) (cons 'trivial .def|397) (cons 'miscellaneous .def|397)))))) .results|377|381|389)))))) (.loop|382|385|388 .defs|325 '()))))) (.sorted|331 (twobit-sort (lambda (.x|363 .y|363) (let ((.temp|364|367 (eq? (let ((.x|373|376 .x|363)) (begin (.check! (pair? .x|373|376) 0 .x|373|376) (car:pair .x|373|376))) 'procedure))) (if .temp|364|367 .temp|364|367 (eq? (let ((.x|369|372 .y|363)) (begin (.check! (pair? .x|369|372) 0 .x|369|372) (car:pair .x|369|372))) 'miscellaneous)))) .augmented|328))) (let () (let () (let ((.loop|340|343|346 (unspecified))) (begin (set! .loop|340|343|346 (lambda (.y1|335|336|347 .results|335|339|347) (if (null? .y1|335|336|347) (reverse .results|335|339|347) (begin #t (.loop|340|343|346 (let ((.x|351|354 .y1|335|336|347)) (begin (.check! (pair? .x|351|354) 1 .x|351|354) (cdr:pair .x|351|354))) (cons (let ((.x|355|358 (let ((.x|359|362 .y1|335|336|347)) (begin (.check! (pair? .x|359|362) 0 .x|359|362) (car:pair .x|359|362))))) (begin (.check! (pair? .x|355|358) 1 .x|355|358) (cdr:pair .x|355|358))) .results|335|339|347)))))) (.loop|340|343|346 .sorted|331 '())))))))) (.expand-letrec|43 (.sort-defs|43 (let () (let ((.loop|429|432|435 (unspecified))) (begin (set! .loop|429|432|435 (lambda (.y1|424|425|436 .results|424|428|436) (if (null? .y1|424|425|436) (reverse .results|424|428|436) (begin #t (.loop|429|432|435 (let ((.x|440|443 .y1|424|425|436)) (begin (.check! (pair? .x|440|443) 1 .x|440|443) (cdr:pair .x|440|443))) (cons (.desugar-definition|43 (let ((.x|444|447 .y1|424|425|436)) (begin (.check! (pair? .x|444|447) 0 .x|444|447) (car:pair .x|444|447)))) .results|424|428|436)))))) (.loop|429|432|435 (reverse .defs|3) '()))))) .body|3))))))) (.finalize-body|2 .body|1 .env|1 .defs|1))))) 'finalize-body))
(let () (begin (set! m-if (lambda (.exp|1 .env|1) (let ((.m-if|2 0)) (begin (set! .m-if|2 (lambda (.exp|3 .env|3) (let ((.n|6 (safe-length .exp|3))) (if (let ((.temp|7|10 (= .n|6 3))) (if .temp|7|10 .temp|7|10 (= .n|6 4))) (make-conditional (m-expand (let ((.x|13|16 (let ((.x|17|20 .exp|3)) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 0 .x|13|16) (car:pair .x|13|16))) .env|3) (m-expand (let ((.x|22|25 (let ((.x|26|29 (let ((.x|30|33 .exp|3)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))))) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 0 .x|22|25) (car:pair .x|22|25))) .env|3) (if (= .n|6 3) (make-unspecified) (m-expand (let ((.x|35|38 (let ((.x|39|42 (let ((.x|43|46 (let ((.x|47|50 .exp|3)) (begin (.check! (pair? .x|47|50) 1 .x|47|50) (cdr:pair .x|47|50))))) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46))))) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 0 .x|35|38) (car:pair .x|35|38))) .env|3))) (m-error "Malformed if expression" .exp|3))))) (.m-if|2 .exp|1 .env|1))))) 'm-if))
(let () (begin (set! m-set (lambda (.exp|1 .env|1) (let ((.m-set|2 0)) (begin (set! .m-set|2 (lambda (.exp|3 .env|3) (if (= (safe-length .exp|3) 3) (let ((.lhs|6 (m-expand (let ((.x|28|31 (let ((.x|32|35 .exp|3)) (begin (.check! (pair? .x|32|35) 1 .x|32|35) (cdr:pair .x|32|35))))) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31))) .env|3)) (.rhs|6 (m-expand (let ((.x|37|40 (let ((.x|41|44 (let ((.x|45|48 .exp|3)) (begin (.check! (pair? .x|45|48) 1 .x|45|48) (cdr:pair .x|45|48))))) (begin (.check! (pair? .x|41|44) 1 .x|41|44) (cdr:pair .x|41|44))))) (begin (.check! (pair? .x|37|40) 0 .x|37|40) (car:pair .x|37|40))) .env|3))) (if (variable? .lhs|6) (let* ((.x|9 (variable.name .lhs|6)) (.assignment|12 (make-assignment .x|9 .rhs|6)) (.denotation|15 (syntactic-lookup .env|3 .x|9))) (let () (begin (if (identifier-denotation? .denotation|15) (let ((.r-entry|21 (identifier-r-entry .denotation|15))) (begin (r-entry.references-set! .r-entry|21 (remq .lhs|6 (r-entry.references .r-entry|21))) (r-entry.assignments-set! .r-entry|21 (cons .assignment|12 (r-entry.assignments .r-entry|21))))) (unspecified)) (if (if (lambda? .rhs|6) (include-procedure-names) #f) (let ((.doc|26 (lambda.doc .rhs|6))) (doc.name-set! .doc|26 .x|9)) (unspecified)) (if pass1-block-compiling? (set! pass1-block-assignments (cons .x|9 pass1-block-assignments)) (unspecified)) .assignment|12))) (m-error "Malformed assignment" .exp|3))) (m-error "Malformed assignment" .exp|3)))) (.m-set|2 .exp|1 .env|1))))) 'm-set))
(let () (begin (set! m-begin (lambda (.exp|1 .env|1) (let ((.m-begin|2 0)) (begin (set! .m-begin|2 (lambda (.exp|3 .env|3) (if (> (safe-length .exp|3) 1) (make-begin (let () (let ((.loop|10|13|16 (unspecified))) (begin (set! .loop|10|13|16 (lambda (.y1|5|6|17 .results|5|9|17) (if (null? .y1|5|6|17) (reverse .results|5|9|17) (begin #t (.loop|10|13|16 (let ((.x|21|24 .y1|5|6|17)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))) (cons (let ((.exp|25 (let ((.x|26|29 .y1|5|6|17)) (begin (.check! (pair? .x|26|29) 0 .x|26|29) (car:pair .x|26|29))))) (m-expand .exp|25 .env|3)) .results|5|9|17)))))) (.loop|10|13|16 (let ((.x|30|33 .exp|3)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))) '()))))) (if (= (safe-length .exp|3) 1) (begin (m-warn "Non-standard begin expression" .exp|3) (make-unspecified)) (m-error "Malformed begin expression" .exp|3))))) (.m-begin|2 .exp|1 .env|1))))) 'm-begin))
(let () (begin (set! m-application (lambda (.exp|1 .env|1) (let ((.m-application|2 0)) (begin (set! .m-application|2 (lambda (.exp|3 .env|3) (if (> (safe-length .exp|3) 0) (let* ((.proc|6 (m-expand (let ((.x|129|132 .exp|3)) (begin (.check! (pair? .x|129|132) 0 .x|129|132) (car:pair .x|129|132))) .env|3)) (.args|9 (let () (let ((.loop|105|108|111 (unspecified))) (begin (set! .loop|105|108|111 (lambda (.y1|100|101|112 .results|100|104|112) (if (null? .y1|100|101|112) (reverse .results|100|104|112) (begin #t (.loop|105|108|111 (let ((.x|116|119 .y1|100|101|112)) (begin (.check! (pair? .x|116|119) 1 .x|116|119) (cdr:pair .x|116|119))) (cons (let ((.exp|120 (let ((.x|121|124 .y1|100|101|112)) (begin (.check! (pair? .x|121|124) 0 .x|121|124) (car:pair .x|121|124))))) (m-expand .exp|120 .env|3)) .results|100|104|112)))))) (.loop|105|108|111 (let ((.x|125|128 .exp|3)) (begin (.check! (pair? .x|125|128) 1 .x|125|128) (cdr:pair .x|125|128))) '()))))) (.call|12 (make-call .proc|6 .args|9))) (let () (if (variable? .proc|6) (let* ((.procname|18 (variable.name .proc|6)) (.entry|21 (if (not (null? .args|9)) (if (constant? (let ((.x|57|60 .args|9)) (begin (.check! (pair? .x|57|60) 0 .x|57|60) (car:pair .x|57|60)))) (if (integrate-usual-procedures) (if (every1? constant? .args|9) (let ((.entry|66 (constant-folding-entry .procname|18))) (if .entry|66 (let ((.predicates|71 (constant-folding-predicates .entry|66))) (if (= (length .args|9) (length .predicates|71)) (let ((.args|76 .args|9) (.predicates|76 .predicates|71)) (let () (let ((.loop|79 (unspecified))) (begin (set! .loop|79 (lambda (.args|80 .predicates|80) (if (null? .args|80) .entry|66 (if ((let ((.x|83|86 .predicates|80)) (begin (.check! (pair? .x|83|86) 0 .x|83|86) (car:pair .x|83|86))) (constant.value (let ((.x|87|90 .args|80)) (begin (.check! (pair? .x|87|90) 0 .x|87|90) (car:pair .x|87|90))))) (.loop|79 (let ((.x|91|94 .args|80)) (begin (.check! (pair? .x|91|94) 1 .x|91|94) (cdr:pair .x|91|94))) (let ((.x|95|98 .predicates|80)) (begin (.check! (pair? .x|95|98) 1 .x|95|98) (cdr:pair .x|95|98)))) #f)))) (.loop|79 .args|76 .predicates|76))))) #f)) #f)) #f) #f) #f) #f))) (let () (if .entry|21 (make-constant (apply (constant-folding-folder .entry|21) (let () (let ((.loop|30|33|36 (unspecified))) (begin (set! .loop|30|33|36 (lambda (.y1|25|26|37 .results|25|29|37) (if (null? .y1|25|26|37) (reverse .results|25|29|37) (begin #t (.loop|30|33|36 (let ((.x|41|44 .y1|25|26|37)) (begin (.check! (pair? .x|41|44) 1 .x|41|44) (cdr:pair .x|41|44))) (cons (constant.value (let ((.x|45|48 .y1|25|26|37)) (begin (.check! (pair? .x|45|48) 0 .x|45|48) (car:pair .x|45|48)))) .results|25|29|37)))))) (.loop|30|33|36 .args|9 '())))))) (let ((.denotation|51 (syntactic-lookup .env|3 .procname|18))) (begin (if (identifier-denotation? .denotation|51) (let ((.r-entry|54 (identifier-r-entry .denotation|51))) (r-entry.calls-set! .r-entry|54 (cons .call|12 (r-entry.calls .r-entry|54)))) (unspecified)) .call|12))))) .call|12))) (m-error "Malformed application" .exp|3)))) (.m-application|2 .exp|1 .env|1))))) 'm-application))
(let () (begin (set! m-define-inline (lambda (.exp|1 .env|1) (let ((.m-define-inline|2 0)) (begin (set! .m-define-inline|2 (lambda (.exp|3 .env|3) (if (if (= (safe-length .exp|3) 3) (symbol? (let ((.x|8|11 (let ((.x|12|15 .exp|3)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))))) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11)))) #f) (let ((.name|18 (let ((.x|36|39 (let ((.x|40|43 .exp|3)) (begin (.check! (pair? .x|40|43) 1 .x|40|43) (cdr:pair .x|40|43))))) (begin (.check! (pair? .x|36|39) 0 .x|36|39) (car:pair .x|36|39))))) (begin (m-define-syntax1 .name|18 (let ((.x|20|23 (let ((.x|24|27 (let ((.x|28|31 .exp|3)) (begin (.check! (pair? .x|28|31) 1 .x|28|31) (cdr:pair .x|28|31))))) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27))))) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))) .env|3 (define-syntax-scope)) (let ((.denotation|34 (syntactic-lookup global-syntactic-environment .name|18))) (syntactic-bind-globally! .name|18 (make-inline-denotation .name|18 (macro-rules .denotation|34) (macro-env .denotation|34)))) (make-constant .name|18))) (m-error "Malformed define-inline" .exp|3)))) (.m-define-inline|2 .exp|1 .env|1))))) 'm-define-inline))
(let () (begin (set! m-define-syntax (lambda (.exp|1 .env|1) (let ((.m-define-syntax|2 0)) (begin (set! .m-define-syntax|2 (lambda (.exp|3 .env|3) (if (if (= (safe-length .exp|3) 3) (symbol? (let ((.x|8|11 (let ((.x|12|15 .exp|3)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))))) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11)))) #f) (m-define-syntax1 (let ((.x|17|20 (let ((.x|21|24 .exp|3)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 0 .x|17|20) (car:pair .x|17|20))) (let ((.x|26|29 (let ((.x|30|33 (let ((.x|34|37 .exp|3)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37))))) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))))) (begin (.check! (pair? .x|26|29) 0 .x|26|29) (car:pair .x|26|29))) .env|3 (define-syntax-scope)) (if (if (= (safe-length .exp|3) 4) (if (symbol? (let ((.x|42|45 (let ((.x|46|49 .exp|3)) (begin (.check! (pair? .x|46|49) 1 .x|46|49) (cdr:pair .x|46|49))))) (begin (.check! (pair? .x|42|45) 0 .x|42|45) (car:pair .x|42|45)))) (let ((.t0|51|52|55 (let ((.x|82|85 (let ((.x|86|89 (let ((.x|90|93 .exp|3)) (begin (.check! (pair? .x|90|93) 1 .x|90|93) (cdr:pair .x|90|93))))) (begin (.check! (pair? .x|86|89) 1 .x|86|89) (cdr:pair .x|86|89))))) (begin (.check! (pair? .x|82|85) 0 .x|82|85) (car:pair .x|82|85)))) (.t1|51|52|55 '(letrec letrec* let*))) (if (eq? .t0|51|52|55 'letrec) .t1|51|52|55 (let ((.t1|51|52|59 (let ((.x|77|80 .t1|51|52|55)) (begin (.check! (pair? .x|77|80) 1 .x|77|80) (cdr:pair .x|77|80))))) (if (eq? .t0|51|52|55 'letrec*) .t1|51|52|59 (let ((.t1|51|52|63 (let ((.x|73|76 .t1|51|52|59)) (begin (.check! (pair? .x|73|76) 1 .x|73|76) (cdr:pair .x|73|76))))) (if (eq? .t0|51|52|55 'let*) .t1|51|52|63 (let ((.t1|51|52|67 (let ((.x|69|72 .t1|51|52|63)) (begin (.check! (pair? .x|69|72) 1 .x|69|72) (cdr:pair .x|69|72))))) #f))))))) #f) #f) (m-define-syntax1 (let ((.x|95|98 (let ((.x|99|102 .exp|3)) (begin (.check! (pair? .x|99|102) 1 .x|99|102) (cdr:pair .x|99|102))))) (begin (.check! (pair? .x|95|98) 0 .x|95|98) (car:pair .x|95|98))) (let ((.x|104|107 (let ((.x|108|111 (let ((.x|112|115 (let ((.x|116|119 .exp|3)) (begin (.check! (pair? .x|116|119) 1 .x|116|119) (cdr:pair .x|116|119))))) (begin (.check! (pair? .x|112|115) 1 .x|112|115) (cdr:pair .x|112|115))))) (begin (.check! (pair? .x|108|111) 1 .x|108|111) (cdr:pair .x|108|111))))) (begin (.check! (pair? .x|104|107) 0 .x|104|107) (car:pair .x|104|107))) .env|3 (let ((.x|121|124 (let ((.x|125|128 (let ((.x|129|132 .exp|3)) (begin (.check! (pair? .x|129|132) 1 .x|129|132) (cdr:pair .x|129|132))))) (begin (.check! (pair? .x|125|128) 1 .x|125|128) (cdr:pair .x|125|128))))) (begin (.check! (pair? .x|121|124) 0 .x|121|124) (car:pair .x|121|124)))) (m-error "Malformed define-syntax" .exp|3))))) (.m-define-syntax|2 .exp|1 .env|1))))) 'm-define-syntax))
(let () (begin (set! m-define-syntax1 (lambda (.keyword|1 .spec|1 .env|1 .scope|1) (let ((.m-define-syntax1|2 0)) (begin (set! .m-define-syntax1|2 (lambda (.keyword|3 .spec|3 .env|3 .scope|3) (begin (if (if (pair? .spec|3) (symbol? (let ((.x|6|9 .spec|3)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9)))) #f) (let* ((.transformer-keyword|12 (let ((.x|39|42 .spec|3)) (begin (.check! (pair? .x|39|42) 0 .x|39|42) (car:pair .x|39|42)))) (.denotation|15 (syntactic-lookup .env|3 .transformer-keyword|12))) (let () (if (eq? .denotation|15 denotation-of-syntax-rules) (let ((.temp|20|23 .scope|3)) (if (memv .temp|20|23 '(letrec)) (m-define-syntax-letrec .keyword|3 .spec|3 .env|3) (if (memv .temp|20|23 '(letrec*)) (m-define-syntax-letrec* .keyword|3 .spec|3 .env|3) (if (memv .temp|20|23 '(let*)) (m-define-syntax-let* .keyword|3 .spec|3 .env|3) (m-bug "Weird scope" .scope|3))))) (if (same-denotation? .denotation|15 denotation-of-transformer) (syntactic-bind-globally! .keyword|3 (make-macro-denotation (eval (let ((.x|30|33 (let ((.x|34|37 .spec|3)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37))))) (begin (.check! (pair? .x|30|33) 0 .x|30|33) (car:pair .x|30|33)))) .env|3)) (m-error "Malformed syntax transformer" .spec|3))))) (m-error "Malformed syntax transformer" .spec|3)) (make-constant .keyword|3)))) (.m-define-syntax1|2 .keyword|1 .spec|1 .env|1 .scope|1))))) 'm-define-syntax1))
(let () (begin (set! m-define-syntax-letrec (lambda (.keyword|1 .spec|1 .env|1) (let ((.m-define-syntax-letrec|2 0)) (begin (set! .m-define-syntax-letrec|2 (lambda (.keyword|3 .spec|3 .env|3) (syntactic-bind-globally! .keyword|3 (m-compile-transformer-spec .spec|3 .env|3)))) (.m-define-syntax-letrec|2 .keyword|1 .spec|1 .env|1))))) 'm-define-syntax-letrec))
(let () (begin (set! m-define-syntax-letrec* (lambda (.keyword|1 .spec|1 .env|1) (let ((.m-define-syntax-letrec*|2 0)) (begin (set! .m-define-syntax-letrec*|2 (lambda (.keyword|3 .spec|3 .env|3) (let* ((.env|6 (syntactic-extend (syntactic-copy .env|3) (cons .keyword|3 '()) '((fake denotation)))) (.transformer|9 (m-compile-transformer-spec .spec|3 .env|6))) (let () (begin (syntactic-assign! .env|6 .keyword|3 .transformer|9) (syntactic-bind-globally! .keyword|3 .transformer|9)))))) (.m-define-syntax-letrec*|2 .keyword|1 .spec|1 .env|1))))) 'm-define-syntax-letrec*))
(let () (begin (set! m-define-syntax-let* (lambda (.keyword|1 .spec|1 .env|1) (let ((.m-define-syntax-let*|2 0)) (begin (set! .m-define-syntax-let*|2 (lambda (.keyword|3 .spec|3 .env|3) (syntactic-bind-globally! .keyword|3 (m-compile-transformer-spec .spec|3 (syntactic-copy .env|3))))) (.m-define-syntax-let*|2 .keyword|1 .spec|1 .env|1))))) 'm-define-syntax-let*))
(let () (begin (set! m-let-syntax (lambda (.exp|1 .env|1) (let ((.m-let-syntax|2 0)) (begin (set! .m-let-syntax|2 (lambda (.exp|3 .env|3) (if (if (> (safe-length .exp|3) 2) (every1? (lambda (.binding|6) (if (pair? .binding|6) (if (symbol? (let ((.x|9|12 .binding|6)) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12)))) (if (pair? (let ((.x|14|17 .binding|6)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17)))) (null? (let ((.x|20|23 (let ((.x|24|27 .binding|6)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27))))) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23)))) #f) #f) #f)) (let ((.x|29|32 (let ((.x|33|36 .exp|3)) (begin (.check! (pair? .x|33|36) 1 .x|33|36) (cdr:pair .x|33|36))))) (begin (.check! (pair? .x|29|32) 0 .x|29|32) (car:pair .x|29|32)))) #f) (m-body (let ((.x|38|41 (let ((.x|42|45 .exp|3)) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45))))) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41))) (syntactic-extend .env|3 (let () (let ((.loop|51|54|57 (unspecified))) (begin (set! .loop|51|54|57 (lambda (.y1|46|47|58 .results|46|50|58) (if (null? .y1|46|47|58) (reverse .results|46|50|58) (begin #t (.loop|51|54|57 (let ((.x|62|65 .y1|46|47|58)) (begin (.check! (pair? .x|62|65) 1 .x|62|65) (cdr:pair .x|62|65))) (cons (let ((.x|66|69 (let ((.x|70|73 .y1|46|47|58)) (begin (.check! (pair? .x|70|73) 0 .x|70|73) (car:pair .x|70|73))))) (begin (.check! (pair? .x|66|69) 0 .x|66|69) (car:pair .x|66|69))) .results|46|50|58)))))) (.loop|51|54|57 (let ((.x|75|78 (let ((.x|79|82 .exp|3)) (begin (.check! (pair? .x|79|82) 1 .x|79|82) (cdr:pair .x|79|82))))) (begin (.check! (pair? .x|75|78) 0 .x|75|78) (car:pair .x|75|78))) '())))) (let () (let ((.loop|88|91|94 (unspecified))) (begin (set! .loop|88|91|94 (lambda (.y1|83|84|95 .results|83|87|95) (if (null? .y1|83|84|95) (reverse .results|83|87|95) (begin #t (.loop|88|91|94 (let ((.x|99|102 .y1|83|84|95)) (begin (.check! (pair? .x|99|102) 1 .x|99|102) (cdr:pair .x|99|102))) (cons (let ((.spec|103 (let ((.x|104|107 .y1|83|84|95)) (begin (.check! (pair? .x|104|107) 0 .x|104|107) (car:pair .x|104|107))))) (m-compile-transformer-spec .spec|103 .env|3)) .results|83|87|95)))))) (.loop|88|91|94 (let () (let ((.loop|113|116|119 (unspecified))) (begin (set! .loop|113|116|119 (lambda (.y1|108|109|120 .results|108|112|120) (if (null? .y1|108|109|120) (reverse .results|108|112|120) (begin #t (.loop|113|116|119 (let ((.x|124|127 .y1|108|109|120)) (begin (.check! (pair? .x|124|127) 1 .x|124|127) (cdr:pair .x|124|127))) (cons (let ((.x|129|132 (let ((.x|133|136 (let ((.x|137|140 .y1|108|109|120)) (begin (.check! (pair? .x|137|140) 0 .x|137|140) (car:pair .x|137|140))))) (begin (.check! (pair? .x|133|136) 1 .x|133|136) (cdr:pair .x|133|136))))) (begin (.check! (pair? .x|129|132) 0 .x|129|132) (car:pair .x|129|132))) .results|108|112|120)))))) (.loop|113|116|119 (let ((.x|142|145 (let ((.x|146|149 .exp|3)) (begin (.check! (pair? .x|146|149) 1 .x|146|149) (cdr:pair .x|146|149))))) (begin (.check! (pair? .x|142|145) 0 .x|142|145) (car:pair .x|142|145))) '())))) '())))))) (m-error "Malformed let-syntax" .exp|3)))) (.m-let-syntax|2 .exp|1 .env|1))))) 'm-let-syntax))
(let () (begin (set! m-letrec-syntax (lambda (.exp|1 .env|1) (let ((.m-letrec-syntax|2 0)) (begin (set! .m-letrec-syntax|2 (lambda (.exp|3 .env|3) (if (if (> (safe-length .exp|3) 2) (every1? (lambda (.binding|6) (if (pair? .binding|6) (if (symbol? (let ((.x|9|12 .binding|6)) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12)))) (if (pair? (let ((.x|14|17 .binding|6)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17)))) (null? (let ((.x|20|23 (let ((.x|24|27 .binding|6)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27))))) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23)))) #f) #f) #f)) (let ((.x|29|32 (let ((.x|33|36 .exp|3)) (begin (.check! (pair? .x|33|36) 1 .x|33|36) (cdr:pair .x|33|36))))) (begin (.check! (pair? .x|29|32) 0 .x|29|32) (car:pair .x|29|32)))) #f) (let ((.env|39 (syntactic-extend .env|3 (let () (let ((.loop|171|174|177 (unspecified))) (begin (set! .loop|171|174|177 (lambda (.y1|166|167|178 .results|166|170|178) (if (null? .y1|166|167|178) (reverse .results|166|170|178) (begin #t (.loop|171|174|177 (let ((.x|182|185 .y1|166|167|178)) (begin (.check! (pair? .x|182|185) 1 .x|182|185) (cdr:pair .x|182|185))) (cons (let ((.x|186|189 (let ((.x|190|193 .y1|166|167|178)) (begin (.check! (pair? .x|190|193) 0 .x|190|193) (car:pair .x|190|193))))) (begin (.check! (pair? .x|186|189) 0 .x|186|189) (car:pair .x|186|189))) .results|166|170|178)))))) (.loop|171|174|177 (let ((.x|195|198 (let ((.x|199|202 .exp|3)) (begin (.check! (pair? .x|199|202) 1 .x|199|202) (cdr:pair .x|199|202))))) (begin (.check! (pair? .x|195|198) 0 .x|195|198) (car:pair .x|195|198))) '())))) (let () (let ((.loop|208|211|214 (unspecified))) (begin (set! .loop|208|211|214 (lambda (.y1|203|204|215 .results|203|207|215) (if (null? .y1|203|204|215) (reverse .results|203|207|215) (begin #t (.loop|208|211|214 (let ((.x|219|222 .y1|203|204|215)) (begin (.check! (pair? .x|219|222) 1 .x|219|222) (cdr:pair .x|219|222))) (cons (let ((.id|223 (let ((.x|224|227 .y1|203|204|215)) (begin (.check! (pair? .x|224|227) 0 .x|224|227) (car:pair .x|224|227))))) '(fake denotation)) .results|203|207|215)))))) (.loop|208|211|214 (let ((.x|229|232 (let ((.x|233|236 .exp|3)) (begin (.check! (pair? .x|233|236) 1 .x|233|236) (cdr:pair .x|233|236))))) (begin (.check! (pair? .x|229|232) 0 .x|229|232) (car:pair .x|229|232))) '()))))))) (begin (let () (let ((.loop|46|49|52 (unspecified))) (begin (set! .loop|46|49|52 (lambda (.y1|40|42|53 .y1|40|41|53) (if (let ((.temp|55|58 (null? .y1|40|42|53))) (if .temp|55|58 .temp|55|58 (null? .y1|40|41|53))) (if #f #f (unspecified)) (begin (begin #t (let ((.id|61 (let ((.x|62|65 .y1|40|42|53)) (begin (.check! (pair? .x|62|65) 0 .x|62|65) (car:pair .x|62|65)))) (.spec|61 (let ((.x|66|69 .y1|40|41|53)) (begin (.check! (pair? .x|66|69) 0 .x|66|69) (car:pair .x|66|69))))) (syntactic-assign! .env|39 .id|61 (m-compile-transformer-spec .spec|61 .env|39)))) (.loop|46|49|52 (let ((.x|70|73 .y1|40|42|53)) (begin (.check! (pair? .x|70|73) 1 .x|70|73) (cdr:pair .x|70|73))) (let ((.x|74|77 .y1|40|41|53)) (begin (.check! (pair? .x|74|77) 1 .x|74|77) (cdr:pair .x|74|77)))))))) (.loop|46|49|52 (let () (let ((.loop|83|86|89 (unspecified))) (begin (set! .loop|83|86|89 (lambda (.y1|78|79|90 .results|78|82|90) (if (null? .y1|78|79|90) (reverse .results|78|82|90) (begin #t (.loop|83|86|89 (let ((.x|94|97 .y1|78|79|90)) (begin (.check! (pair? .x|94|97) 1 .x|94|97) (cdr:pair .x|94|97))) (cons (let ((.x|98|101 (let ((.x|102|105 .y1|78|79|90)) (begin (.check! (pair? .x|102|105) 0 .x|102|105) (car:pair .x|102|105))))) (begin (.check! (pair? .x|98|101) 0 .x|98|101) (car:pair .x|98|101))) .results|78|82|90)))))) (.loop|83|86|89 (let ((.x|107|110 (let ((.x|111|114 .exp|3)) (begin (.check! (pair? .x|111|114) 1 .x|111|114) (cdr:pair .x|111|114))))) (begin (.check! (pair? .x|107|110) 0 .x|107|110) (car:pair .x|107|110))) '())))) (let () (let ((.loop|120|123|126 (unspecified))) (begin (set! .loop|120|123|126 (lambda (.y1|115|116|127 .results|115|119|127) (if (null? .y1|115|116|127) (reverse .results|115|119|127) (begin #t (.loop|120|123|126 (let ((.x|131|134 .y1|115|116|127)) (begin (.check! (pair? .x|131|134) 1 .x|131|134) (cdr:pair .x|131|134))) (cons (let ((.x|136|139 (let ((.x|140|143 (let ((.x|144|147 .y1|115|116|127)) (begin (.check! (pair? .x|144|147) 0 .x|144|147) (car:pair .x|144|147))))) (begin (.check! (pair? .x|140|143) 1 .x|140|143) (cdr:pair .x|140|143))))) (begin (.check! (pair? .x|136|139) 0 .x|136|139) (car:pair .x|136|139))) .results|115|119|127)))))) (.loop|120|123|126 (let ((.x|149|152 (let ((.x|153|156 .exp|3)) (begin (.check! (pair? .x|153|156) 1 .x|153|156) (cdr:pair .x|153|156))))) (begin (.check! (pair? .x|149|152) 0 .x|149|152) (car:pair .x|149|152))) '())))))))) (m-body (let ((.x|158|161 (let ((.x|162|165 .exp|3)) (begin (.check! (pair? .x|162|165) 1 .x|162|165) (cdr:pair .x|162|165))))) (begin (.check! (pair? .x|158|161) 1 .x|158|161) (cdr:pair .x|158|161))) .env|39))) (m-error "Malformed let-syntax" .exp|3)))) (.m-letrec-syntax|2 .exp|1 .env|1))))) 'm-letrec-syntax))
(let () (begin (set! m-macro (lambda (.exp|1 .env|1) (let ((.m-macro|2 0)) (begin (set! .m-macro|2 (lambda (.exp|3 .env|3) (m-transcribe .exp|3 .env|3 (lambda (.exp|4 .env|4) (m-expand .exp|4 .env|4))))) (.m-macro|2 .exp|1 .env|1))))) 'm-macro))
(let () (begin (set! m-inline (lambda (.exp|1 .env|1) (let ((.m-inline|2 0)) (begin (set! .m-inline|2 (lambda (.exp|3 .env|3) (if (integrate-usual-procedures) (m-transcribe-inline .exp|3 .env|3 (lambda (.newexp|4 .env|4) (if (eq? .exp|3 .newexp|4) (m-application .exp|3 .env|4) (m-expand .newexp|4 .env|4)))) (m-application .exp|3 .env|3)))) (.m-inline|2 .exp|1 .env|1))))) 'm-inline))
(let () (begin (set! m-quit (lambda (.v|1) .v|1)) 'm-quit))
(let () ($$trace "usual"))
(let () (define-syntax-scope 'letrec*))
(let () (let () (let ((.loop|6|8|11 (unspecified))) (begin (set! .loop|6|8|11 (lambda (.y1|1|2|12) (if (null? .y1|1|2|12) (if #f #f (unspecified)) (begin (begin #t (let ((.form|16 (let ((.x|17|20 .y1|1|2|12)) (begin (.check! (pair? .x|17|20) 0 .x|17|20) (car:pair .x|17|20))))) (macro-expand .form|16))) (.loop|6|8|11 (let ((.x|21|24 .y1|1|2|12)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24)))))))) (.loop|6|8|11 '((define-syntax let (syntax-rules () ((let ((?name ?val) ...) ?body ?body1 ...) ((lambda (?name ...) ?body ?body1 ...) ?val ...)))) (define-syntax let* (syntax-rules () ((let* () ?body ?body1 ...) (let () ?body ?body1 ...)) ((let* ((?name1 ?val1) (?name ?val) ...) ?body ?body1 ...) (let ((?name1 ?val1)) (let* ((?name ?val) ...) ?body ?body1 ...))))) (define-syntax letrec (syntax-rules (lambda quote) ((letrec ((?name ?val) ...) ?body ?body2 ...) ((lambda () (define ?name ?val) ... ?body ?body2 ...))))) (define-syntax let let* (syntax-rules () ((let (?bindings ...) . ?body) (let (?bindings ...) . ?body)) ((let ?tag ((?name ?val) ...) ?body ?body1 ...) (let ((?name ?val) ...) (letrec ((?tag (lambda (?name ...) ?body ?body1 ...))) (?tag ?name ...)))))) (define-syntax and (syntax-rules () ((and) #t) ((and ?e) ?e) ((and ?e1 ?e2 ?e3 ...) (if ?e1 (and ?e2 ?e3 ...) #f)))) (define-syntax or (syntax-rules () ((or) #f) ((or ?e) ?e) ((or ?e1 ?e2 ?e3 ...) (let ((temp ?e1)) (if temp temp (or ?e2 ?e3 ...)))))) (define-syntax cond (syntax-rules (else =>) ((cond (else ?result ?result2 ...)) (begin ?result ?result2 ...)) ((cond (?test => ?result)) (let ((temp ?test)) (if temp (?result temp)))) ((cond (?test)) ?test) ((cond (?test ?result ?result2 ...)) (if ?test (begin ?result ?result2 ...))) ((cond (?test => ?result) ?clause ?clause2 ...) (let ((temp ?test)) (if temp (?result temp) (cond ?clause ?clause2 ...)))) ((cond (?test) ?clause ?clause2 ...) (or ?test (cond ?clause ?clause2 ...))) ((cond (?test ?result ?result2 ...) ?clause ?clause2 ...) (if ?test (begin ?result ?result2 ...) (cond ?clause ?clause2 ...))))) (define-syntax do (syntax-rules () ((do (?bindings0 ...) (?test) ?body0 ...) (do (?bindings0 ...) (?test (if #f #f)) ?body0 ...)) ((do (?bindings0 ...) ?clause0 ?body0 ...) (letrec-syntax ((do-aux (... (syntax-rules () ((do-aux () ((?name ?init ?step) ...) ?clause ?body ...) (letrec ((loop (lambda (?name ...) (cond ?clause (else (begin #t ?body ...) (loop ?step ...)))))) (loop ?init ...))) ((do-aux ((?name ?init ?step) ?todo ...) (?bindings ...) ?clause ?body ...) (do-aux (?todo ...) (?bindings ... (?name ?init ?step)) ?clause ?body ...)) ((do-aux ((?name ?init) ?todo ...) (?bindings ...) ?clause ?body ...) (do-aux (?todo ...) (?bindings ... (?name ?init ?name)) ?clause ?body ...)))))) (do-aux (?bindings0 ...) () ?clause0 ?body0 ...))))) (define-syntax delay (syntax-rules () ((delay ?e) (.make-promise (lambda () ?e))))) (define-syntax case (syntax-rules (else) ((case ?e1 (else ?body ?body2 ...)) (begin ?e1 ?body ?body2 ...)) ((case ?e1 (?z ?body ?body2 ...)) (if (memv ?e1 '?z) (begin ?body ?body2 ...))) ((case ?e1 ?clause1 ?clause2 ?clause3 ...) (letrec-syntax ((case-aux (... (syntax-rules (else) ((case-aux ?temp (else ?body ?body2 ...)) (begin ?body ?body2 ...)) ((case-aux ?temp ((?z ...) ?body ?body2 ...)) (if (memv ?temp '(?z ...)) (begin ?body ?body2 ...))) ((case-aux ?temp ((?z ...) ?body ?body2 ...) ?c1 ?c2 ...) (if (memv ?temp '(?z ...)) (begin ?body ?body2 ...) (case-aux ?temp ?c1 ?c2 ...))) ((case-aux ?temp (?z ?body ...) ?c1 ...) (case-aux ?temp ((?z) ?body ...) ?c1 ...)))))) (let ((temp ?e1)) (case-aux temp ?clause1 ?clause2 ?clause3 ...)))))) (begin (define-syntax .finalize-quasiquote letrec (syntax-rules (quote unquote unquote-splicing) ((.finalize-quasiquote quote ?arg ?return) (.interpret-continuation ?return '?arg)) ((.finalize-quasiquote unquote ?arg ?return) (.interpret-continuation ?return ?arg)) ((.finalize-quasiquote unquote-splicing ?arg ?return) (syntax-error ",@ in illegal context" ?arg)) ((.finalize-quasiquote ?mode ?arg ?return) (.interpret-continuation ?return (?mode . ?arg))))) (define-syntax .descend-quasiquote letrec (syntax-rules (quasiquote unquote unquote-splicing) ((.descend-quasiquote `?y ?x ?level ?return) (.descend-quasiquote-pair ?x ?x (?level) ?return)) ((.descend-quasiquote ,?y ?x () ?return) (.interpret-continuation ?return unquote ?y)) ((.descend-quasiquote ,?y ?x (?level) ?return) (.descend-quasiquote-pair ?x ?x ?level ?return)) ((.descend-quasiquote ,@?y ?x () ?return) (.interpret-continuation ?return unquote-splicing ?y)) ((.descend-quasiquote ,@?y ?x (?level) ?return) (.descend-quasiquote-pair ?x ?x ?level ?return)) ((.descend-quasiquote (?y . ?z) ?x ?level ?return) (.descend-quasiquote-pair ?x ?x ?level ?return)) ((.descend-quasiquote #(?y ...) ?x ?level ?return) (.descend-quasiquote-vector ?x ?x ?level ?return)) ((.descend-quasiquote ?y ?x ?level ?return) (.interpret-continuation ?return quote ?x)))) (define-syntax .descend-quasiquote-pair letrec (syntax-rules (quote unquote unquote-splicing) ((.descend-quasiquote-pair (?carx . ?cdrx) ?x ?level ?return) (.descend-quasiquote ?carx ?carx ?level (1 ?cdrx ?x ?level ?return))))) (define-syntax .descend-quasiquote-vector letrec (syntax-rules (quote) ((.descend-quasiquote-vector #(?y ...) ?x ?level ?return) (.descend-quasiquote (?y ...) (?y ...) ?level (6 ?x ?return))))) (define-syntax .interpret-continuation letrec (syntax-rules (quote unquote unquote-splicing) ((.interpret-continuation (-1) ?e) ?e) ((.interpret-continuation (0) ?mode ?arg) (.finalize-quasiquote ?mode ?arg (-1))) ((.interpret-continuation (1 ?cdrx ?x ?level ?return) ?car-mode ?car-arg) (.descend-quasiquote ?cdrx ?cdrx ?level (2 ?car-mode ?car-arg ?x ?return))) ((.interpret-continuation (2 quote ?car-arg ?x ?return) quote ?cdr-arg) (.interpret-continuation ?return quote ?x)) ((.interpret-continuation (2 unquote-splicing ?car-arg ?x ?return) quote ()) (.interpret-continuation ?return unquote ?car-arg)) ((.interpret-continuation (2 unquote-splicing ?car-arg ?x ?return) ?cdr-mode ?cdr-arg) (.finalize-quasiquote ?cdr-mode ?cdr-arg (3 ?car-arg ?return))) ((.interpret-continuation (2 ?car-mode ?car-arg ?x ?return) ?cdr-mode ?cdr-arg) (.finalize-quasiquote ?car-mode ?car-arg (4 ?cdr-mode ?cdr-arg ?return))) ((.interpret-continuation (3 ?car-arg ?return) ?e) (.interpret-continuation ?return append (?car-arg ?e))) ((.interpret-continuation (4 ?cdr-mode ?cdr-arg ?return) ?e1) (.finalize-quasiquote ?cdr-mode ?cdr-arg (5 ?e1 ?return))) ((.interpret-continuation (5 ?e1 ?return) ?e2) (.interpret-continuation ?return .cons (?e1 ?e2))) ((.interpret-continuation (6 ?x ?return) quote ?arg) (.interpret-continuation ?return quote ?x)) ((.interpret-continuation (6 ?x ?return) ?mode ?arg) (.finalize-quasiquote ?mode ?arg (7 ?return))) ((.interpret-continuation (7 ?return) ?e) (.interpret-continuation ?return .list->vector (?e))))) (define-syntax quasiquote letrec (syntax-rules () (`?x (.descend-quasiquote ?x ?x () (0)))))) (define-syntax let*-syntax (syntax-rules () ((let*-syntax () ?body) (let-syntax () ?body)) ((let*-syntax ((?name1 ?val1) (?name ?val) ...) ?body) (let-syntax ((?name1 ?val1)) (let*-syntax ((?name ?val) ...) ?body)))))))))))
(let () (define-syntax-scope 'letrec))
(let () (begin (set! standard-syntactic-environment (syntactic-copy global-syntactic-environment)) 'standard-syntactic-environment))
(let () (begin (set! make-standard-syntactic-environment (lambda () (let ((.make-standard-syntactic-environment|2 0)) (begin (set! .make-standard-syntactic-environment|2 (lambda () (syntactic-copy standard-syntactic-environment))) (.make-standard-syntactic-environment|2))))) 'make-standard-syntactic-environment))
(let () (begin (set! copy-exp (lambda (.exp|1) (let ((.copy-exp|2 0)) (begin (set! .copy-exp|2 (lambda (.exp|3) (let ((.copy|4 (unspecified)) (.lexical-lookup|4 (unspecified)) (.env-unbind-multiple!|4 (unspecified)) (.env-bind-multiple!|4 (unspecified)) (.env-lookup|4 (unspecified)) (.env-unbind!|4 (unspecified)) (.env-bind!|4 (unspecified)) (.make-env|4 (unspecified)) (.rename-formals|4 (unspecified)) (.rename-vars|4 (unspecified)) (.renaming-counter|4 (unspecified)) (.original-names|4 (unspecified)) (.special-names|4 (unspecified))) (begin (set! .copy|4 (lambda (.exp|5 .env|5 .notepad|5 .r-table|5) (if (constant? .exp|5) .exp|5 (if (lambda? .exp|5) (let* ((.bvl|10 (make-null-terminated (lambda.args .exp|5))) (.newnames|13 (.rename-vars|4 .bvl|10)) (.procnames|16 (let () (let ((.loop|172|175|178 (unspecified))) (begin (set! .loop|172|175|178 (lambda (.y1|167|168|179 .results|167|171|179) (if (null? .y1|167|168|179) (reverse .results|167|171|179) (begin #t (.loop|172|175|178 (let ((.x|183|186 .y1|167|168|179)) (begin (.check! (pair? .x|183|186) 1 .x|183|186) (cdr:pair .x|183|186))) (cons (def.lhs (let ((.x|187|190 .y1|167|168|179)) (begin (.check! (pair? .x|187|190) 0 .x|187|190) (car:pair .x|187|190)))) .results|167|171|179)))))) (.loop|172|175|178 (lambda.defs .exp|5) '()))))) (.newprocnames|19 (.rename-vars|4 .procnames|16)) (.refinfo|22 (let () (let ((.loop|147|150|153 (unspecified))) (begin (set! .loop|147|150|153 (lambda (.y1|142|143|154 .results|142|146|154) (if (null? .y1|142|143|154) (reverse .results|142|146|154) (begin #t (.loop|147|150|153 (let ((.x|158|161 .y1|142|143|154)) (begin (.check! (pair? .x|158|161) 1 .x|158|161) (cdr:pair .x|158|161))) (cons (let ((.var|162 (let ((.x|163|166 .y1|142|143|154)) (begin (.check! (pair? .x|163|166) 0 .x|163|166) (car:pair .x|163|166))))) (make-r-entry .var|162 '() '() '())) .results|142|146|154)))))) (.loop|147|150|153 (append .newnames|13 .newprocnames|19) '()))))) (.newexp|25 (make-lambda (.rename-formals|4 (lambda.args .exp|5) .newnames|13) '() .refinfo|22 '() '() (lambda.decls .exp|5) (lambda.doc .exp|5) (lambda.body .exp|5)))) (let () (begin (.env-bind-multiple!|4 .env|5 .procnames|16 .newprocnames|19) (.env-bind-multiple!|4 .env|5 .bvl|10 .newnames|13) (let () (let ((.loop|34|36|39 (unspecified))) (begin (set! .loop|34|36|39 (lambda (.y1|29|30|40) (if (null? .y1|29|30|40) (if #f #f (unspecified)) (begin (begin #t (let ((.entry|44 (let ((.x|45|48 .y1|29|30|40)) (begin (.check! (pair? .x|45|48) 0 .x|45|48) (car:pair .x|45|48))))) (.env-bind!|4 .r-table|5 (r-entry.name .entry|44) .entry|44))) (.loop|34|36|39 (let ((.x|49|52 .y1|29|30|40)) (begin (.check! (pair? .x|49|52) 1 .x|49|52) (cdr:pair .x|49|52)))))))) (.loop|34|36|39 .refinfo|22)))) (notepad-lambda-add! .notepad|5 .newexp|25) (let ((.newnotepad|55 (make-notepad .notepad|5))) (begin (let () (let ((.loop|62|65|68 (unspecified))) (begin (set! .loop|62|65|68 (lambda (.y1|56|58|69 .y1|56|57|69) (if (let ((.temp|71|74 (null? .y1|56|58|69))) (if .temp|71|74 .temp|71|74 (null? .y1|56|57|69))) (if #f #f (unspecified)) (begin (begin #t (let ((.name|77 (let ((.x|78|81 .y1|56|58|69)) (begin (.check! (pair? .x|78|81) 0 .x|78|81) (car:pair .x|78|81)))) (.rhs|77 (let ((.x|82|85 .y1|56|57|69)) (begin (.check! (pair? .x|82|85) 0 .x|82|85) (car:pair .x|82|85))))) (lambda.defs-set! .newexp|25 (cons (make-definition .name|77 (.copy|4 .rhs|77 .env|5 .newnotepad|55 .r-table|5)) (lambda.defs .newexp|25))))) (.loop|62|65|68 (let ((.x|86|89 .y1|56|58|69)) (begin (.check! (pair? .x|86|89) 1 .x|86|89) (cdr:pair .x|86|89))) (let ((.x|90|93 .y1|56|57|69)) (begin (.check! (pair? .x|90|93) 1 .x|90|93) (cdr:pair .x|90|93)))))))) (.loop|62|65|68 (reverse .newprocnames|19) (let () (let ((.loop|99|102|105 (unspecified))) (begin (set! .loop|99|102|105 (lambda (.y1|94|95|106 .results|94|98|106) (if (null? .y1|94|95|106) (reverse .results|94|98|106) (begin #t (.loop|99|102|105 (let ((.x|110|113 .y1|94|95|106)) (begin (.check! (pair? .x|110|113) 1 .x|110|113) (cdr:pair .x|110|113))) (cons (def.rhs (let ((.x|114|117 .y1|94|95|106)) (begin (.check! (pair? .x|114|117) 0 .x|114|117) (car:pair .x|114|117)))) .results|94|98|106)))))) (.loop|99|102|105 (reverse (lambda.defs .exp|5)) '())))))))) (lambda.body-set! .newexp|25 (.copy|4 (lambda.body .exp|5) .env|5 .newnotepad|55 .r-table|5)) (lambda.f-set! .newexp|25 (notepad-free-variables .newnotepad|55)) (lambda.g-set! .newexp|25 (notepad-captured-variables .newnotepad|55)))) (.env-unbind-multiple!|4 .env|5 .procnames|16) (.env-unbind-multiple!|4 .env|5 .bvl|10) (let () (let ((.loop|123|125|128 (unspecified))) (begin (set! .loop|123|125|128 (lambda (.y1|118|119|129) (if (null? .y1|118|119|129) (if #f #f (unspecified)) (begin (begin #t (let ((.entry|133 (let ((.x|134|137 .y1|118|119|129)) (begin (.check! (pair? .x|134|137) 0 .x|134|137) (car:pair .x|134|137))))) (.env-unbind!|4 .r-table|5 (r-entry.name .entry|133)))) (.loop|123|125|128 (let ((.x|138|141 .y1|118|119|129)) (begin (.check! (pair? .x|138|141) 1 .x|138|141) (cdr:pair .x|138|141)))))))) (.loop|123|125|128 .refinfo|22)))) .newexp|25))) (if (assignment? .exp|5) (let* ((.oldname|194 (assignment.lhs .exp|5)) (.name|197 (.env-lookup|4 .env|5 .oldname|194 .oldname|194)) (.varinfo|200 (.env-lookup|4 .r-table|5 .name|197 #f)) (.newexp|203 (make-assignment .name|197 (.copy|4 (assignment.rhs .exp|5) .env|5 .notepad|5 .r-table|5)))) (let () (begin (notepad-var-add! .notepad|5 .name|197) (if .varinfo|200 (r-entry.assignments-set! .varinfo|200 (cons .newexp|203 (r-entry.assignments .varinfo|200))) (unspecified)) .newexp|203))) (if (conditional? .exp|5) (make-conditional (.copy|4 (if.test .exp|5) .env|5 .notepad|5 .r-table|5) (.copy|4 (if.then .exp|5) .env|5 .notepad|5 .r-table|5) (.copy|4 (if.else .exp|5) .env|5 .notepad|5 .r-table|5)) (if (begin? .exp|5) (make-begin (let () (let ((.loop|214|217|220 (unspecified))) (begin (set! .loop|214|217|220 (lambda (.y1|209|210|221 .results|209|213|221) (if (null? .y1|209|210|221) (reverse .results|209|213|221) (begin #t (.loop|214|217|220 (let ((.x|225|228 .y1|209|210|221)) (begin (.check! (pair? .x|225|228) 1 .x|225|228) (cdr:pair .x|225|228))) (cons (let ((.exp|229 (let ((.x|230|233 .y1|209|210|221)) (begin (.check! (pair? .x|230|233) 0 .x|230|233) (car:pair .x|230|233))))) (.copy|4 .exp|229 .env|5 .notepad|5 .r-table|5)) .results|209|213|221)))))) (.loop|214|217|220 (begin.exprs .exp|5) '()))))) (if (variable? .exp|5) (let* ((.oldname|237 (variable.name .exp|5)) (.name|240 (.env-lookup|4 .env|5 .oldname|237 .oldname|237)) (.varinfo|243 (.env-lookup|4 .r-table|5 .name|240 #f)) (.newexp|246 (make-variable .name|240))) (let () (begin (notepad-var-add! .notepad|5 .name|240) (if .varinfo|243 (r-entry.references-set! .varinfo|243 (cons .newexp|246 (r-entry.references .varinfo|243))) (unspecified)) .newexp|246))) (if (call? .exp|5) (let ((.newexp|253 (make-call (.copy|4 (call.proc .exp|5) .env|5 .notepad|5 .r-table|5) (let () (let ((.loop|262|265|268 (unspecified))) (begin (set! .loop|262|265|268 (lambda (.y1|257|258|269 .results|257|261|269) (if (null? .y1|257|258|269) (reverse .results|257|261|269) (begin #t (.loop|262|265|268 (let ((.x|273|276 .y1|257|258|269)) (begin (.check! (pair? .x|273|276) 1 .x|273|276) (cdr:pair .x|273|276))) (cons (let ((.exp|277 (let ((.x|278|281 .y1|257|258|269)) (begin (.check! (pair? .x|278|281) 0 .x|278|281) (car:pair .x|278|281))))) (.copy|4 .exp|277 .env|5 .notepad|5 .r-table|5)) .results|257|261|269)))))) (.loop|262|265|268 (call.args .exp|5) '()))))))) (begin (if (variable? (call.proc .newexp|253)) (let ((.varinfo|256 (.env-lookup|4 .r-table|5 (variable.name (call.proc .newexp|253)) #f))) (if .varinfo|256 (r-entry.calls-set! .varinfo|256 (cons .newexp|253 (r-entry.calls .varinfo|256))) (unspecified))) (unspecified)) (if (lambda? (call.proc .newexp|253)) (notepad-nonescaping-add! .notepad|5 (call.proc .newexp|253)) (unspecified)) .newexp|253)) ???))))))))) (set! .lexical-lookup|4 (lambda (.r-table|283 .name|283) (assq .name|283 .r-table|283))) (set! .env-unbind-multiple!|4 (lambda (.env|284 .symbols|284) (let () (let ((.loop|290|292|295 (unspecified))) (begin (set! .loop|290|292|295 (lambda (.y1|285|286|296) (if (null? .y1|285|286|296) (if #f #f (unspecified)) (begin (begin #t (let ((.sym|300 (let ((.x|301|304 .y1|285|286|296)) (begin (.check! (pair? .x|301|304) 0 .x|301|304) (car:pair .x|301|304))))) (.env-unbind!|4 .env|284 .sym|300))) (.loop|290|292|295 (let ((.x|305|308 .y1|285|286|296)) (begin (.check! (pair? .x|305|308) 1 .x|305|308) (cdr:pair .x|305|308)))))))) (.loop|290|292|295 .symbols|284)))))) (set! .env-bind-multiple!|4 (lambda (.env|309 .symbols|309 .infos|309) (let () (let ((.loop|316|319|322 (unspecified))) (begin (set! .loop|316|319|322 (lambda (.y1|310|312|323 .y1|310|311|323) (if (let ((.temp|325|328 (null? .y1|310|312|323))) (if .temp|325|328 .temp|325|328 (null? .y1|310|311|323))) (if #f #f (unspecified)) (begin (begin #t (let ((.sym|331 (let ((.x|332|335 .y1|310|312|323)) (begin (.check! (pair? .x|332|335) 0 .x|332|335) (car:pair .x|332|335)))) (.info|331 (let ((.x|336|339 .y1|310|311|323)) (begin (.check! (pair? .x|336|339) 0 .x|336|339) (car:pair .x|336|339))))) (.env-bind!|4 .env|309 .sym|331 .info|331))) (.loop|316|319|322 (let ((.x|340|343 .y1|310|312|323)) (begin (.check! (pair? .x|340|343) 1 .x|340|343) (cdr:pair .x|340|343))) (let ((.x|344|347 .y1|310|311|323)) (begin (.check! (pair? .x|344|347) 1 .x|344|347) (cdr:pair .x|344|347)))))))) (.loop|316|319|322 .symbols|309 .infos|309)))))) (set! .env-lookup|4 (lambda (.env|348 .sym|348 .default|348) (let ((.stack|351 (hashtable-get .env|348 .sym|348))) (if .stack|351 (let ((.x|352|355 .stack|351)) (begin (.check! (pair? .x|352|355) 0 .x|352|355) (car:pair .x|352|355))) .default|348)))) (set! .env-unbind!|4 (lambda (.env|356 .sym|356) (let ((.stack|359 (hashtable-get .env|356 .sym|356))) (hashtable-put! .env|356 .sym|356 (let ((.x|360|363 .stack|359)) (begin (.check! (pair? .x|360|363) 1 .x|360|363) (cdr:pair .x|360|363))))))) (set! .env-bind!|4 (lambda (.env|364 .sym|364 .info|364) (let ((.stack|367 (hashtable-get .env|364 .sym|364))) (hashtable-put! .env|364 .sym|364 (cons .info|364 .stack|367))))) (set! .make-env|4 (lambda () (make-hashtable symbol-hash assq))) (set! .rename-formals|4 (lambda (.formals|369 .newnames|369) (if (null? .formals|369) '() (if (symbol? .formals|369) (let ((.x|372|375 .newnames|369)) (begin (.check! (pair? .x|372|375) 0 .x|372|375) (car:pair .x|372|375))) (if (memq (let ((.x|377|380 .formals|369)) (begin (.check! (pair? .x|377|380) 0 .x|377|380) (car:pair .x|377|380))) .special-names|4) (cons (let ((.x|381|384 .formals|369)) (begin (.check! (pair? .x|381|384) 0 .x|381|384) (car:pair .x|381|384))) (.rename-formals|4 (let ((.x|385|388 .formals|369)) (begin (.check! (pair? .x|385|388) 1 .x|385|388) (cdr:pair .x|385|388))) (let ((.x|389|392 .newnames|369)) (begin (.check! (pair? .x|389|392) 1 .x|389|392) (cdr:pair .x|389|392))))) (cons (let ((.x|394|397 .newnames|369)) (begin (.check! (pair? .x|394|397) 0 .x|394|397) (car:pair .x|394|397))) (.rename-formals|4 (let ((.x|398|401 .formals|369)) (begin (.check! (pair? .x|398|401) 1 .x|398|401) (cdr:pair .x|398|401))) (let ((.x|402|405 .newnames|369)) (begin (.check! (pair? .x|402|405) 1 .x|402|405) (cdr:pair .x|402|405)))))))))) (set! .rename-vars|4 (lambda (.vars|406) (let ((.rename|409 (make-rename-procedure))) (let () (let ((.loop|415|418|421 (unspecified))) (begin (set! .loop|415|418|421 (lambda (.y1|410|411|422 .results|410|414|422) (if (null? .y1|410|411|422) (reverse .results|410|414|422) (begin #t (.loop|415|418|421 (let ((.x|426|429 .y1|410|411|422)) (begin (.check! (pair? .x|426|429) 1 .x|426|429) (cdr:pair .x|426|429))) (cons (let ((.var|430 (let ((.x|434|437 .y1|410|411|422)) (begin (.check! (pair? .x|434|437) 0 .x|434|437) (car:pair .x|434|437))))) (if (memq .var|430 .special-names|4) .var|430 (if (hashtable-get .original-names|4 .var|430) (.rename|409 .var|430) (begin (hashtable-put! .original-names|4 .var|430 #t) .var|430)))) .results|410|414|422)))))) (.loop|415|418|421 .vars|406 '()))))))) (set! .renaming-counter|4 0) (set! .original-names|4 (make-hashtable symbol-hash assq)) (set! .special-names|4 (cons name:ignored argument-registers)) (.copy|4 .exp|3 (.make-env|4) (make-notepad #f) (.make-env|4)))))) (.copy-exp|2 .exp|1))))) 'copy-exp))
(let () (begin (set! check-referencing-invariants (lambda (.exp|1 . .flags|1) (let ((.check-free-variables?|4 (memq 'free .flags|1)) (.check-referencing?|4 (memq 'reference .flags|1)) (.first-violation?|4 #t)) (let ((.lookup|5 (unspecified)) (.return|5 (unspecified)) (.check|5 (unspecified))) (begin (set! .lookup|5 (lambda (.env|6 .i|6) (if (null? .env|6) #f (let* ((.rinfo|9 (r-entry (lambda.r (let ((.x|19|22 .env|6)) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22)))) .i|6)) (.temp|10|13 .rinfo|9)) (if .temp|10|13 .temp|10|13 (.lookup|5 (let ((.x|15|18 .env|6)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))) .i|6)))))) (set! .return|5 (lambda (.exp|23 .flag|23) (if .flag|23 #t (if .first-violation?|4 (begin (set! .first-violation?|4 #f) (display "Violation of referencing invariants") (newline) (pretty-print (make-readable .exp|23)) #f) (begin (pretty-print (make-readable .exp|23)) #f))))) (set! .check|5 (lambda (.exp|27 .env|27) (if (constant? .exp|27) (.return|5 .exp|27 #t) (if (lambda? .exp|27) (let ((.env|32 (cons .exp|27 .env|27))) (.return|5 .exp|27 (if (every? (lambda (.exp|34) (.check|5 .exp|34 .env|32)) (let () (let ((.loop|40|43|46 (unspecified))) (begin (set! .loop|40|43|46 (lambda (.y1|35|36|47 .results|35|39|47) (if (null? .y1|35|36|47) (reverse .results|35|39|47) (begin #t (.loop|40|43|46 (let ((.x|51|54 .y1|35|36|47)) (begin (.check! (pair? .x|51|54) 1 .x|51|54) (cdr:pair .x|51|54))) (cons (def.rhs (let ((.x|55|58 .y1|35|36|47)) (begin (.check! (pair? .x|55|58) 0 .x|55|58) (car:pair .x|55|58)))) .results|35|39|47)))))) (.loop|40|43|46 (lambda.defs .exp|27) '()))))) (if (.check|5 (lambda.body .exp|27) .env|32) (if (if (if .check-free-variables?|4 (not (null? .env|32)) #f) (subset? (difference (lambda.f .exp|27) (make-null-terminated (lambda.args .exp|27))) (lambda.f (let ((.x|63|66 .env|32)) (begin (.check! (pair? .x|63|66) 0 .x|63|66) (car:pair .x|63|66))))) #t) (if .check-referencing?|4 (let ((.env|70 (cons .exp|27 .env|32)) (.r|70 (lambda.r .exp|27))) (every? (lambda (.formal|71) (let ((.temp|72|75 (ignored? .formal|71))) (if .temp|72|75 .temp|72|75 (r-entry .r|70 .formal|71)))) (make-null-terminated (lambda.args .exp|27)))) #t) #f) #f) #f))) (if (variable? .exp|27) (.return|5 .exp|27 (if (if (if .check-free-variables?|4 (not (null? .env|27)) #f) (memq (variable.name .exp|27) (lambda.f (let ((.x|81|84 .env|27)) (begin (.check! (pair? .x|81|84) 0 .x|81|84) (car:pair .x|81|84))))) #t) (if .check-referencing?|4 (let ((.rinfo|88 (.lookup|5 .env|27 (variable.name .exp|27)))) (if .rinfo|88 (memq .exp|27 (r-entry.references .rinfo|88)) #t)) #t) #f)) (if (assignment? .exp|27) (.return|5 .exp|27 (if (.check|5 (assignment.rhs .exp|27) .env|27) (if (if (if .check-free-variables?|4 (not (null? .env|27)) #f) (memq (assignment.lhs .exp|27) (lambda.f (let ((.x|94|97 .env|27)) (begin (.check! (pair? .x|94|97) 0 .x|94|97) (car:pair .x|94|97))))) #t) (if .check-referencing?|4 (let ((.rinfo|101 (.lookup|5 .env|27 (assignment.lhs .exp|27)))) (if .rinfo|101 (memq .exp|27 (r-entry.assignments .rinfo|101)) #t)) #t) #f) #f)) (if (conditional? .exp|27) (.return|5 .exp|27 (if (.check|5 (if.test .exp|27) .env|27) (if (.check|5 (if.then .exp|27) .env|27) (.check|5 (if.else .exp|27) .env|27) #f) #f)) (if (begin? .exp|27) (.return|5 .exp|27 (every? (lambda (.exp|107) (.check|5 .exp|107 .env|27)) (begin.exprs .exp|27))) (if (call? .exp|27) (.return|5 .exp|27 (if (.check|5 (call.proc .exp|27) .env|27) (if (every? (lambda (.exp|111) (.check|5 .exp|111 .env|27)) (call.args .exp|27)) (if (if .check-referencing?|4 (variable? (call.proc .exp|27)) #f) (let ((.rinfo|117 (.lookup|5 .env|27 (variable.name (call.proc .exp|27))))) (if .rinfo|117 (memq .exp|27 (r-entry.calls .rinfo|117)) #t)) #t) #f) #f)) ???))))))))) (if (null? .flags|1) (begin (set! .check-free-variables?|4 #t) (set! .check-referencing?|4 #t)) (unspecified)) (.check|5 .exp|1 '())))))) 'check-referencing-invariants))
(let () (begin (set! compute-free-variables! (lambda (.exp|1) (let ((.compute-free-variables!|2 0)) (begin (set! .compute-free-variables!|2 (lambda (.exp|3) (let ((.free|4 (unspecified)) (.set->list|4 (unspecified)) (.union3|4 (unspecified)) (.union2|4 (unspecified)) (.singleton|4 (unspecified)) (.empty-set|4 (unspecified))) (begin (set! .free|4 (lambda (.exp|5) (if (constant? .exp|5) .empty-set|4 (if (lambda? .exp|5) (let* ((.defs|10 (lambda.defs .exp|5)) (.formals|13 (make-set (make-null-terminated (lambda.args .exp|5)))) (.defined|16 (make-set (let () (let ((.loop|59|62|65 (unspecified))) (begin (set! .loop|59|62|65 (lambda (.y1|54|55|66 .results|54|58|66) (if (null? .y1|54|55|66) (reverse .results|54|58|66) (begin #t (.loop|59|62|65 (let ((.x|70|73 .y1|54|55|66)) (begin (.check! (pair? .x|70|73) 1 .x|70|73) (cdr:pair .x|70|73))) (cons (def.lhs (let ((.x|74|77 .y1|54|55|66)) (begin (.check! (pair? .x|74|77) 0 .x|74|77) (car:pair .x|74|77)))) .results|54|58|66)))))) (.loop|59|62|65 .defs|10 '())))))) (.fdefs|19 (apply-union (let () (let ((.loop|34|37|40 (unspecified))) (begin (set! .loop|34|37|40 (lambda (.y1|29|30|41 .results|29|33|41) (if (null? .y1|29|30|41) (reverse .results|29|33|41) (begin #t (.loop|34|37|40 (let ((.x|45|48 .y1|29|30|41)) (begin (.check! (pair? .x|45|48) 1 .x|45|48) (cdr:pair .x|45|48))) (cons (let ((.def|49 (let ((.x|50|53 .y1|29|30|41)) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53))))) (.free|4 (def.rhs .def|49))) .results|29|33|41)))))) (.loop|34|37|40 .defs|10 '())))))) (.fbody|22 (.free|4 (lambda.body .exp|5))) (.f|25 (.union2|4 .fdefs|19 .fbody|22))) (let () (begin (lambda.f-set! .exp|5 (.set->list|4 .f|25)) (lambda.g-set! .exp|5 (.set->list|4 .f|25)) (difference .f|25 (.union2|4 .formals|13 .defined|16))))) (if (assignment? .exp|5) (.union2|4 (make-set (cons (assignment.lhs .exp|5) '())) (.free|4 (assignment.rhs .exp|5))) (if (conditional? .exp|5) (.union3|4 (.free|4 (if.test .exp|5)) (.free|4 (if.then .exp|5)) (.free|4 (if.else .exp|5))) (if (begin? .exp|5) (apply-union (let () (let ((.loop|87|90|93 (unspecified))) (begin (set! .loop|87|90|93 (lambda (.y1|82|83|94 .results|82|86|94) (if (null? .y1|82|83|94) (reverse .results|82|86|94) (begin #t (.loop|87|90|93 (let ((.x|98|101 .y1|82|83|94)) (begin (.check! (pair? .x|98|101) 1 .x|98|101) (cdr:pair .x|98|101))) (cons (let ((.exp|102 (let ((.x|103|106 .y1|82|83|94)) (begin (.check! (pair? .x|103|106) 0 .x|103|106) (car:pair .x|103|106))))) (.free|4 .exp|102)) .results|82|86|94)))))) (.loop|87|90|93 (begin.exprs .exp|5) '()))))) (if (variable? .exp|5) (.singleton|4 (variable.name .exp|5)) (if (call? .exp|5) (.union2|4 (.free|4 (call.proc .exp|5)) (apply-union (let () (let ((.loop|114|117|120 (unspecified))) (begin (set! .loop|114|117|120 (lambda (.y1|109|110|121 .results|109|113|121) (if (null? .y1|109|110|121) (reverse .results|109|113|121) (begin #t (.loop|114|117|120 (let ((.x|125|128 .y1|109|110|121)) (begin (.check! (pair? .x|125|128) 1 .x|125|128) (cdr:pair .x|125|128))) (cons (let ((.exp|129 (let ((.x|130|133 .y1|109|110|121)) (begin (.check! (pair? .x|130|133) 0 .x|130|133) (car:pair .x|130|133))))) (.free|4 .exp|129)) .results|109|113|121)))))) (.loop|114|117|120 (call.args .exp|5) '())))))) ???))))))))) (set! .set->list|4 (lambda (.set|135) .set|135)) (set! .union3|4 (lambda (.x|136 .y|136 .z|136) (union .x|136 .y|136 .z|136))) (set! .union2|4 (lambda (.x|137 .y|137) (union .x|137 .y|137))) (set! .singleton|4 (lambda (.x|138) (cons .x|138 '()))) (set! .empty-set|4 (make-set '())) (.free|4 .exp|3))))) (.compute-free-variables!|2 .exp|1))))) 'compute-free-variables!))
(let () (begin '(define (compute-free-variables! exp) (define empty-set (make-hashtree symbol-hash assq)) (define (singleton x) (hashtree-put empty-set x #t)) (define (make-set values) (if (null? values) empty-set (hashtree-put (make-set (cdr values)) (car values) #t))) (define (union2 x y) (hashtree-for-each (lambda (key val) (set! x (hashtree-put x key #t))) y) x) (define (union3 x y z) (union2 (union2 x y) z)) (define (apply-union sets) (cond ((null? sets) (make-set '())) ((null? (cdr sets)) (car sets)) (else (union2 (car sets) (apply-union (cdr sets)))))) (define (difference x y) (hashtree-for-each (lambda (key val) (set! x (hashtree-remove x key))) y) x) (define (set->list set) (hashtree-map (lambda (sym val) sym) set)) (define (free exp) (cond ((constant? exp) empty-set) ((lambda? exp) (let* ((defs (lambda.defs exp)) (formals (make-set (make-null-terminated (lambda.args exp)))) (defined (make-set (map def.lhs defs))) (fdefs (apply-union (map (lambda (def) (free (def.rhs def))) defs))) (fbody (free (lambda.body exp))) (f (union2 fdefs fbody))) (lambda.f-set! exp (set->list f)) (lambda.g-set! exp (set->list f)) (difference f (union2 formals defined)))) ((assignment? exp) (union2 (make-set (list (assignment.lhs exp))) (free (assignment.rhs exp)))) ((conditional? exp) (union3 (free (if.test exp)) (free (if.then exp)) (free (if.else exp)))) ((begin? exp) (apply-union (map (lambda (exp) (free exp)) (begin.exprs exp)))) ((variable? exp) (singleton (variable.name exp))) ((call? exp) (union2 (free (call.proc exp)) (apply-union (map (lambda (exp) (free exp)) (call.args exp))))) (else ???))) (hashtree-map (lambda (sym val) sym) (free exp))) #t))
(let () ($$trace "pass1"))
(let () (begin (set! source-file-name #f) 'source-file-name))
(let () (begin (set! source-file-position #f) 'source-file-position))
(let () (begin (set! pass1-block-compiling? #f) 'pass1-block-compiling?))
(let () (begin (set! pass1-block-assignments '()) 'pass1-block-assignments))
(let () (begin (set! pass1-block-inlines '()) 'pass1-block-inlines))
(let () (begin (set! pass1 (lambda (.def-or-exp|1 . .rest|1) (begin (set! source-file-name #f) (set! source-file-position #f) (set! pass1-block-compiling? #f) (set! pass1-block-assignments '()) (set! pass1-block-inlines '()) (if (not (null? .rest|1)) (begin (set! source-file-name (let ((.x|2|5 .rest|1)) (begin (.check! (pair? .x|2|5) 0 .x|2|5) (car:pair .x|2|5)))) (if (not (null? (let ((.x|6|9 .rest|1)) (begin (.check! (pair? .x|6|9) 1 .x|6|9) (cdr:pair .x|6|9))))) (set! source-file-position (let ((.x|11|14 (let ((.x|15|18 .rest|1)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))))) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14)))) (unspecified))) (unspecified)) (set! renaming-counter 0) (macro-expand .def-or-exp|1)))) 'pass1))
(let () (begin (set! pass1-block (lambda (.forms|1 . .rest|1) (let ((.part3|2 (unspecified)) (.part2|2 (unspecified)) (.part1|2 (unspecified))) (begin (set! .part3|2 (lambda (.alist|3 .definitions0|3 .definitions1|3 .forms|3) (begin (set! pass1-block-compiling? #f) (set! pass1-block-assignments '()) (set! pass1-block-inlines '()) (let* ((.constnames0|6 (let () (let ((.loop|211|214|217 (unspecified))) (begin (set! .loop|211|214|217 (lambda (.y1|206|207|218 .results|206|210|218) (if (null? .y1|206|207|218) (reverse .results|206|210|218) (begin #t (.loop|211|214|217 (let ((.x|222|225 .y1|206|207|218)) (begin (.check! (pair? .x|222|225) 1 .x|222|225) (cdr:pair .x|222|225))) (cons (assignment.lhs (let ((.x|226|229 .y1|206|207|218)) (begin (.check! (pair? .x|226|229) 0 .x|226|229) (car:pair .x|226|229)))) .results|206|210|218)))))) (.loop|211|214|217 .definitions0|3 '()))))) (.constnames1|9 (let () (let ((.loop|182|185|188 (unspecified))) (begin (set! .loop|182|185|188 (lambda (.y1|177|178|189 .results|177|181|189) (if (null? .y1|177|178|189) (reverse .results|177|181|189) (begin #t (.loop|182|185|188 (let ((.x|193|196 .y1|177|178|189)) (begin (.check! (pair? .x|193|196) 1 .x|193|196) (cdr:pair .x|193|196))) (cons (let* ((.id0|197 (let ((.x|202|205 .y1|177|178|189)) (begin (.check! (pair? .x|202|205) 0 .x|202|205) (car:pair .x|202|205)))) (.x|198|201 (assq .id0|197 .alist|3))) (begin (.check! (pair? .x|198|201) 1 .x|198|201) (cdr:pair .x|198|201))) .results|177|181|189)))))) (.loop|182|185|188 .constnames0|6 '()))))) (.procnames1|12 (let () (let ((.loop|158|161|164 (unspecified))) (begin (set! .loop|158|161|164 (lambda (.y1|153|154|165 .results|153|157|165) (if (null? .y1|153|154|165) (reverse .results|153|157|165) (begin #t (.loop|158|161|164 (let ((.x|169|172 .y1|153|154|165)) (begin (.check! (pair? .x|169|172) 1 .x|169|172) (cdr:pair .x|169|172))) (cons (assignment.lhs (let ((.x|173|176 .y1|153|154|165)) (begin (.check! (pair? .x|173|176) 0 .x|173|176) (car:pair .x|173|176)))) .results|153|157|165)))))) (.loop|158|161|164 .definitions1|3 '())))))) (let () (copy-exp (make-call (make-lambda .constnames1|9 '() '() '() '() '() #f (make-begin (let* ((.t1|16|19 (make-begin (cons (make-constant #f) (reverse (let () (let ((.loop|105|108|111 (unspecified))) (begin (set! .loop|105|108|111 (lambda (.y1|100|101|112 .results|100|104|112) (if (null? .y1|100|101|112) (reverse .results|100|104|112) (begin #t (.loop|105|108|111 (let ((.x|116|119 .y1|100|101|112)) (begin (.check! (pair? .x|116|119) 1 .x|116|119) (cdr:pair .x|116|119))) (cons (let ((.id|120 (let ((.x|125|128 .y1|100|101|112)) (begin (.check! (pair? .x|125|128) 0 .x|125|128) (car:pair .x|125|128))))) (make-assignment .id|120 (make-variable (let ((.x|121|124 (assq .id|120 .alist|3))) (begin (.check! (pair? .x|121|124) 1 .x|121|124) (cdr:pair .x|121|124)))))) .results|100|104|112)))))) (.loop|105|108|111 .constnames0|6 '())))))))) (.t2|16|22 (cons (make-call (make-lambda .constnames0|6 '() '() '() '() '() #f (make-call (make-lambda (let () (let ((.loop|32|35|38 (unspecified))) (begin (set! .loop|32|35|38 (lambda (.y1|27|28|39 .results|27|31|39) (if (null? .y1|27|28|39) (reverse .results|27|31|39) (begin #t (.loop|32|35|38 (let ((.x|43|46 .y1|27|28|39)) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46))) (cons (assignment.lhs (let ((.x|47|50 .y1|27|28|39)) (begin (.check! (pair? .x|47|50) 0 .x|47|50) (car:pair .x|47|50)))) .results|27|31|39)))))) (.loop|32|35|38 .definitions1|3 '())))) '() '() '() '() '() #f (make-begin (cons (make-constant #f) (append .definitions1|3 .forms|3)))) (let () (let ((.loop|56|59|62 (unspecified))) (begin (set! .loop|56|59|62 (lambda (.y1|51|52|63 .results|51|55|63) (if (null? .y1|51|52|63) (reverse .results|51|55|63) (begin #t (.loop|56|59|62 (let ((.x|67|70 .y1|51|52|63)) (begin (.check! (pair? .x|67|70) 1 .x|67|70) (cdr:pair .x|67|70))) (cons (let ((.ignored|71 (let ((.x|72|75 .y1|51|52|63)) (begin (.check! (pair? .x|72|75) 0 .x|72|75) (car:pair .x|72|75))))) (make-unspecified)) .results|51|55|63)))))) (.loop|56|59|62 .definitions1|3 '())))))) (let () (let ((.loop|81|84|87 (unspecified))) (begin (set! .loop|81|84|87 (lambda (.y1|76|77|88 .results|76|80|88) (if (null? .y1|76|77|88) (reverse .results|76|80|88) (begin #t (.loop|81|84|87 (let ((.x|92|95 .y1|76|77|88)) (begin (.check! (pair? .x|92|95) 1 .x|92|95) (cdr:pair .x|92|95))) (cons (make-variable (let ((.x|96|99 .y1|76|77|88)) (begin (.check! (pair? .x|96|99) 0 .x|96|99) (car:pair .x|96|99)))) .results|76|80|88)))))) (.loop|81|84|87 .constnames1|9 '()))))) '()))) (let () (cons .t1|16|19 .t2|16|22))))) (let () (let ((.loop|134|137|140 (unspecified))) (begin (set! .loop|134|137|140 (lambda (.y1|129|130|141 .results|129|133|141) (if (null? .y1|129|130|141) (reverse .results|129|133|141) (begin #t (.loop|134|137|140 (let ((.x|145|148 .y1|129|130|141)) (begin (.check! (pair? .x|145|148) 1 .x|145|148) (cdr:pair .x|145|148))) (cons (assignment.rhs (let ((.x|149|152 .y1|129|130|141)) (begin (.check! (pair? .x|149|152) 0 .x|149|152) (car:pair .x|149|152)))) .results|129|133|141)))))) (.loop|134|137|140 .definitions0|3 '()))))))))))) (set! .part2|2 (lambda (.defined|230) (begin (set! pass1-block-compiling? #f) (set! pass1-block-assignments '()) (set! pass1-block-inlines '()) (set! renaming-counter 0) (let* ((.rename|233 (make-rename-procedure)) (.alist|236 (let () (let ((.loop|354|357|360 (unspecified))) (begin (set! .loop|354|357|360 (lambda (.y1|349|350|361 .results|349|353|361) (if (null? .y1|349|350|361) (reverse .results|349|353|361) (begin #t (.loop|354|357|360 (let ((.x|365|368 .y1|349|350|361)) (begin (.check! (pair? .x|365|368) 1 .x|365|368) (cdr:pair .x|365|368))) (cons (let ((.id|369 (let ((.x|370|373 .y1|349|350|361)) (begin (.check! (pair? .x|370|373) 0 .x|370|373) (car:pair .x|370|373))))) (cons .id|369 (.rename|233 .id|369))) .results|349|353|361)))))) (.loop|354|357|360 .defined|230 '()))))) (.definitions0|239 '()) (.definitions1|242 '())) (let () (let ((.make-toplevel-definition|248 (unspecified))) (begin (set! .make-toplevel-definition|248 (lambda (.id|249 .exp|249) (begin (if (lambda? .exp|249) (doc.name-set! (lambda.doc .exp|249) .id|249) (unspecified)) (let ((.probe|252 (assq .id|249 .alist|236))) (if .probe|252 (let ((.id1|255 (let ((.x|283|286 .probe|252)) (begin (.check! (pair? .x|283|286) 1 .x|283|286) (cdr:pair .x|283|286))))) (if (constant? .exp|249) (begin (set! .definitions0|239 (cons (make-assignment .id|249 .exp|249) .definitions0|239)) (make-constant .id|249)) (if (lambda? .exp|249) (begin (set! .definitions1|242 (cons (make-assignment .id1|255 .exp|249) .definitions1|242)) (make-assignment .id|249 (make-lambda (lambda.args .exp|249) '() '() '() '() '() (lambda.doc .exp|249) (make-call (make-variable .id1|255) (let () (let ((.loop|263|266|269 (unspecified))) (begin (set! .loop|263|266|269 (lambda (.y1|258|259|270 .results|258|262|270) (if (null? .y1|258|259|270) (reverse .results|258|262|270) (begin #t (.loop|263|266|269 (let ((.x|274|277 .y1|258|259|270)) (begin (.check! (pair? .x|274|277) 1 .x|274|277) (cdr:pair .x|274|277))) (cons (make-variable (let ((.x|278|281 .y1|258|259|270)) (begin (.check! (pair? .x|278|281) 0 .x|278|281) (car:pair .x|278|281)))) .results|258|262|270)))))) (.loop|263|266|269 (lambda.args .exp|249) '())))))))) (m-error "Inconsistent macro expansion" (make-readable .exp|249))))) (make-assignment .id|249 .exp|249)))))) (let ((.env0|287 (syntactic-copy global-syntactic-environment)) (.bmode|287 (benchmark-mode)) (.wmode|287 (issue-warnings))) (begin (issue-warnings #f) (let () (let ((.loop|293|295|298 (unspecified))) (begin (set! .loop|293|295|298 (lambda (.y1|288|289|299) (if (null? .y1|288|289|299) (if #f #f (unspecified)) (begin (begin #t (let ((.pair|303 (let ((.x|320|323 .y1|288|289|299)) (begin (.check! (pair? .x|320|323) 0 .x|320|323) (car:pair .x|320|323))))) (let ((.id0|306 (let ((.x|312|315 .pair|303)) (begin (.check! (pair? .x|312|315) 0 .x|312|315) (car:pair .x|312|315)))) (.id1|306 (let ((.x|316|319 .pair|303)) (begin (.check! (pair? .x|316|319) 1 .x|316|319) (cdr:pair .x|316|319))))) (begin (syntactic-bind-globally! .id0|306 (make-inline-denotation .id0|306 (lambda (.exp|307 .rename|307 .compare|307) (cons .id1|306 (let ((.x|308|311 .exp|307)) (begin (.check! (pair? .x|308|311) 1 .x|308|311) (cdr:pair .x|308|311))))) global-syntactic-environment)) (set! pass1-block-inlines (cons .id0|306 pass1-block-inlines)))))) (.loop|293|295|298 (let ((.x|324|327 .y1|288|289|299)) (begin (.check! (pair? .x|324|327) 1 .x|324|327) (cdr:pair .x|324|327)))))))) (.loop|293|295|298 .alist|236)))) (benchmark-mode #f) (issue-warnings .wmode|287) (let ((.forms|330 (let () (let ((.loop|331|334|337 (unspecified))) (begin (set! .loop|331|334|337 (lambda (.forms|338 .newforms|338) (if (null? .forms|338) (reverse .newforms|338) (begin #t (.loop|331|334|337 (let ((.x|341|344 .forms|338)) (begin (.check! (pair? .x|341|344) 1 .x|341|344) (cdr:pair .x|341|344))) (cons (desugar-definitions (let ((.x|345|348 .forms|338)) (begin (.check! (pair? .x|345|348) 0 .x|345|348) (car:pair .x|345|348))) global-syntactic-environment .make-toplevel-definition|248) .newforms|338)))))) (.loop|331|334|337 .forms|1 '())))))) (begin (benchmark-mode .bmode|287) (set! global-syntactic-environment .env0|287) (.part3|2 .alist|236 .definitions0|239 .definitions1|242 .forms|330)))))))))))) (set! .part1|2 (lambda () (begin (set! pass1-block-compiling? #t) (set! pass1-block-assignments '()) (set! pass1-block-inlines '()) (set! renaming-counter 0) (let ((.env0|377 (syntactic-copy global-syntactic-environment)) (.bmode|377 (benchmark-mode)) (.wmode|377 (issue-warnings)) (.defined|377 '())) (let ((.make-toplevel-definition|378 (unspecified))) (begin (set! .make-toplevel-definition|378 (lambda (.id|379 .exp|379) (begin (if (memq .id|379 .defined|377) (set! pass1-block-assignments (cons .id|379 pass1-block-assignments)) (if (let ((.temp|382|385 (constant? .exp|379))) (if .temp|382|385 .temp|382|385 (if (lambda? .exp|379) (list? (lambda.args .exp|379)) #f))) (set! .defined|377 (cons .id|379 .defined|377)) (unspecified))) (make-begin (let* ((.t1|389|392 (make-assignment .id|379 .exp|379)) (.t2|389|395 (cons (make-constant .id|379) '()))) (let () (cons .t1|389|392 .t2|389|395))))))) (benchmark-mode #f) (issue-warnings #f) (let () (let ((.loop|405|407|410 (unspecified))) (begin (set! .loop|405|407|410 (lambda (.y1|400|401|411) (if (null? .y1|400|401|411) (if #f #f (unspecified)) (begin (begin #t (let ((.form|415 (let ((.x|416|419 .y1|400|401|411)) (begin (.check! (pair? .x|416|419) 0 .x|416|419) (car:pair .x|416|419))))) (desugar-definitions .form|415 global-syntactic-environment .make-toplevel-definition|378))) (.loop|405|407|410 (let ((.x|420|423 .y1|400|401|411)) (begin (.check! (pair? .x|420|423) 1 .x|420|423) (cdr:pair .x|420|423)))))))) (.loop|405|407|410 .forms|1)))) (set! global-syntactic-environment .env0|377) (benchmark-mode .bmode|377) (issue-warnings .wmode|377) (.part2|2 (filter (lambda (.id|424) (not (memq .id|424 pass1-block-assignments))) (reverse .defined|377))))))))) (set! source-file-name #f) (set! source-file-position #f) (if (not (null? .rest|1)) (begin (set! source-file-name (let ((.x|425|428 .rest|1)) (begin (.check! (pair? .x|425|428) 0 .x|425|428) (car:pair .x|425|428)))) (if (not (null? (let ((.x|429|432 .rest|1)) (begin (.check! (pair? .x|429|432) 1 .x|429|432) (cdr:pair .x|429|432))))) (set! source-file-position (let ((.x|434|437 (let ((.x|438|441 .rest|1)) (begin (.check! (pair? .x|438|441) 1 .x|438|441) (cdr:pair .x|438|441))))) (begin (.check! (pair? .x|434|437) 0 .x|434|437) (car:pair .x|434|437)))) (unspecified))) (unspecified)) (.part1|2))))) 'pass1-block))
(let () (begin (set! make-available-table (lambda () (let ((.make-available-table|2 0)) (begin (set! .make-available-table|2 (lambda () (let* ((.t|4|6|11 '()) (.t|4|5|14 '()) (.v|4|8|17 (make-vector 2 .t|4|6|11))) (let () (begin (let ((.v|21|24 .v|4|8|17) (.i|21|24 0) (.x|21|24 .t|4|5|14)) (begin (.check! (fixnum? .i|21|24) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (vector? .v|21|24) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (<:fix:fix .i|21|24 (vector-length:vec .v|21|24)) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (>=:fix:fix .i|21|24 0) 41 .v|21|24 .i|21|24 .x|21|24) (vector-set!:trusted .v|21|24 .i|21|24 .x|21|24))) .v|4|8|17))))) (.make-available-table|2))))) 'make-available-table))
(let () (begin (set! copy-available-table (lambda (.available|1) (let ((.copy-available-table|2 0)) (begin (set! .copy-available-table|2 (lambda (.available|3) (let* ((.t|4|6|11 (let ((.v|29|32 .available|3) (.i|29|32 1)) (begin (.check! (fixnum? .i|29|32) 40 .v|29|32 .i|29|32) (.check! (vector? .v|29|32) 40 .v|29|32 .i|29|32) (.check! (<:fix:fix .i|29|32 (vector-length:vec .v|29|32)) 40 .v|29|32 .i|29|32) (.check! (>=:fix:fix .i|29|32 0) 40 .v|29|32 .i|29|32) (vector-ref:trusted .v|29|32 .i|29|32)))) (.t|4|5|14 (let ((.v|25|28 .available|3) (.i|25|28 0)) (begin (.check! (fixnum? .i|25|28) 40 .v|25|28 .i|25|28) (.check! (vector? .v|25|28) 40 .v|25|28 .i|25|28) (.check! (<:fix:fix .i|25|28 (vector-length:vec .v|25|28)) 40 .v|25|28 .i|25|28) (.check! (>=:fix:fix .i|25|28 0) 40 .v|25|28 .i|25|28) (vector-ref:trusted .v|25|28 .i|25|28)))) (.v|4|8|17 (make-vector 2 .t|4|6|11))) (let () (begin (let ((.v|21|24 .v|4|8|17) (.i|21|24 0) (.x|21|24 .t|4|5|14)) (begin (.check! (fixnum? .i|21|24) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (vector? .v|21|24) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (<:fix:fix .i|21|24 (vector-length:vec .v|21|24)) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (>=:fix:fix .i|21|24 0) 41 .v|21|24 .i|21|24 .x|21|24) (vector-set!:trusted .v|21|24 .i|21|24 .x|21|24))) .v|4|8|17))))) (.copy-available-table|2 .available|1))))) 'copy-available-table))
(let () (begin (set! available-expression (lambda (.available|1 .e|1) (let ((.available-expression|2 0)) (begin (set! .available-expression|2 (lambda (.available|3 .e|3) (let ((.binding|6 (assoc .e|3 (let ((.v|16|19 .available|3) (.i|16|19 0)) (begin (.check! (fixnum? .i|16|19) 40 .v|16|19 .i|16|19) (.check! (vector? .v|16|19) 40 .v|16|19 .i|16|19) (.check! (<:fix:fix .i|16|19 (vector-length:vec .v|16|19)) 40 .v|16|19 .i|16|19) (.check! (>=:fix:fix .i|16|19 0) 40 .v|16|19 .i|16|19) (vector-ref:trusted .v|16|19 .i|16|19)))))) (if .binding|6 (let ((.x|8|11 (let ((.x|12|15 .binding|6)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))))) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) #f)))) (.available-expression|2 .available|1 .e|1))))) 'available-expression))
(let () (begin (set! available-variable (lambda (.available|1 .t|1) (let ((.available-variable|2 0)) (begin (set! .available-variable|2 (lambda (.available|3 .t|3) (let ((.binding|6 (assq .t|3 (let ((.v|16|19 .available|3) (.i|16|19 1)) (begin (.check! (fixnum? .i|16|19) 40 .v|16|19 .i|16|19) (.check! (vector? .v|16|19) 40 .v|16|19 .i|16|19) (.check! (<:fix:fix .i|16|19 (vector-length:vec .v|16|19)) 40 .v|16|19 .i|16|19) (.check! (>=:fix:fix .i|16|19 0) 40 .v|16|19 .i|16|19) (vector-ref:trusted .v|16|19 .i|16|19)))))) (if .binding|6 (let ((.x|8|11 (let ((.x|12|15 .binding|6)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))))) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) #f)))) (.available-variable|2 .available|1 .t|1))))) 'available-variable))
(let () (begin (set! available-extend! (lambda (.available|1 .t|1 .e|1 .k|1) (let ((.available-extend!|2 0)) (begin (set! .available-extend!|2 (lambda (.available|3 .t|3 .e|3 .k|3) (if (constant? .e|3) (let ((.v|5|8 .available|3) (.i|5|8 1) (.x|5|8 (cons (let* ((.t1|9|12 .t|3) (.t2|9|15 (let* ((.t1|19|22 .e|3) (.t2|19|25 (cons .k|3 '()))) (let () (cons .t1|19|22 .t2|19|25))))) (let () (cons .t1|9|12 .t2|9|15))) (let ((.v|30|33 .available|3) (.i|30|33 1)) (begin (.check! (fixnum? .i|30|33) 40 .v|30|33 .i|30|33) (.check! (vector? .v|30|33) 40 .v|30|33 .i|30|33) (.check! (<:fix:fix .i|30|33 (vector-length:vec .v|30|33)) 40 .v|30|33 .i|30|33) (.check! (>=:fix:fix .i|30|33 0) 40 .v|30|33 .i|30|33) (vector-ref:trusted .v|30|33 .i|30|33)))))) (begin (.check! (fixnum? .i|5|8) 41 .v|5|8 .i|5|8 .x|5|8) (.check! (vector? .v|5|8) 41 .v|5|8 .i|5|8 .x|5|8) (.check! (<:fix:fix .i|5|8 (vector-length:vec .v|5|8)) 41 .v|5|8 .i|5|8 .x|5|8) (.check! (>=:fix:fix .i|5|8 0) 41 .v|5|8 .i|5|8 .x|5|8) (vector-set!:trusted .v|5|8 .i|5|8 .x|5|8))) (if (if (variable? .e|3) (eq? .k|3 available:killer:none) #f) (let ((.v|37|40 .available|3) (.i|37|40 1) (.x|37|40 (cons (let* ((.t1|41|44 .t|3) (.t2|41|47 (let* ((.t1|51|54 .e|3) (.t2|51|57 (cons .k|3 '()))) (let () (cons .t1|51|54 .t2|51|57))))) (let () (cons .t1|41|44 .t2|41|47))) (let ((.v|62|65 .available|3) (.i|62|65 1)) (begin (.check! (fixnum? .i|62|65) 40 .v|62|65 .i|62|65) (.check! (vector? .v|62|65) 40 .v|62|65 .i|62|65) (.check! (<:fix:fix .i|62|65 (vector-length:vec .v|62|65)) 40 .v|62|65 .i|62|65) (.check! (>=:fix:fix .i|62|65 0) 40 .v|62|65 .i|62|65) (vector-ref:trusted .v|62|65 .i|62|65)))))) (begin (.check! (fixnum? .i|37|40) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (vector? .v|37|40) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (<:fix:fix .i|37|40 (vector-length:vec .v|37|40)) 41 .v|37|40 .i|37|40 .x|37|40) (.check! (>=:fix:fix .i|37|40 0) 41 .v|37|40 .i|37|40 .x|37|40) (vector-set!:trusted .v|37|40 .i|37|40 .x|37|40))) (let ((.v|67|70 .available|3) (.i|67|70 0) (.x|67|70 (cons (let* ((.t1|71|74 .e|3) (.t2|71|77 (let* ((.t1|81|84 .t|3) (.t2|81|87 (cons .k|3 '()))) (let () (cons .t1|81|84 .t2|81|87))))) (let () (cons .t1|71|74 .t2|71|77))) (let ((.v|92|95 .available|3) (.i|92|95 0)) (begin (.check! (fixnum? .i|92|95) 40 .v|92|95 .i|92|95) (.check! (vector? .v|92|95) 40 .v|92|95 .i|92|95) (.check! (<:fix:fix .i|92|95 (vector-length:vec .v|92|95)) 40 .v|92|95 .i|92|95) (.check! (>=:fix:fix .i|92|95 0) 40 .v|92|95 .i|92|95) (vector-ref:trusted .v|92|95 .i|92|95)))))) (begin (.check! (fixnum? .i|67|70) 41 .v|67|70 .i|67|70 .x|67|70) (.check! (vector? .v|67|70) 41 .v|67|70 .i|67|70 .x|67|70) (.check! (<:fix:fix .i|67|70 (vector-length:vec .v|67|70)) 41 .v|67|70 .i|67|70 .x|67|70) (.check! (>=:fix:fix .i|67|70 0) 41 .v|67|70 .i|67|70 .x|67|70) (vector-set!:trusted .v|67|70 .i|67|70 .x|67|70))))))) (.available-extend!|2 .available|1 .t|1 .e|1 .k|1))))) 'available-extend!))
(let () (begin (set! available-kill! (lambda (.available|1 .k|1) (let ((.available-kill!|2 0)) (begin (set! .available-kill!|2 (lambda (.available|3 .k|3) (begin (let ((.v|4|7 .available|3) (.i|4|7 0) (.x|4|7 (filter (lambda (.binding|8) (zero? (logand .k|3 (let ((.x|10|13 (let ((.x|14|17 (let ((.x|18|21 .binding|8)) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21))))) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))))) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13)))))) (let ((.v|22|25 .available|3) (.i|22|25 0)) (begin (.check! (fixnum? .i|22|25) 40 .v|22|25 .i|22|25) (.check! (vector? .v|22|25) 40 .v|22|25 .i|22|25) (.check! (<:fix:fix .i|22|25 (vector-length:vec .v|22|25)) 40 .v|22|25 .i|22|25) (.check! (>=:fix:fix .i|22|25 0) 40 .v|22|25 .i|22|25) (vector-ref:trusted .v|22|25 .i|22|25)))))) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))) (let ((.v|26|29 .available|3) (.i|26|29 1) (.x|26|29 (filter (lambda (.binding|30) (zero? (logand .k|3 (let ((.x|32|35 (let ((.x|36|39 (let ((.x|40|43 .binding|30)) (begin (.check! (pair? .x|40|43) 1 .x|40|43) (cdr:pair .x|40|43))))) (begin (.check! (pair? .x|36|39) 1 .x|36|39) (cdr:pair .x|36|39))))) (begin (.check! (pair? .x|32|35) 0 .x|32|35) (car:pair .x|32|35)))))) (let ((.v|44|47 .available|3) (.i|44|47 1)) (begin (.check! (fixnum? .i|44|47) 40 .v|44|47 .i|44|47) (.check! (vector? .v|44|47) 40 .v|44|47 .i|44|47) (.check! (<:fix:fix .i|44|47 (vector-length:vec .v|44|47)) 40 .v|44|47 .i|44|47) (.check! (>=:fix:fix .i|44|47 0) 40 .v|44|47 .i|44|47) (vector-ref:trusted .v|44|47 .i|44|47)))))) (begin (.check! (fixnum? .i|26|29) 41 .v|26|29 .i|26|29 .x|26|29) (.check! (vector? .v|26|29) 41 .v|26|29 .i|26|29 .x|26|29) (.check! (<:fix:fix .i|26|29 (vector-length:vec .v|26|29)) 41 .v|26|29 .i|26|29 .x|26|29) (.check! (>=:fix:fix .i|26|29 0) 41 .v|26|29 .i|26|29 .x|26|29) (vector-set!:trusted .v|26|29 .i|26|29 .x|26|29)))))) (.available-kill!|2 .available|1 .k|1))))) 'available-kill!))
(let () (begin (set! available-intersect! (lambda (.available0|1 .available1|1 .available2|1) (let ((.available-intersect!|2 0)) (begin (set! .available-intersect!|2 (lambda (.available0|3 .available1|3 .available2|3) (begin (let ((.v|4|7 .available0|3) (.i|4|7 0) (.x|4|7 (intersection (let ((.v|8|11 .available1|3) (.i|8|11 0)) (begin (.check! (fixnum? .i|8|11) 40 .v|8|11 .i|8|11) (.check! (vector? .v|8|11) 40 .v|8|11 .i|8|11) (.check! (<:fix:fix .i|8|11 (vector-length:vec .v|8|11)) 40 .v|8|11 .i|8|11) (.check! (>=:fix:fix .i|8|11 0) 40 .v|8|11 .i|8|11) (vector-ref:trusted .v|8|11 .i|8|11))) (let ((.v|12|15 .available2|3) (.i|12|15 0)) (begin (.check! (fixnum? .i|12|15) 40 .v|12|15 .i|12|15) (.check! (vector? .v|12|15) 40 .v|12|15 .i|12|15) (.check! (<:fix:fix .i|12|15 (vector-length:vec .v|12|15)) 40 .v|12|15 .i|12|15) (.check! (>=:fix:fix .i|12|15 0) 40 .v|12|15 .i|12|15) (vector-ref:trusted .v|12|15 .i|12|15)))))) (begin (.check! (fixnum? .i|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (vector? .v|4|7) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (<:fix:fix .i|4|7 (vector-length:vec .v|4|7)) 41 .v|4|7 .i|4|7 .x|4|7) (.check! (>=:fix:fix .i|4|7 0) 41 .v|4|7 .i|4|7 .x|4|7) (vector-set!:trusted .v|4|7 .i|4|7 .x|4|7))) (let ((.v|16|19 .available0|3) (.i|16|19 1) (.x|16|19 (intersection (let ((.v|20|23 .available1|3) (.i|20|23 1)) (begin (.check! (fixnum? .i|20|23) 40 .v|20|23 .i|20|23) (.check! (vector? .v|20|23) 40 .v|20|23 .i|20|23) (.check! (<:fix:fix .i|20|23 (vector-length:vec .v|20|23)) 40 .v|20|23 .i|20|23) (.check! (>=:fix:fix .i|20|23 0) 40 .v|20|23 .i|20|23) (vector-ref:trusted .v|20|23 .i|20|23))) (let ((.v|24|27 .available2|3) (.i|24|27 1)) (begin (.check! (fixnum? .i|24|27) 40 .v|24|27 .i|24|27) (.check! (vector? .v|24|27) 40 .v|24|27 .i|24|27) (.check! (<:fix:fix .i|24|27 (vector-length:vec .v|24|27)) 40 .v|24|27 .i|24|27) (.check! (>=:fix:fix .i|24|27 0) 40 .v|24|27 .i|24|27) (vector-ref:trusted .v|24|27 .i|24|27)))))) (begin (.check! (fixnum? .i|16|19) 41 .v|16|19 .i|16|19 .x|16|19) (.check! (vector? .v|16|19) 41 .v|16|19 .i|16|19 .x|16|19) (.check! (<:fix:fix .i|16|19 (vector-length:vec .v|16|19)) 41 .v|16|19 .i|16|19 .x|16|19) (.check! (>=:fix:fix .i|16|19 0) 41 .v|16|19 .i|16|19 .x|16|19) (vector-set!:trusted .v|16|19 .i|16|19 .x|16|19)))))) (.available-intersect!|2 .available0|1 .available1|1 .available2|1))))) 'available-intersect!))
(let () (begin (set! available:killer:globals 2) 'available:killer:globals))
(let () (begin (set! available:killer:car 4) 'available:killer:car))
(let () (begin (set! available:killer:cdr 8) 'available:killer:cdr))
(let () (begin (set! available:killer:string 16) 'available:killer:string))
(let () (begin (set! available:killer:vector 32) 'available:killer:vector))
(let () (begin (set! available:killer:cell 64) 'available:killer:cell))
(let () (begin (set! available:killer:io 128) 'available:killer:io))
(let () (begin (set! available:killer:none 0) 'available:killer:none))
(let () (begin (set! available:killer:all 1022) 'available:killer:all))
(let () (begin (set! available:killer:immortal 0) 'available:killer:immortal))
(let () (begin (set! available:killer:dead 1023) 'available:killer:dead))
(let () (begin (set! available:killer-combine (lambda (.k1|1 .k2|1) (let ((.available:killer-combine|2 0)) (begin (set! .available:killer-combine|2 (lambda (.k1|3 .k2|3) (logior .k1|3 .k2|3))) (.available:killer-combine|2 .k1|1 .k2|1))))) 'available:killer-combine))
(let () (begin (set! simple-lambda? (lambda (.l|1) (let ((.simple-lambda?|2 0)) (begin (set! .simple-lambda?|2 (lambda (.l|3) (if (null? (lambda.defs .l|3)) (every? (lambda (.decl|6) (eq? .decl|6 a-normal-form-declaration)) (lambda.decls .l|3)) #f))) (.simple-lambda?|2 .l|1))))) 'simple-lambda?))
(let () (begin (set! real-call? (lambda (.e|1) (let ((.real-call?|2 0)) (begin (set! .real-call?|2 (lambda (.e|3) (if (call? .e|3) (let ((.proc|8 (call.proc .e|3))) (if (not (lambda? .proc|8)) (let ((.temp|11|14 (not (variable? .proc|8)))) (if .temp|11|14 .temp|11|14 (let* ((.f|18 (variable.name .proc|8)) (.temp|19|22 (not (integrate-usual-procedures)))) (if .temp|19|22 .temp|19|22 (not (prim-entry .f|18)))))) #f)) #f))) (.real-call?|2 .e|1))))) 'real-call?))
(let () (begin (set! prim-call (lambda (.e|1) (let ((.prim-call|2 0)) (begin (set! .prim-call|2 (lambda (.e|3) (if (call? .e|3) (let ((.proc|8 (call.proc .e|3))) (if (variable? .proc|8) (if (integrate-usual-procedures) (prim-entry (variable.name .proc|8)) #f) #f)) #f))) (.prim-call|2 .e|1))))) 'prim-call))
(let () (begin (set! no-side-effects? (lambda (.e|1) (let ((.no-side-effects?|2 0)) (begin (set! .no-side-effects?|2 (lambda (.e|3) (let ((.temp|4|7 (constant? .e|3))) (if .temp|4|7 .temp|4|7 (let ((.temp|8|11 (variable? .e|3))) (if .temp|8|11 .temp|8|11 (let ((.temp|12|15 (lambda? .e|3))) (if .temp|12|15 .temp|12|15 (let ((.temp|16|19 (if (conditional? .e|3) (if (.no-side-effects?|2 (if.test .e|3)) (if (.no-side-effects?|2 (if.then .e|3)) (.no-side-effects?|2 (if.else .e|3)) #f) #f) #f))) (if .temp|16|19 .temp|16|19 (if (call? .e|3) (let ((.proc|25 (call.proc .e|3))) (if (variable? .proc|25) (if (integrate-usual-procedures) (let ((.entry|31 (prim-entry (variable.name .proc|25)))) (if .entry|31 (not (eq? available:killer:dead (prim-lives-until .entry|31))) #f)) #f) #f)) #f))))))))))) (.no-side-effects?|2 .e|1))))) 'no-side-effects?))
(let () (begin (set! temporary-used-once? (lambda (.t|1 .e|1 .used-once|1) (let ((.temporary-used-once?|2 0)) (begin (set! .temporary-used-once?|2 (lambda (.t|3 .e|3 .used-once|3) (if (call? .e|3) (let ((.proc|7 (call.proc .e|3)) (.args|7 (call.args .e|3))) (let ((.temp|8|11 (if (lambda? .proc|7) (if (not (memq .t|3 (lambda.f .proc|7))) (if (pair? .args|7) (if (null? (let ((.x|47|50 .args|7)) (begin (.check! (pair? .x|47|50) 1 .x|47|50) (cdr:pair .x|47|50)))) (.temporary-used-once?|2 .t|3 (let ((.x|52|55 .args|7)) (begin (.check! (pair? .x|52|55) 0 .x|52|55) (car:pair .x|52|55))) .used-once|3) #f) #f) #f) #f))) (if .temp|8|11 .temp|8|11 (let () (let ((.loop|13|16|19 (unspecified))) (begin (set! .loop|13|16|19 (lambda (.exprs|20 .n|20) (if (let ((.temp|22|25 (null? .exprs|20))) (if .temp|22|25 .temp|22|25 (> .n|20 1))) (= .n|20 1) (begin #t (.loop|13|16|19 (let ((.x|28|31 .exprs|20)) (begin (.check! (pair? .x|28|31) 1 .x|28|31) (cdr:pair .x|28|31))) (let ((.exp|34 (let ((.x|38|41 .exprs|20)) (begin (.check! (pair? .x|38|41) 0 .x|38|41) (car:pair .x|38|41))))) (if (constant? .exp|34) .n|20 (if (variable? .exp|34) (if (eq? .t|3 (variable.name .exp|34)) (+ .n|20 1) .n|20) 2)))))))) (.loop|13|16|19 (cons .proc|7 (call.args .e|3)) 0))))))) (memq .t|3 .used-once|3)))) (.temporary-used-once?|2 .t|1 .e|1 .used-once|1))))) 'temporary-used-once?))
(let () (begin (set! make-regbinding (lambda (.lhs|1 .rhs|1 .use|1) (let ((.make-regbinding|2 0)) (begin (set! .make-regbinding|2 (lambda (.lhs|3 .rhs|3 .use|3) (let* ((.t1|4|7 .lhs|3) (.t2|4|10 (let* ((.t1|14|17 .rhs|3) (.t2|14|20 (cons .use|3 '()))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-regbinding|2 .lhs|1 .rhs|1 .use|1))))) 'make-regbinding))
(let () (begin (set! regbinding.lhs (lambda (.x|1) (let ((.regbinding.lhs|2 0)) (begin (set! .regbinding.lhs|2 (lambda (.x|3) (let ((.x|4|7 .x|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.regbinding.lhs|2 .x|1))))) 'regbinding.lhs))
(let () (begin (set! regbinding.rhs (lambda (.x|1) (let ((.regbinding.rhs|2 0)) (begin (set! .regbinding.rhs|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 .x|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.regbinding.rhs|2 .x|1))))) 'regbinding.rhs))
(let () (begin (set! regbinding.use (lambda (.x|1) (let ((.regbinding.use|2 0)) (begin (set! .regbinding.use|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .x|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.regbinding.use|2 .x|1))))) 'regbinding.use))
(let () (begin (set! wrap-with-register-bindings (lambda (.regbindings|1 .e|1 .f|1) (let ((.wrap-with-register-bindings|2 0)) (begin (set! .wrap-with-register-bindings|2 (lambda (.regbindings|3 .e|3 .f|3) (if (null? .regbindings|3) (values .e|3 .f|3) (let* ((.regbinding|6 (let ((.x|25|28 .regbindings|3)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28)))) (.r|9 (regbinding.lhs .regbinding|6)) (.x|12 (regbinding.rhs .regbinding|6))) (let () (.wrap-with-register-bindings|2 (let ((.x|16|19 .regbindings|3)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19))) (make-call (make-lambda (cons .r|9 '()) '() '() .f|3 .f|3 (cons a-normal-form-declaration '()) #f .e|3) (cons (make-variable .x|12) '())) (union (cons .x|12 '()) (difference .f|3 (cons .r|9 '()))))))))) (.wrap-with-register-bindings|2 .regbindings|1 .e|1 .f|1))))) 'wrap-with-register-bindings))
(let () (begin (set! register-bindings (lambda (.regbindings|1 .x|1) (let ((.register-bindings|2 0)) (begin (set! .register-bindings|2 (lambda (.regbindings|3 .x|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.regbindings|5 .to-x|5 .others|5) (if (null? .regbindings|5) (values .to-x|5 .others|5) (if (eq? .x|3 (regbinding.rhs (let ((.x|8|11 .regbindings|5)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))))) (.loop|4 (let ((.x|12|15 .regbindings|5)) (begin (.check! (pair? .x|12|15) 1 .x|12|15) (cdr:pair .x|12|15))) (cons (let ((.x|16|19 .regbindings|5)) (begin (.check! (pair? .x|16|19) 0 .x|16|19) (car:pair .x|16|19))) .to-x|5) .others|5) (.loop|4 (let ((.x|21|24 .regbindings|5)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))) .to-x|5 (cons (let ((.x|25|28 .regbindings|5)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28))) .others|5)))))) (.loop|4 .regbindings|3 '() '()))))) (.register-bindings|2 .regbindings|1 .x|1))))) 'register-bindings))
(let () (begin (set! declaration-error (lambda (.e|1) (let ((.declaration-error|2 0)) (begin (set! .declaration-error|2 (lambda (.e|3) (if (issue-warnings) (begin (display "WARNING: Assertion is false: ") (write (make-readable .e|3 #t)) (newline)) (unspecified)))) (.declaration-error|2 .e|1))))) 'declaration-error))
(let () (begin (set! *nreps* 0) '*nreps*))
(let () (begin (set! *rep-encodings* '()) '*rep-encodings*))
(let () (begin (set! *rep-decodings* '()) '*rep-decodings*))
(let () (begin (set! *rep-subtypes* '()) '*rep-subtypes*))
(let () (begin (set! *rep-joins* (make-bytevector 0)) '*rep-joins*))
(let () (begin (set! *rep-meets* (make-bytevector 0)) '*rep-meets*))
(let () (begin (set! *rep-joins-special* '#()) '*rep-joins-special*))
(let () (begin (set! *rep-meets-special* '#()) '*rep-meets-special*))
(let () (begin (set! representation-error (lambda (.msg|1 . .stuff|1) (apply error (if (string? .msg|1) (string-append "Bug in flow analysis: " .msg|1) .msg|1) .stuff|1))) 'representation-error))
(let () (begin (set! symbol->rep (lambda (.sym|1) (let ((.symbol->rep|2 0)) (begin (set! .symbol->rep|2 (lambda (.sym|3) (let ((.probe|6 (assq .sym|3 *rep-encodings*))) (if .probe|6 (let ((.x|7|10 .probe|6)) (begin (.check! (pair? .x|7|10) 1 .x|7|10) (cdr:pair .x|7|10))) (let ((.rep|13 *nreps*)) (begin (set! *nreps* (+ *nreps* 1)) (if (> *nreps* 255) (representation-error "Too many representation types") (unspecified)) (set! *rep-encodings* (cons (cons .sym|3 .rep|13) *rep-encodings*)) (set! *rep-decodings* (cons (cons .rep|13 .sym|3) *rep-decodings*)) .rep|13)))))) (.symbol->rep|2 .sym|1))))) 'symbol->rep))
(let () (begin (set! rep->symbol (lambda (.rep|1) (let ((.rep->symbol|2 0)) (begin (set! .rep->symbol|2 (lambda (.rep|3) (if (pair? .rep|3) (cons (.rep->symbol|2 (let ((.x|4|7 .rep|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7)))) (let ((.x|8|11 .rep|3)) (begin (.check! (pair? .x|8|11) 1 .x|8|11) (cdr:pair .x|8|11)))) (let ((.probe|14 (assv .rep|3 *rep-decodings*))) (if .probe|14 (let ((.x|15|18 .probe|14)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))) 'unknown))))) (.rep->symbol|2 .rep|1))))) 'rep->symbol))
(let () (begin (set! representation-table (lambda (.table|1) (let ((.representation-table|2 0)) (begin (set! .representation-table|2 (lambda (.table|3) (let () (let ((.loop|9|12|15 (unspecified))) (begin (set! .loop|9|12|15 (lambda (.y1|4|5|16 .results|4|8|16) (if (null? .y1|4|5|16) (reverse .results|4|8|16) (begin #t (.loop|9|12|15 (let ((.x|20|23 .y1|4|5|16)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) (cons (let ((.row|24 (let ((.x|74|77 .y1|4|5|16)) (begin (.check! (pair? .x|74|77) 0 .x|74|77) (car:pair .x|74|77))))) (let () (let ((.loop|30|33|36 (unspecified))) (begin (set! .loop|30|33|36 (lambda (.y1|25|26|37 .results|25|29|37) (if (null? .y1|25|26|37) (reverse .results|25|29|37) (begin #t (.loop|30|33|36 (let ((.x|41|44 .y1|25|26|37)) (begin (.check! (pair? .x|41|44) 1 .x|41|44) (cdr:pair .x|41|44))) (cons (let ((.x|45 (let ((.x|70|73 .y1|25|26|37)) (begin (.check! (pair? .x|70|73) 0 .x|70|73) (car:pair .x|70|73))))) (if (list? .x|45) (let () (let ((.loop|51|54|57 (unspecified))) (begin (set! .loop|51|54|57 (lambda (.y1|46|47|58 .results|46|50|58) (if (null? .y1|46|47|58) (reverse .results|46|50|58) (begin #t (.loop|51|54|57 (let ((.x|62|65 .y1|46|47|58)) (begin (.check! (pair? .x|62|65) 1 .x|62|65) (cdr:pair .x|62|65))) (cons (symbol->rep (let ((.x|66|69 .y1|46|47|58)) (begin (.check! (pair? .x|66|69) 0 .x|66|69) (car:pair .x|66|69)))) .results|46|50|58)))))) (.loop|51|54|57 .x|45 '())))) .x|45)) .results|25|29|37)))))) (.loop|30|33|36 .row|24 '()))))) .results|4|8|16)))))) (.loop|9|12|15 .table|3 '())))))) (.representation-table|2 .table|1))))) 'representation-table))
(let () (begin (set! define-subtype (lambda (.sym1|1 .sym2|1) (let ((.define-subtype|2 0)) (begin (set! .define-subtype|2 (lambda (.sym1|3 .sym2|3) (let* ((.rep2|6 (symbol->rep .sym2|3)) (.rep1|9 (symbol->rep .sym1|3))) (let () (begin (set! *rep-subtypes* (cons (cons .rep1|9 .rep2|6) *rep-subtypes*)) .sym1|3))))) (.define-subtype|2 .sym1|1 .sym2|1))))) 'define-subtype))
(let () (begin (set! define-intersection (lambda (.sym1|1 .sym2|1 .sym3|1) (let ((.define-intersection|2 0)) (begin (set! .define-intersection|2 (lambda (.sym1|3 .sym2|3 .sym3|3) (let ((.rep1|6 (symbol->rep .sym1|3)) (.rep2|6 (symbol->rep .sym2|3)) (.rep3|6 (symbol->rep .sym3|3))) (begin (representation-aset! *rep-meets* .rep1|6 .rep2|6 .rep3|6) (representation-aset! *rep-meets* .rep2|6 .rep1|6 .rep3|6))))) (.define-intersection|2 .sym1|1 .sym2|1 .sym3|1))))) 'define-intersection))
(let () (begin (set! representation-aref (lambda (.bv|1 .i|1 .j|1) (let ((.representation-aref|2 0)) (begin (set! .representation-aref|2 (lambda (.bv|3 .i|3 .j|3) (bytevector-ref .bv|3 (+ (* *nreps* .i|3) .j|3)))) (.representation-aref|2 .bv|1 .i|1 .j|1))))) 'representation-aref))
(let () (begin (set! representation-aset! (lambda (.bv|1 .i|1 .j|1 .x|1) (let ((.representation-aset!|2 0)) (begin (set! .representation-aset!|2 (lambda (.bv|3 .i|3 .j|3 .x|3) (bytevector-set! .bv|3 (+ (* *nreps* .i|3) .j|3) .x|3))) (.representation-aset!|2 .bv|1 .i|1 .j|1 .x|1))))) 'representation-aset!))
(let () (begin (set! compute-unions! (lambda () (let ((.compute-unions!|2 0)) (begin (set! .compute-unions!|2 (lambda () (begin (let () (let ((.loop|9|11|14 (unspecified))) (begin (set! .loop|9|11|14 (lambda (.y1|4|5|15) (if (null? .y1|4|5|15) (if #f #f (unspecified)) (begin (begin #t (let ((.sym|19 (let ((.x|20|23 .y1|4|5|15)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))))) (define-subtype 'bottom .sym|19))) (.loop|9|11|14 (let ((.x|24|27 .y1|4|5|15)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27)))))))) (.loop|9|11|14 (let () (let ((.loop|33|36|39 (unspecified))) (begin (set! .loop|33|36|39 (lambda (.y1|28|29|40 .results|28|32|40) (if (null? .y1|28|29|40) (reverse .results|28|32|40) (begin #t (.loop|33|36|39 (let ((.x|44|47 .y1|28|29|40)) (begin (.check! (pair? .x|44|47) 1 .x|44|47) (cdr:pair .x|44|47))) (cons (let ((.x|48|51 (let ((.x|52|55 .y1|28|29|40)) (begin (.check! (pair? .x|52|55) 0 .x|52|55) (car:pair .x|52|55))))) (begin (.check! (pair? .x|48|51) 0 .x|48|51) (car:pair .x|48|51))) .results|28|32|40)))))) (.loop|33|36|39 *rep-encodings* '())))))))) (let* ((.debugging?|58 #f) (.n|61 *nreps*) (.n^2|64 (* .n|61 .n|61)) (.matrix|67 (make-bytevector .n^2|64))) (let () (let ((.compute-joins!|73 (unspecified)) (.compute-transitive-closure!|73 (unspecified)) (.join|73 (unspecified)) (.lub|73 (unspecified))) (begin (set! .compute-joins!|73 (lambda () (begin (let ((.default|77 (lambda (.x|78 .y|78) (error "Compiler bug: special meet or join" .x|78 .y|78)))) (begin (set! *rep-joins-special* (make-vector .n|61 .default|77)) (set! *rep-meets-special* (make-vector .n|61 .default|77)))) (set! *rep-joins* (make-bytevector .n^2|64)) (set! *rep-meets* (make-bytevector .n^2|64)) (let () (let ((.loop|80|82|85 (unspecified))) (begin (set! .loop|80|82|85 (lambda (.i|86) (if (= .i|86 .n|61) (if #f #f (unspecified)) (begin (begin #t (let () (let ((.loop|90|92|95 (unspecified))) (begin (set! .loop|90|92|95 (lambda (.j|96) (if (= .j|96 .n|61) (if #f #f (unspecified)) (begin (begin #t (representation-aset! *rep-joins* .i|86 .j|96 (.join|73 .i|86 .j|96))) (.loop|90|92|95 (+ .j|96 1)))))) (.loop|90|92|95 0))))) (.loop|80|82|85 (+ .i|86 1)))))) (.loop|80|82|85 0))))))) (set! .compute-transitive-closure!|73 (lambda () (let* ((.changed?|102 #f) (.loop|103 (unspecified))) (begin (set! .loop|103 (lambda () (begin (let () (let ((.loop|106|108|111 (unspecified))) (begin (set! .loop|106|108|111 (lambda (.i|112) (if (= .i|112 .n|61) (if #f #f (unspecified)) (begin (begin #t (let () (let ((.loop|116|118|121 (unspecified))) (begin (set! .loop|116|118|121 (lambda (.k|122) (if (= .k|122 .n|61) (if #f #f (unspecified)) (begin (begin #t (let () (let ((.loop|125|128|131 (unspecified))) (begin (set! .loop|125|128|131 (lambda (.j|132 .sum|132) (if (= .j|132 .n|61) (if (> .sum|132 0) (let ((.x|136 (representation-aref .matrix|67 .i|112 .k|122))) (if (zero? .x|136) (begin (set! .changed?|102 #t) (representation-aset! .matrix|67 .i|112 .k|122 1)) (unspecified))) (unspecified)) (begin #t (.loop|125|128|131 (+ .j|132 1) (logior .sum|132 (logand (representation-aref .matrix|67 .i|112 .j|132) (representation-aref .matrix|67 .j|132 .k|122)))))))) (.loop|125|128|131 0 0))))) (.loop|116|118|121 (+ .k|122 1)))))) (.loop|116|118|121 0))))) (.loop|106|108|111 (+ .i|112 1)))))) (.loop|106|108|111 0)))) (if .changed?|102 (begin (set! .changed?|102 #f) (.loop|103)) (unspecified))))) (.loop|103))))) (set! .join|73 (lambda (.i|138 .j|138) (.lub|73 .i|138 .j|138 (lambda (.rep1|139 .rep2|139) (= 1 (representation-aref .matrix|67 .rep1|139 .rep2|139)))))) (set! .lub|73 (lambda (.rep1|140 .rep2|140 .subtype?|140) (let () (let ((.loop|141|144|147 (unspecified))) (begin (set! .loop|141|144|147 (lambda (.i|148 .bounds|148) (if (= .i|148 .n|61) (let ((.x|150|153 (twobit-sort .subtype?|140 .bounds|148))) (begin (.check! (pair? .x|150|153) 0 .x|150|153) (car:pair .x|150|153))) (begin #t (.loop|141|144|147 (+ .i|148 1) (if (if (.subtype?|140 .rep1|140 .i|148) (.subtype?|140 .rep2|140 .i|148) #f) (cons .i|148 .bounds|148) .bounds|148)))))) (.loop|141|144|147 0 '())))))) (let () (let ((.loop|72|158|161 (unspecified))) (begin (set! .loop|72|158|161 (lambda (.i|162) (if (= .i|162 .n|61) (if #f #f (unspecified)) (begin (begin #t (let () (let ((.loop|166|168|171 (unspecified))) (begin (set! .loop|166|168|171 (lambda (.j|172) (if (= .j|172 .n|61) (if #f #f (unspecified)) (begin (begin #t (representation-aset! .matrix|67 .i|162 .j|172 0)) (.loop|166|168|171 (+ .j|172 1)))))) (.loop|166|168|171 0)))) (representation-aset! .matrix|67 .i|162 .i|162 1)) (.loop|72|158|161 (+ .i|162 1)))))) (.loop|72|158|161 0)))) (let () (let ((.loop|180|182|185 (unspecified))) (begin (set! .loop|180|182|185 (lambda (.y1|175|176|186) (if (null? .y1|175|176|186) (if #f #f (unspecified)) (begin (begin #t (let ((.subtype|190 (let ((.x|202|205 .y1|175|176|186)) (begin (.check! (pair? .x|202|205) 0 .x|202|205) (car:pair .x|202|205))))) (let ((.rep1|193 (let ((.x|194|197 .subtype|190)) (begin (.check! (pair? .x|194|197) 0 .x|194|197) (car:pair .x|194|197)))) (.rep2|193 (let ((.x|198|201 .subtype|190)) (begin (.check! (pair? .x|198|201) 1 .x|198|201) (cdr:pair .x|198|201))))) (representation-aset! .matrix|67 .rep1|193 .rep2|193 1)))) (.loop|180|182|185 (let ((.x|206|209 .y1|175|176|186)) (begin (.check! (pair? .x|206|209) 1 .x|206|209) (cdr:pair .x|206|209)))))))) (.loop|180|182|185 *rep-subtypes*)))) (.compute-transitive-closure!|73) (if .debugging?|58 (let () (let ((.loop|211|213|216 (unspecified))) (begin (set! .loop|211|213|216 (lambda (.i|217) (if (= .i|217 .n|61) (if #f #f (unspecified)) (begin (begin #t (let () (let ((.loop|221|223|226 (unspecified))) (begin (set! .loop|221|223|226 (lambda (.j|227) (if (= .j|227 .n|61) (if #f #f (unspecified)) (begin (begin #t (write-char #\space) (write (representation-aref .matrix|67 .i|217 .j|227))) (.loop|221|223|226 (+ .j|227 1)))))) (.loop|221|223|226 0)))) (newline)) (.loop|211|213|216 (+ .i|217 1)))))) (.loop|211|213|216 0)))) (unspecified)) (.compute-joins!|73) (set! *rep-subtypes* '())))))))) (.compute-unions!|2))))) 'compute-unions!))
(let () (begin (set! compute-intersections! (lambda () (let ((.compute-intersections!|2 0)) (begin (set! .compute-intersections!|2 (lambda () (let* ((.n|6 *nreps*) (.meet|9 (unspecified))) (begin (set! .meet|9 (lambda (.i|10 .j|10) (let ((.k|13 (representation-union .i|10 .j|10))) (if (= .i|10 .k|13) .j|10 .i|10)))) (let () (let ((.loop|8|15|18 (unspecified))) (begin (set! .loop|8|15|18 (lambda (.i|19) (if (= .i|19 .n|6) (if #f #f (unspecified)) (begin (begin #t (let () (let ((.loop|23|25|28 (unspecified))) (begin (set! .loop|23|25|28 (lambda (.j|29) (if (= .j|29 .n|6) (if #f #f (unspecified)) (begin (begin #t (representation-aset! *rep-meets* .i|19 .j|29 (.meet|9 .i|19 .j|29))) (.loop|23|25|28 (+ .j|29 1)))))) (.loop|23|25|28 0))))) (.loop|8|15|18 (+ .i|19 1)))))) (.loop|8|15|18 0)))))))) (.compute-intersections!|2))))) 'compute-intersections!))
(let () (begin (set! compute-type-structure! (lambda () (let ((.compute-type-structure!|2 0)) (begin (set! .compute-type-structure!|2 (lambda () (begin (compute-unions!) (compute-intersections!)))) (.compute-type-structure!|2))))) 'compute-type-structure!))
(let () (begin (set! representation-subtype? (lambda (.rep1|1 .rep2|1) (let ((.representation-subtype?|2 0)) (begin (set! .representation-subtype?|2 (lambda (.rep1|3 .rep2|3) (equal? .rep2|3 (representation-union .rep1|3 .rep2|3)))) (.representation-subtype?|2 .rep1|1 .rep2|1))))) 'representation-subtype?))
(let () (begin (set! representation-union (lambda (.rep1|1 .rep2|1) (let ((.representation-union|2 0)) (begin (set! .representation-union|2 (lambda (.rep1|3 .rep2|3) (if (fixnum? .rep1|3) (if (fixnum? .rep2|3) (representation-aref *rep-joins* .rep1|3 .rep2|3) (.representation-union|2 .rep1|3 (let ((.x|4|7 .rep2|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (if (fixnum? .rep2|3) (.representation-union|2 (let ((.x|8|11 .rep1|3)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) .rep2|3) (let ((.r1|14 (let ((.x|19|22 .rep1|3)) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22)))) (.r2|14 (let ((.x|23|26 .rep2|3)) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26))))) (if (= .r1|14 .r2|14) ((let ((.v|15|18 *rep-joins-special*) (.i|15|18 .r1|14)) (begin (.check! (fixnum? .i|15|18) 40 .v|15|18 .i|15|18) (.check! (vector? .v|15|18) 40 .v|15|18 .i|15|18) (.check! (<:fix:fix .i|15|18 (vector-length:vec .v|15|18)) 40 .v|15|18 .i|15|18) (.check! (>=:fix:fix .i|15|18 0) 40 .v|15|18 .i|15|18) (vector-ref:trusted .v|15|18 .i|15|18))) .rep1|3 .rep2|3) (.representation-union|2 .r1|14 .r2|14))))))) (.representation-union|2 .rep1|1 .rep2|1))))) 'representation-union))
(let () (begin (set! representation-intersection (lambda (.rep1|1 .rep2|1) (let ((.representation-intersection|2 0)) (begin (set! .representation-intersection|2 (lambda (.rep1|3 .rep2|3) (if (fixnum? .rep1|3) (if (fixnum? .rep2|3) (representation-aref *rep-meets* .rep1|3 .rep2|3) (.representation-intersection|2 .rep1|3 (let ((.x|4|7 .rep2|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (if (fixnum? .rep2|3) (.representation-intersection|2 (let ((.x|8|11 .rep1|3)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) .rep2|3) (let ((.r1|14 (let ((.x|19|22 .rep1|3)) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22)))) (.r2|14 (let ((.x|23|26 .rep2|3)) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26))))) (if (= .r1|14 .r2|14) ((let ((.v|15|18 *rep-meets-special*) (.i|15|18 .r1|14)) (begin (.check! (fixnum? .i|15|18) 40 .v|15|18 .i|15|18) (.check! (vector? .v|15|18) 40 .v|15|18 .i|15|18) (.check! (<:fix:fix .i|15|18 (vector-length:vec .v|15|18)) 40 .v|15|18 .i|15|18) (.check! (>=:fix:fix .i|15|18 0) 40 .v|15|18 .i|15|18) (vector-ref:trusted .v|15|18 .i|15|18))) .rep1|3 .rep2|3) (.representation-intersection|2 .r1|14 .r2|14))))))) (.representation-intersection|2 .rep1|1 .rep2|1))))) 'representation-intersection))
(let () (begin (set! display-unions-and-intersections (lambda () (let ((.display-unions-and-intersections|2 0)) (begin (set! .display-unions-and-intersections|2 (lambda () (let* ((.column-width|6 10) (.columns/row|9 (quotient 80 .column-width|6))) (let () (let ((.display-matrix|13 (unspecified)) (.display-symbol|13 (unspecified))) (begin (set! .display-matrix|13 (lambda (.f|14 .i|14 .n|14) (begin (display (make-string .column-width|6 #\space)) (let () (let ((.loop|16|18|21 (unspecified))) (begin (set! .loop|16|18|21 (lambda (.i|22) (if (= .i|22 .n|14) (if #f #f (unspecified)) (begin (begin #t (.display-symbol|13 (rep->symbol .i|22))) (.loop|16|18|21 (+ .i|22 1)))))) (.loop|16|18|21 .i|14)))) (newline) (newline) (let () (let ((.loop|26|28|31 (unspecified))) (begin (set! .loop|26|28|31 (lambda (.k|32) (if (= .k|32 *nreps*) (if #f #f (unspecified)) (begin (begin #t (.display-symbol|13 (rep->symbol .k|32)) (let () (let ((.loop|36|38|41 (unspecified))) (begin (set! .loop|36|38|41 (lambda (.i|42) (if (= .i|42 .n|14) (if #f #f (unspecified)) (begin (begin #t (.display-symbol|13 (rep->symbol (.f|14 .k|32 .i|42)))) (.loop|36|38|41 (+ .i|42 1)))))) (.loop|36|38|41 .i|14)))) (newline)) (.loop|26|28|31 (+ .k|32 1)))))) (.loop|26|28|31 0)))) (newline) (newline)))) (set! .display-symbol|13 (lambda (.sym|45) (let* ((.s|48 (symbol->string .sym|45)) (.n|51 (string-length .s|48))) (let () (if (< .n|51 .column-width|6) (begin (display .s|48) (display (make-string (- .column-width|6 .n|51) #\space))) (begin (display (substring .s|48 0 (- .column-width|6 1))) (write-char #\space))))))) (display "Unions:") (newline) (newline) (let () (let ((.loop|56|58|61 (unspecified))) (begin (set! .loop|56|58|61 (lambda (.i|62) (if (>= .i|62 *nreps*) (if #f #f (unspecified)) (begin (begin #t (.display-matrix|13 representation-union .i|62 (min *nreps* (+ .i|62 .columns/row|9)))) (.loop|56|58|61 (+ .i|62 .columns/row|9)))))) (.loop|56|58|61 0)))) (display "Intersections:") (newline) (newline) (let () (let ((.loop|66|68|71 (unspecified))) (begin (set! .loop|66|68|71 (lambda (.i|72) (if (>= .i|72 *nreps*) (if #f #f (unspecified)) (begin (begin #t (.display-matrix|13 representation-intersection .i|72 (min *nreps* (+ .i|72 .columns/row|9)))) (.loop|66|68|71 (+ .i|72 .columns/row|9)))))) (.loop|66|68|71 0)))))))))) (.display-unions-and-intersections|2))))) 'display-unions-and-intersections))
(let () (begin (set! rep-specific? (lambda (.f|1 .rs|1) (let ((.rep-specific?|2 0)) (begin (set! .rep-specific?|2 (lambda (.f|3 .rs|3) (rep-match .f|3 .rs|3 rep-specific caddr))) (.rep-specific?|2 .f|1 .rs|1))))) 'rep-specific?))
(let () (begin (set! rep-result? (lambda (.f|1 .rs|1) (let ((.rep-result?|2 0)) (begin (set! .rep-result?|2 (lambda (.f|3 .rs|3) (rep-match .f|3 .rs|3 rep-result caaddr))) (.rep-result?|2 .f|1 .rs|1))))) 'rep-result?))
(let () (begin (set! rep-if-true (lambda (.f|1 .rs|1) (let ((.rep-if-true|2 0)) (begin (set! .rep-if-true|2 (lambda (.f|3 .rs|3) (rep-match .f|3 .rs|3 rep-informing caddr))) (.rep-if-true|2 .f|1 .rs|1))))) 'rep-if-true))
(let () (begin (set! rep-if-false (lambda (.f|1 .rs|1) (let ((.rep-if-false|2 0)) (begin (set! .rep-if-false|2 (lambda (.f|3 .rs|3) (rep-match .f|3 .rs|3 rep-informing cadddr))) (.rep-if-false|2 .f|1 .rs|1))))) 'rep-if-false))
(let () (begin (set! rep-match (lambda (.f|1 .rs|1 .table|1 .selector|1) (let ((.rep-match|2 0)) (begin (set! .rep-match|2 (lambda (.f|3 .rs|3 .table|3 .selector|3) (let* ((.n|6 (length .rs|3)) (.entries|9 .table|3)) (let () (let ((.loop|12 (unspecified))) (begin (set! .loop|12 (lambda (.entries|13) (if (null? .entries|13) #f (if (eq? .f|3 (let ((.x|16|19 (let ((.x|20|23 .entries|13)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))))) (begin (.check! (pair? .x|16|19) 0 .x|16|19) (car:pair .x|16|19)))) (let ((.rs0|26 (let ((.x|88|91 (let ((.x|92|95 (let ((.x|96|99 .entries|13)) (begin (.check! (pair? .x|96|99) 0 .x|96|99) (car:pair .x|96|99))))) (begin (.check! (pair? .x|92|95) 1 .x|92|95) (cdr:pair .x|92|95))))) (begin (.check! (pair? .x|88|91) 0 .x|88|91) (car:pair .x|88|91))))) (if (if (= .n|6 (length .rs0|26)) (every? (lambda (.r1+r2|29) (let ((.r1|32 (let ((.x|33|36 .r1+r2|29)) (begin (.check! (pair? .x|33|36) 0 .x|33|36) (car:pair .x|33|36)))) (.r2|32 (let ((.x|37|40 .r1+r2|29)) (begin (.check! (pair? .x|37|40) 1 .x|37|40) (cdr:pair .x|37|40))))) (representation-subtype? .r1|32 .r2|32))) (let () (let ((.loop|47|51|54 (unspecified))) (begin (set! .loop|47|51|54 (lambda (.y1|41|43|55 .y1|41|42|55 .results|41|46|55) (if (let ((.temp|57|60 (null? .y1|41|43|55))) (if .temp|57|60 .temp|57|60 (null? .y1|41|42|55))) (reverse .results|41|46|55) (begin #t (.loop|47|51|54 (let ((.x|63|66 .y1|41|43|55)) (begin (.check! (pair? .x|63|66) 1 .x|63|66) (cdr:pair .x|63|66))) (let ((.x|67|70 .y1|41|42|55)) (begin (.check! (pair? .x|67|70) 1 .x|67|70) (cdr:pair .x|67|70))) (cons (cons (let ((.x|71|74 .y1|41|43|55)) (begin (.check! (pair? .x|71|74) 0 .x|71|74) (car:pair .x|71|74))) (let ((.x|75|78 .y1|41|42|55)) (begin (.check! (pair? .x|75|78) 0 .x|75|78) (car:pair .x|75|78)))) .results|41|46|55)))))) (.loop|47|51|54 .rs|3 .rs0|26 '()))))) #f) (.selector|3 (let ((.x|79|82 .entries|13)) (begin (.check! (pair? .x|79|82) 0 .x|79|82) (car:pair .x|79|82)))) (.loop|12 (let ((.x|83|86 .entries|13)) (begin (.check! (pair? .x|83|86) 1 .x|83|86) (cdr:pair .x|83|86)))))) (.loop|12 (let ((.x|101|104 .entries|13)) (begin (.check! (pair? .x|101|104) 1 .x|101|104) (cdr:pair .x|101|104)))))))) (.loop|12 .entries|9))))))) (.rep-match|2 .f|1 .rs|1 .table|1 .selector|1))))) 'rep-match))
(let () (begin (set! aeval (lambda (.e|1 .types|1 .constraints|1) (let ((.aeval|2 0)) (begin (set! .aeval|2 (lambda (.e|3 .types|3 .constraints|3) (if (call? .e|3) (let ((.proc|7 (call.proc .e|3))) (if (variable? .proc|7) (let* ((.op|10 (variable.name .proc|7)) (.argtypes|13 (let () (let ((.loop|25|28|31 (unspecified))) (begin (set! .loop|25|28|31 (lambda (.y1|20|21|32 .results|20|24|32) (if (null? .y1|20|21|32) (reverse .results|20|24|32) (begin #t (.loop|25|28|31 (let ((.x|36|39 .y1|20|21|32)) (begin (.check! (pair? .x|36|39) 1 .x|36|39) (cdr:pair .x|36|39))) (cons (let ((.e|40 (let ((.x|41|44 .y1|20|21|32)) (begin (.check! (pair? .x|41|44) 0 .x|41|44) (car:pair .x|41|44))))) (.aeval|2 .e|40 .types|3 .constraints|3)) .results|20|24|32)))))) (.loop|25|28|31 (call.args .e|3) '()))))) (.type|16 (rep-result? .op|10 .argtypes|13))) (let () (if .type|16 .type|16 rep:object))) rep:object)) (if (variable? .e|3) (representation-typeof (variable.name .e|3) .types|3 .constraints|3) (if (constant? .e|3) (representation-of-value (constant.value .e|3)) rep:object))))) (.aeval|2 .e|1 .types|1 .constraints|1))))) 'aeval))
(let () (begin (set! representation-typeof (lambda (.name|1 .types|1 .constraints|1) (let ((.representation-typeof|2 0)) (begin (set! .representation-typeof|2 (lambda (.name|3 .types|3 .constraints|3) (let ((.t0|6 (hashtable-fetch .types|3 .name|3 rep:object)) (.cs|6 (hashtable-fetch (constraints.table .constraints|3) .name|3 '()))) (let ((.loop|7 (unspecified))) (begin (set! .loop|7 (lambda (.type|8 .cs|8) (if (null? .cs|8) .type|8 (let* ((.c|11 (let ((.x|28|31 .cs|8)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31)))) (.cs|14 (let ((.x|24|27 .cs|8)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27)))) (.e|17 (constraint.rhs .c|11))) (let () (if (constant? .e|17) (.loop|7 (representation-intersection .type|8 (constant.value .e|17)) .cs|14) (if (call? .e|17) (.loop|7 (representation-intersection .type|8 (aeval .e|17 .types|3 .constraints|3)) .cs|14) (.loop|7 .type|8 .cs|14)))))))) (.loop|7 .t0|6 .cs|6)))))) (.representation-typeof|2 .name|1 .types|1 .constraints|1))))) 'representation-typeof))
(let () (begin (set! make-constraint (lambda (.t|1 .e|1 .k|1) (let ((.make-constraint|2 0)) (begin (set! .make-constraint|2 (lambda (.t|3 .e|3 .k|3) (let* ((.t1|4|7 .t|3) (.t2|4|10 (let* ((.t1|14|17 .e|3) (.t2|14|20 (cons .k|3 '()))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-constraint|2 .t|1 .e|1 .k|1))))) 'make-constraint))
(let () (begin (set! constraint.lhs (lambda (.c|1) (let ((.constraint.lhs|2 0)) (begin (set! .constraint.lhs|2 (lambda (.c|3) (let ((.x|4|7 .c|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.constraint.lhs|2 .c|1))))) 'constraint.lhs))
(let () (begin (set! constraint.rhs (lambda (.c|1) (let ((.constraint.rhs|2 0)) (begin (set! .constraint.rhs|2 (lambda (.c|3) (let ((.x|5|8 (let ((.x|9|12 .c|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.constraint.rhs|2 .c|1))))) 'constraint.rhs))
(let () (begin (set! constraint.killer (lambda (.c|1) (let ((.constraint.killer|2 0)) (begin (set! .constraint.killer|2 (lambda (.c|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .c|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.constraint.killer|2 .c|1))))) 'constraint.killer))
(let () (begin (set! make-type-constraint (lambda (.t|1 .type|1 .k|1) (let ((.make-type-constraint|2 0)) (begin (set! .make-type-constraint|2 (lambda (.t|3 .type|3 .k|3) (make-constraint .t|3 (make-constant .type|3) .k|3))) (.make-type-constraint|2 .t|1 .type|1 .k|1))))) 'make-type-constraint))
(let () (begin (set! constraints-add! (lambda (.types|1 .constraints|1 .new|1) (let ((.constraints-add!|2 0)) (begin (set! .constraints-add!|2 (lambda (.types|3 .constraints|3 .new|3) (let* ((.debugging?|6 #f) (.t|9 (constraint.lhs .new|3)) (.e|12 (constraint.rhs .new|3)) (.k|15 (constraint.killer .new|3)) (.cs|18 (constraints-for-variable .constraints|3 .t|9))) (let () (let ((.record-new-reps!|22 (unspecified)) (.loop|22 (unspecified))) (begin (set! .record-new-reps!|22 (lambda (.args|23 .argtypes|23 .reps|23 .k2|23) (begin (if .debugging?|6 (begin (write (let* ((.t1|24|27 (let () (let ((.loop|98|101|104 (unspecified))) (begin (set! .loop|98|101|104 (lambda (.y1|93|94|105 .results|93|97|105) (if (null? .y1|93|94|105) (reverse .results|93|97|105) (begin #t (.loop|98|101|104 (let ((.x|109|112 .y1|93|94|105)) (begin (.check! (pair? .x|109|112) 1 .x|109|112) (cdr:pair .x|109|112))) (cons (make-readable (let ((.x|113|116 .y1|93|94|105)) (begin (.check! (pair? .x|113|116) 0 .x|113|116) (car:pair .x|113|116)))) .results|93|97|105)))))) (.loop|98|101|104 .args|23 '()))))) (.t2|24|30 (let* ((.t1|34|37 (let () (let ((.loop|74|77|80 (unspecified))) (begin (set! .loop|74|77|80 (lambda (.y1|69|70|81 .results|69|73|81) (if (null? .y1|69|70|81) (reverse .results|69|73|81) (begin #t (.loop|74|77|80 (let ((.x|85|88 .y1|69|70|81)) (begin (.check! (pair? .x|85|88) 1 .x|85|88) (cdr:pair .x|85|88))) (cons (rep->symbol (let ((.x|89|92 .y1|69|70|81)) (begin (.check! (pair? .x|89|92) 0 .x|89|92) (car:pair .x|89|92)))) .results|69|73|81)))))) (.loop|74|77|80 .argtypes|23 '()))))) (.t2|34|40 (cons (let () (let ((.loop|50|53|56 (unspecified))) (begin (set! .loop|50|53|56 (lambda (.y1|45|46|57 .results|45|49|57) (if (null? .y1|45|46|57) (reverse .results|45|49|57) (begin #t (.loop|50|53|56 (let ((.x|61|64 .y1|45|46|57)) (begin (.check! (pair? .x|61|64) 1 .x|61|64) (cdr:pair .x|61|64))) (cons (rep->symbol (let ((.x|65|68 .y1|45|46|57)) (begin (.check! (pair? .x|65|68) 0 .x|65|68) (car:pair .x|65|68)))) .results|45|49|57)))))) (.loop|50|53|56 .reps|23 '())))) '()))) (let () (cons .t1|34|37 .t2|34|40))))) (let () (cons .t1|24|27 .t2|24|30)))) (newline)) (unspecified)) (let () (let ((.loop|124|128|131 (unspecified))) (begin (set! .loop|124|128|131 (lambda (.y1|117|120|132 .y1|117|119|132 .y1|117|118|132) (if (let ((.temp|134|137 (null? .y1|117|120|132))) (if .temp|134|137 .temp|134|137 (let ((.temp|138|141 (null? .y1|117|119|132))) (if .temp|138|141 .temp|138|141 (null? .y1|117|118|132))))) (if #f #f (unspecified)) (begin (begin #t (let ((.arg|144 (let ((.x|148|151 .y1|117|120|132)) (begin (.check! (pair? .x|148|151) 0 .x|148|151) (car:pair .x|148|151)))) (.type0|144 (let ((.x|152|155 .y1|117|119|132)) (begin (.check! (pair? .x|152|155) 0 .x|152|155) (car:pair .x|152|155)))) (.type1|144 (let ((.x|156|159 .y1|117|118|132)) (begin (.check! (pair? .x|156|159) 0 .x|156|159) (car:pair .x|156|159))))) (if (not (representation-subtype? .type0|144 .type1|144)) (if (variable? .arg|144) (let ((.name|147 (variable.name .arg|144))) (if (hashtable-get .types|3 .name|147) (.constraints-add!|2 .types|3 .constraints|3 (make-type-constraint .name|147 .type1|144 (available:killer-combine .k|15 .k2|23))) (cerror "Compiler bug: unexpected global: " .name|147))) (unspecified)) (unspecified)))) (.loop|124|128|131 (let ((.x|160|163 .y1|117|120|132)) (begin (.check! (pair? .x|160|163) 1 .x|160|163) (cdr:pair .x|160|163))) (let ((.x|164|167 .y1|117|119|132)) (begin (.check! (pair? .x|164|167) 1 .x|164|167) (cdr:pair .x|164|167))) (let ((.x|168|171 .y1|117|118|132)) (begin (.check! (pair? .x|168|171) 1 .x|168|171) (cdr:pair .x|168|171)))))))) (.loop|124|128|131 .args|23 .argtypes|23 .reps|23))))))) (set! .loop|22 (lambda (.type|172 .k|172 .cs|172 .newcs|172) (if (null? .cs|172) (cons (make-type-constraint .t|9 .type|172 .k|172) .newcs|172) (let* ((.c2|175 (let ((.x|249|252 .cs|172)) (begin (.check! (pair? .x|249|252) 0 .x|249|252) (car:pair .x|249|252)))) (.cs|178 (let ((.x|245|248 .cs|172)) (begin (.check! (pair? .x|245|248) 1 .x|245|248) (cdr:pair .x|245|248)))) (.e2|181 (constraint.rhs .c2|175)) (.k2|184 (constraint.killer .c2|175))) (let () (if (constant? .e2|181) (let* ((.type2|190 (constant.value .e2|181)) (.type3|193 (representation-intersection .type|172 .type2|190))) (let () (if (eq? .type2|190 .type3|193) (if (= .k2|184 (logand .k|172 .k2|184)) (append .newcs|172 .cs|178) (.loop|22 (representation-intersection .type|172 .type2|190) (available:killer-combine .k|172 .k2|184) .cs|178 (cons .c2|175 .newcs|172))) (if (representation-subtype? .type|172 .type3|193) (if (= .k|172 (logand .k|172 .k2|184)) (.loop|22 .type|172 .k|172 .cs|178 .newcs|172) (.loop|22 .type|172 .k|172 .cs|178 (cons .c2|175 .newcs|172))) (.loop|22 .type3|193 (available:killer-combine .k|172 .k2|184) .cs|178 (cons .c2|175 .newcs|172)))))) (let* ((.op|202 (variable.name (call.proc .e2|181))) (.args|205 (call.args .e2|181)) (.argtypes|208 (let () (let ((.loop|225|228|231 (unspecified))) (begin (set! .loop|225|228|231 (lambda (.y1|220|221|232 .results|220|224|232) (if (null? .y1|220|221|232) (reverse .results|220|224|232) (begin #t (.loop|225|228|231 (let ((.x|236|239 .y1|220|221|232)) (begin (.check! (pair? .x|236|239) 1 .x|236|239) (cdr:pair .x|236|239))) (cons (let ((.exp|240 (let ((.x|241|244 .y1|220|221|232)) (begin (.check! (pair? .x|241|244) 0 .x|241|244) (car:pair .x|241|244))))) (aeval .exp|240 .types|3 .constraints|3)) .results|220|224|232)))))) (.loop|225|228|231 .args|205 '())))))) (let () (begin (if (representation-subtype? .type|172 rep:true) (let ((.reps|215 (rep-if-true .op|202 .argtypes|208))) (if .reps|215 (.record-new-reps!|22 .args|205 .argtypes|208 .reps|215 .k2|184) (unspecified))) (if (representation-subtype? .type|172 rep:false) (let ((.reps|219 (rep-if-false .op|202 .argtypes|208))) (if .reps|219 (.record-new-reps!|22 .args|205 .argtypes|208 .reps|219 .k2|184) (unspecified))) (unspecified))) (.loop|22 .type|172 .k|172 .cs|178 (cons .c2|175 .newcs|172))))))))))) (if (not (zero? .k|15)) (constraints-add-killedby! .constraints|3 .t|9 .k|15) (unspecified)) (let* ((.table|255 (constraints.table .constraints|3)) (.cs|258 (hashtable-fetch .table|255 .t|9 '()))) (let () (if (constant? .e|12) (let ((.type|265 (constant.value .e|12))) (begin (if .debugging?|6 (begin (display .t|9) (display " : ") (display (rep->symbol .type|265)) (newline)) (unspecified)) (let ((.cs|268 (.loop|22 .type|265 .k|15 .cs|258 '()))) (begin (hashtable-put! .table|255 .t|9 .cs|268) .constraints|3)))) (begin (if .debugging?|6 (begin (display .t|9) (display " = ") (display (make-readable .e|12 #t)) (newline)) (unspecified)) (if (not (null? .cs|258)) (begin (display "Compiler bug: ") (write .t|9) (display " has unexpectedly nonempty constraints") (newline)) (unspecified)) (hashtable-put! .table|255 .t|9 (cons (let* ((.t1|271|274 .t|9) (.t2|271|277 (let* ((.t1|281|284 .e|12) (.t2|281|287 (cons .k|15 '()))) (let () (cons .t1|281|284 .t2|281|287))))) (let () (cons .t1|271|274 .t2|271|277))) '())) .constraints|3)))))))))) (.constraints-add!|2 .types|1 .constraints|1 .new|1))))) 'constraints-add!))
(let () (begin (set! number-of-basic-killers (let () (let ((.loop|1|4|7 (unspecified))) (begin (set! .loop|1|4|7 (lambda (.i|8 .k|8) (if (> .k|8 available:killer:dead) .i|8 (begin #t (.loop|1|4|7 (+ .i|8 1) (+ .k|8 .k|8)))))) (.loop|1|4|7 0 1))))) 'number-of-basic-killers))
(let () (begin (set! constraints.table (lambda (.constraints|1) (let ((.constraints.table|2 0)) (begin (set! .constraints.table|2 (lambda (.constraints|3) (let ((.x|4|7 .constraints|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.constraints.table|2 .constraints|1))))) 'constraints.table))
(let () (begin (set! constraints.killed (lambda (.constraints|1) (let ((.constraints.killed|2 0)) (begin (set! .constraints.killed|2 (lambda (.constraints|3) (let ((.x|5|8 (let ((.x|9|12 .constraints|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.constraints.killed|2 .constraints|1))))) 'constraints.killed))
(let () (begin (set! make-constraints-table (lambda () (let ((.make-constraints-table|2 0)) (begin (set! .make-constraints-table|2 (lambda () (let* ((.t1|4|7 (make-hashtable symbol-hash assq)) (.t2|4|10 (cons (make-vector number-of-basic-killers '()) '()))) (let () (cons .t1|4|7 .t2|4|10))))) (.make-constraints-table|2))))) 'make-constraints-table))
(let () (begin (set! copy-constraints-table (lambda (.constraints|1) (let ((.copy-constraints-table|2 0)) (begin (set! .copy-constraints-table|2 (lambda (.constraints|3) (let* ((.t1|4|7 (hashtable-copy (constraints.table .constraints|3))) (.t2|4|10 (cons (list->vector (vector->list (constraints.killed .constraints|3))) '()))) (let () (cons .t1|4|7 .t2|4|10))))) (.copy-constraints-table|2 .constraints|1))))) 'copy-constraints-table))
(let () (begin (set! constraints-for-variable (lambda (.constraints|1 .t|1) (let ((.constraints-for-variable|2 0)) (begin (set! .constraints-for-variable|2 (lambda (.constraints|3 .t|3) (hashtable-fetch (constraints.table .constraints|3) .t|3 '()))) (.constraints-for-variable|2 .constraints|1 .t|1))))) 'constraints-for-variable))
(let () (begin (set! constraints-add-killedby! (lambda (.constraints|1 .t|1 .k0|1) (let ((.constraints-add-killedby!|2 0)) (begin (set! .constraints-add-killedby!|2 (lambda (.constraints|3 .t|3 .k0|3) (if (not (zero? .k0|3)) (let ((.v|6 (constraints.killed .constraints|3))) (let () (let ((.loop|8|11|14 (unspecified))) (begin (set! .loop|8|11|14 (lambda (.i|15 .k|15) (if (= .i|15 number-of-basic-killers) (if #f #f (unspecified)) (begin (begin #t (if (not (zero? (logand .k|15 .k0|3))) (let ((.v|18|21 .v|6) (.i|18|21 .i|15) (.x|18|21 (cons .t|3 (let ((.v|22|25 .v|6) (.i|22|25 .i|15)) (begin (.check! (fixnum? .i|22|25) 40 .v|22|25 .i|22|25) (.check! (vector? .v|22|25) 40 .v|22|25 .i|22|25) (.check! (<:fix:fix .i|22|25 (vector-length:vec .v|22|25)) 40 .v|22|25 .i|22|25) (.check! (>=:fix:fix .i|22|25 0) 40 .v|22|25 .i|22|25) (vector-ref:trusted .v|22|25 .i|22|25)))))) (begin (.check! (fixnum? .i|18|21) 41 .v|18|21 .i|18|21 .x|18|21) (.check! (vector? .v|18|21) 41 .v|18|21 .i|18|21 .x|18|21) (.check! (<:fix:fix .i|18|21 (vector-length:vec .v|18|21)) 41 .v|18|21 .i|18|21 .x|18|21) (.check! (>=:fix:fix .i|18|21 0) 41 .v|18|21 .i|18|21 .x|18|21) (vector-set!:trusted .v|18|21 .i|18|21 .x|18|21))) (unspecified))) (.loop|8|11|14 (+ .i|15 1) (+ .k|15 .k|15)))))) (.loop|8|11|14 0 1))))) (unspecified)))) (.constraints-add-killedby!|2 .constraints|1 .t|1 .k0|1))))) 'constraints-add-killedby!))
(let () (begin (set! constraints-kill! (lambda (.constraints|1 .k|1) (let ((.constraints-kill!|2 0)) (begin (set! .constraints-kill!|2 (lambda (.constraints|3 .k|3) (if (not (zero? .k|3)) (let ((.table|6 (constraints.table .constraints|3)) (.killed|6 (constraints.killed .constraints|3))) (let ((.examine!|9 (unspecified))) (begin (set! .examine!|9 (lambda (.t|10) (let ((.cs|13 (filter (lambda (.c|14) (zero? (logand (constraint.killer .c|14) .k|3))) (hashtable-fetch .table|6 .t|10 '())))) (if (null? .cs|13) (hashtable-remove! .table|6 .t|10) (hashtable-put! .table|6 .t|10 .cs|13))))) (let () (let ((.loop|8|17|20 (unspecified))) (begin (set! .loop|8|17|20 (lambda (.i|21 .j|21) (if (= .i|21 number-of-basic-killers) (if #f #f (unspecified)) (begin (begin #t (if (not (zero? (logand .j|21 .k|3))) (begin (let () (let ((.loop|29|31|34 (unspecified))) (begin (set! .loop|29|31|34 (lambda (.y1|24|25|35) (if (null? .y1|24|25|35) (if #f #f (unspecified)) (begin (begin #t (.examine!|9 (let ((.x|39|42 .y1|24|25|35)) (begin (.check! (pair? .x|39|42) 0 .x|39|42) (car:pair .x|39|42))))) (.loop|29|31|34 (let ((.x|43|46 .y1|24|25|35)) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46)))))))) (.loop|29|31|34 (let ((.v|47|50 .killed|6) (.i|47|50 .i|21)) (begin (.check! (fixnum? .i|47|50) 40 .v|47|50 .i|47|50) (.check! (vector? .v|47|50) 40 .v|47|50 .i|47|50) (.check! (<:fix:fix .i|47|50 (vector-length:vec .v|47|50)) 40 .v|47|50 .i|47|50) (.check! (>=:fix:fix .i|47|50 0) 40 .v|47|50 .i|47|50) (vector-ref:trusted .v|47|50 .i|47|50))))))) (let ((.v|51|54 .killed|6) (.i|51|54 .i|21) (.x|51|54 '())) (begin (.check! (fixnum? .i|51|54) 41 .v|51|54 .i|51|54 .x|51|54) (.check! (vector? .v|51|54) 41 .v|51|54 .i|51|54 .x|51|54) (.check! (<:fix:fix .i|51|54 (vector-length:vec .v|51|54)) 41 .v|51|54 .i|51|54 .x|51|54) (.check! (>=:fix:fix .i|51|54 0) 41 .v|51|54 .i|51|54 .x|51|54) (vector-set!:trusted .v|51|54 .i|51|54 .x|51|54)))) (unspecified))) (.loop|8|17|20 (+ .i|21 1) (+ .j|21 .j|21)))))) (.loop|8|17|20 0 1))))))) (unspecified)))) (.constraints-kill!|2 .constraints|1 .k|1))))) 'constraints-kill!))
(let () (begin (set! constraints-intersect! (lambda (.constraints0|1 .constraints1|1 .constraints2|1) (let ((.constraints-intersect!|2 0)) (begin (set! .constraints-intersect!|2 (lambda (.constraints0|3 .constraints1|3 .constraints2|3) (let ((.table0|6 (constraints.table .constraints0|3)) (.table1|6 (constraints.table .constraints1|3)) (.table2|6 (constraints.table .constraints2|3))) (if (eq? .table0|6 .table1|6) (hashtable-for-each (lambda (.t|7 .cs|7) (if (not (null? .cs|7)) (hashtable-put! .table0|6 .t|7 (cs-intersect (hashtable-fetch .table2|6 .t|7 '()) .cs|7)) (unspecified))) .table1|6) (begin (.constraints-intersect!|2 .constraints0|3 .constraints0|3 .constraints1|3) (.constraints-intersect!|2 .constraints0|3 .constraints0|3 .constraints2|3)))))) (.constraints-intersect!|2 .constraints0|1 .constraints1|1 .constraints2|1))))) 'constraints-intersect!))
(let () (begin (set! cs-intersect (lambda (.cs1|1 .cs2|1) (let ((.cs-intersect|2 0)) (begin (set! .cs-intersect|2 (lambda (.cs1|3 .cs2|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.cs|5 .init|5 .rep|5 .krep|5) (if (null? .cs|5) (values .init|5 .rep|5 .krep|5) (let* ((.c|8 (let ((.x|28|31 .cs|5)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31)))) (.cs|11 (let ((.x|24|27 .cs|5)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27)))) (.e2|14 (constraint.rhs .c|8)) (.k2|17 (constraint.killer .c|8))) (let () (if (constant? .e2|14) (.loop|4 .cs|11 .init|5 (representation-intersection .rep|5 (constant.value .e2|14)) (available:killer-combine .krep|5 .k2|17)) (if (call? .e2|14) (if .init|5 (begin (display "Compiler bug in cs-intersect") (break)) (.loop|4 .cs|11 .c|8 .rep|5 .krep|5)) (error "Compiler bug in cs-intersect")))))))) (call-with-values (lambda () (.loop|4 .cs1|3 #f rep:object available:killer:none)) (lambda (.c1|33 .rep1|33 .krep1|33) (call-with-values (lambda () (.loop|4 .cs2|3 #f rep:object available:killer:none)) (lambda (.c2|35 .rep2|35 .krep2|35) (let ((.c|38 (if (equal? .c1|33 .c2|35) .c1|33 #f)) (.rep|38 (representation-union .rep1|33 .rep2|35)) (.krep|38 (available:killer-combine .krep1|33 .krep2|35))) (if (eq? .rep|38 rep:object) (if .c|38 (cons .c|38 '()) '()) (let ((.t|42 (constraint.lhs (let ((.x|55|58 .cs1|3)) (begin (.check! (pair? .x|55|58) 0 .x|55|58) (car:pair .x|55|58)))))) (if .c|38 (let* ((.t1|43|46 .c|38) (.t2|43|49 (cons (make-type-constraint .t|42 .rep|38 .krep|38) '()))) (let () (cons .t1|43|46 .t2|43|49))) (cons (make-type-constraint .t|42 .rep|38 .krep|38) '()))))))))))))) (.cs-intersect|2 .cs1|1 .cs2|1))))) 'cs-intersect))
(let () (begin (set! $gc.ephemeral 0) '$gc.ephemeral))
(let () (begin (set! $gc.tenuring 1) '$gc.tenuring))
(let () (begin (set! $gc.full 2) '$gc.full))
(let () (begin (set! $mstat.wallocated-hi 0) '$mstat.wallocated-hi))
(let () (begin (set! $mstat.wallocated-lo 1) '$mstat.wallocated-lo))
(let () (begin (set! $mstat.wcollected-hi 2) '$mstat.wcollected-hi))
(let () (begin (set! $mstat.wcollected-lo 3) '$mstat.wcollected-lo))
(let () (begin (set! $mstat.wcopied-hi 4) '$mstat.wcopied-hi))
(let () (begin (set! $mstat.wcopied-lo 5) '$mstat.wcopied-lo))
(let () (begin (set! $mstat.gctime 6) '$mstat.gctime))
(let () (begin (set! $mstat.wlive 7) '$mstat.wlive))
(let () (begin (set! $mstat.gc-last-gen 8) '$mstat.gc-last-gen))
(let () (begin (set! $mstat.gc-last-type 9) '$mstat.gc-last-type))
(let () (begin (set! $mstat.generations 10) '$mstat.generations))
(let () (begin (set! $mstat.g-gc-count 0) '$mstat.g-gc-count))
(let () (begin (set! $mstat.g-prom-count 1) '$mstat.g-prom-count))
(let () (begin (set! $mstat.g-gctime 2) '$mstat.g-gctime))
(let () (begin (set! $mstat.g-wlive 3) '$mstat.g-wlive))
(let () (begin (set! $mstat.g-np-youngp 4) '$mstat.g-np-youngp))
(let () (begin (set! $mstat.g-np-oldp 5) '$mstat.g-np-oldp))
(let () (begin (set! $mstat.g-np-j 6) '$mstat.g-np-j))
(let () (begin (set! $mstat.g-np-k 7) '$mstat.g-np-k))
(let () (begin (set! $mstat.g-alloc 8) '$mstat.g-alloc))
(let () (begin (set! $mstat.g-target 9) '$mstat.g-target))
(let () (begin (set! $mstat.g-promtime 10) '$mstat.g-promtime))
(let () (begin (set! $mstat.remsets 11) '$mstat.remsets))
(let () (begin (set! $mstat.r-apool 0) '$mstat.r-apool))
(let () (begin (set! $mstat.r-upool 1) '$mstat.r-upool))
(let () (begin (set! $mstat.r-ahash 2) '$mstat.r-ahash))
(let () (begin (set! $mstat.r-uhash 3) '$mstat.r-uhash))
(let () (begin (set! $mstat.r-hrec-hi 4) '$mstat.r-hrec-hi))
(let () (begin (set! $mstat.r-hrec-lo 5) '$mstat.r-hrec-lo))
(let () (begin (set! $mstat.r-hrem-hi 6) '$mstat.r-hrem-hi))
(let () (begin (set! $mstat.r-hrem-lo 7) '$mstat.r-hrem-lo))
(let () (begin (set! $mstat.r-hscan-hi 8) '$mstat.r-hscan-hi))
(let () (begin (set! $mstat.r-hscan-lo 9) '$mstat.r-hscan-lo))
(let () (begin (set! $mstat.r-wscan-hi 10) '$mstat.r-wscan-hi))
(let () (begin (set! $mstat.r-wscan-lo 11) '$mstat.r-wscan-lo))
(let () (begin (set! $mstat.r-ssbrec-hi 12) '$mstat.r-ssbrec-hi))
(let () (begin (set! $mstat.r-ssbrec-lo 13) '$mstat.r-ssbrec-lo))
(let () (begin (set! $mstat.r-np-p 14) '$mstat.r-np-p))
(let () (begin (set! $mstat.fflushed-hi 12) '$mstat.fflushed-hi))
(let () (begin (set! $mstat.fflushed-lo 13) '$mstat.fflushed-lo))
(let () (begin (set! $mstat.wflushed-hi 14) '$mstat.wflushed-hi))
(let () (begin (set! $mstat.wflushed-lo 15) '$mstat.wflushed-lo))
(let () (begin (set! $mstat.stk-created 16) '$mstat.stk-created))
(let () (begin (set! $mstat.frestored-hi 17) '$mstat.frestored-hi))
(let () (begin (set! $mstat.frestored-lo 18) '$mstat.frestored-lo))
(let () (begin (set! $mstat.words-heap 19) '$mstat.words-heap))
(let () (begin (set! $mstat.words-remset 20) '$mstat.words-remset))
(let () (begin (set! $mstat.words-rts 21) '$mstat.words-rts))
(let () (begin (set! $mstat.swb-assign 22) '$mstat.swb-assign))
(let () (begin (set! $mstat.swb-lhs-ok 23) '$mstat.swb-lhs-ok))
(let () (begin (set! $mstat.swb-rhs-const 24) '$mstat.swb-rhs-const))
(let () (begin (set! $mstat.swb-not-xgen 25) '$mstat.swb-not-xgen))
(let () (begin (set! $mstat.swb-trans 26) '$mstat.swb-trans))
(let () (begin (set! $mstat.rtime 27) '$mstat.rtime))
(let () (begin (set! $mstat.stime 28) '$mstat.stime))
(let () (begin (set! $mstat.utime 29) '$mstat.utime))
(let () (begin (set! $mstat.minfaults 30) '$mstat.minfaults))
(let () (begin (set! $mstat.majfaults 31) '$mstat.majfaults))
(let () (begin (set! $mstat.np-remsetp 32) '$mstat.np-remsetp))
(let () (begin (set! $mstat.max-heap 33) '$mstat.max-heap))
(let () (begin (set! $mstat.promtime 34) '$mstat.promtime))
(let () (begin (set! $mstat.wmoved-hi 35) '$mstat.wmoved-hi))
(let () (begin (set! $mstat.wmoved-lo 36) '$mstat.wmoved-lo))
(let () (begin (set! $mstat.vsize 37) '$mstat.vsize))
(let () (begin (set! $g.reg0 12) '$g.reg0))
(let () (begin (set! $r.reg8 44) '$r.reg8))
(let () (begin (set! $r.reg9 48) '$r.reg9))
(let () (begin (set! $r.reg10 52) '$r.reg10))
(let () (begin (set! $r.reg11 56) '$r.reg11))
(let () (begin (set! $r.reg12 60) '$r.reg12))
(let () (begin (set! $r.reg13 64) '$r.reg13))
(let () (begin (set! $r.reg14 68) '$r.reg14))
(let () (begin (set! $r.reg15 72) '$r.reg15))
(let () (begin (set! $r.reg16 76) '$r.reg16))
(let () (begin (set! $r.reg17 80) '$r.reg17))
(let () (begin (set! $r.reg18 84) '$r.reg18))
(let () (begin (set! $r.reg19 88) '$r.reg19))
(let () (begin (set! $r.reg20 92) '$r.reg20))
(let () (begin (set! $r.reg21 96) '$r.reg21))
(let () (begin (set! $r.reg22 100) '$r.reg22))
(let () (begin (set! $r.reg23 104) '$r.reg23))
(let () (begin (set! $r.reg24 108) '$r.reg24))
(let () (begin (set! $r.reg25 112) '$r.reg25))
(let () (begin (set! $r.reg26 116) '$r.reg26))
(let () (begin (set! $r.reg27 120) '$r.reg27))
(let () (begin (set! $r.reg28 124) '$r.reg28))
(let () (begin (set! $r.reg29 128) '$r.reg29))
(let () (begin (set! $r.reg30 132) '$r.reg30))
(let () (begin (set! $r.reg31 136) '$r.reg31))
(let () (begin (set! $g.stkbot 180) '$g.stkbot))
(let () (begin (set! $g.gccnt 420) '$g.gccnt))
(let () (begin (set! $m.alloc 1024) '$m.alloc))
(let () (begin (set! $m.alloci 1032) '$m.alloci))
(let () (begin (set! $m.gc 1040) '$m.gc))
(let () (begin (set! $m.addtrans 1048) '$m.addtrans))
(let () (begin (set! $m.stkoflow 1056) '$m.stkoflow))
(let () (begin (set! $m.stkuflow 1072) '$m.stkuflow))
(let () (begin (set! $m.creg 1080) '$m.creg))
(let () (begin (set! $m.creg-set! 1088) '$m.creg-set!))
(let () (begin (set! $m.add 1096) '$m.add))
(let () (begin (set! $m.subtract 1104) '$m.subtract))
(let () (begin (set! $m.multiply 1112) '$m.multiply))
(let () (begin (set! $m.quotient 1120) '$m.quotient))
(let () (begin (set! $m.remainder 1128) '$m.remainder))
(let () (begin (set! $m.divide 1136) '$m.divide))
(let () (begin (set! $m.modulo 1144) '$m.modulo))
(let () (begin (set! $m.negate 1152) '$m.negate))
(let () (begin (set! $m.numeq 1160) '$m.numeq))
(let () (begin (set! $m.numlt 1168) '$m.numlt))
(let () (begin (set! $m.numle 1176) '$m.numle))
(let () (begin (set! $m.numgt 1184) '$m.numgt))
(let () (begin (set! $m.numge 1192) '$m.numge))
(let () (begin (set! $m.zerop 1200) '$m.zerop))
(let () (begin (set! $m.complexp 1208) '$m.complexp))
(let () (begin (set! $m.realp 1216) '$m.realp))
(let () (begin (set! $m.rationalp 1224) '$m.rationalp))
(let () (begin (set! $m.integerp 1232) '$m.integerp))
(let () (begin (set! $m.exactp 1240) '$m.exactp))
(let () (begin (set! $m.inexactp 1248) '$m.inexactp))
(let () (begin (set! $m.exact->inexact 1256) '$m.exact->inexact))
(let () (begin (set! $m.inexact->exact 1264) '$m.inexact->exact))
(let () (begin (set! $m.make-rectangular 1272) '$m.make-rectangular))
(let () (begin (set! $m.real-part 1280) '$m.real-part))
(let () (begin (set! $m.imag-part 1288) '$m.imag-part))
(let () (begin (set! $m.sqrt 1296) '$m.sqrt))
(let () (begin (set! $m.round 1304) '$m.round))
(let () (begin (set! $m.truncate 1312) '$m.truncate))
(let () (begin (set! $m.apply 1320) '$m.apply))
(let () (begin (set! $m.varargs 1328) '$m.varargs))
(let () (begin (set! $m.typetag 1336) '$m.typetag))
(let () (begin (set! $m.typetag-set 1344) '$m.typetag-set))
(let () (begin (set! $m.break 1352) '$m.break))
(let () (begin (set! $m.eqv 1360) '$m.eqv))
(let () (begin (set! $m.partial-list->vector 1368) '$m.partial-list->vector))
(let () (begin (set! $m.timer-exception 1376) '$m.timer-exception))
(let () (begin (set! $m.exception 1384) '$m.exception))
(let () (begin (set! $m.singlestep 1392) '$m.singlestep))
(let () (begin (set! $m.syscall 1400) '$m.syscall))
(let () (begin (set! $m.bvlcmp 1408) '$m.bvlcmp))
(let () (begin (set! $m.enable-interrupts 1416) '$m.enable-interrupts))
(let () (begin (set! $m.disable-interrupts 1424) '$m.disable-interrupts))
(let () (begin (set! $m.alloc-bv 1432) '$m.alloc-bv))
(let () (begin (set! $m.global-ex 1440) '$m.global-ex))
(let () (begin (set! $m.invoke-ex 1448) '$m.invoke-ex))
(let () (begin (set! $m.global-invoke-ex 1456) '$m.global-invoke-ex))
(let () (begin (set! $m.argc-ex 1464) '$m.argc-ex))
(let () (begin (set! $r.g0 0) '$r.g0))
(let () (begin (set! $r.g1 1) '$r.g1))
(let () (begin (set! $r.g2 2) '$r.g2))
(let () (begin (set! $r.g3 3) '$r.g3))
(let () (begin (set! $r.g4 4) '$r.g4))
(let () (begin (set! $r.g5 5) '$r.g5))
(let () (begin (set! $r.g6 6) '$r.g6))
(let () (begin (set! $r.g7 7) '$r.g7))
(let () (begin (set! $r.o0 8) '$r.o0))
(let () (begin (set! $r.o1 9) '$r.o1))
(let () (begin (set! $r.o2 10) '$r.o2))
(let () (begin (set! $r.o3 11) '$r.o3))
(let () (begin (set! $r.o4 12) '$r.o4))
(let () (begin (set! $r.o5 13) '$r.o5))
(let () (begin (set! $r.o6 14) '$r.o6))
(let () (begin (set! $r.o7 15) '$r.o7))
(let () (begin (set! $r.l0 16) '$r.l0))
(let () (begin (set! $r.l1 17) '$r.l1))
(let () (begin (set! $r.l2 18) '$r.l2))
(let () (begin (set! $r.l3 19) '$r.l3))
(let () (begin (set! $r.l4 20) '$r.l4))
(let () (begin (set! $r.l5 21) '$r.l5))
(let () (begin (set! $r.l6 22) '$r.l6))
(let () (begin (set! $r.l7 23) '$r.l7))
(let () (begin (set! $r.i0 24) '$r.i0))
(let () (begin (set! $r.i1 25) '$r.i1))
(let () (begin (set! $r.i2 26) '$r.i2))
(let () (begin (set! $r.i3 27) '$r.i3))
(let () (begin (set! $r.i4 28) '$r.i4))
(let () (begin (set! $r.i5 29) '$r.i5))
(let () (begin (set! $r.i6 30) '$r.i6))
(let () (begin (set! $r.i7 31) '$r.i7))
(let () (begin (set! $r.result $r.o0) '$r.result))
(let () (begin (set! $r.argreg2 $r.o1) '$r.argreg2))
(let () (begin (set! $r.argreg3 $r.o2) '$r.argreg3))
(let () (begin (set! $r.stkp $r.o3) '$r.stkp))
(let () (begin (set! $r.stklim $r.i0) '$r.stklim))
(let () (begin (set! $r.tmp1 $r.o4) '$r.tmp1))
(let () (begin (set! $r.tmp2 $r.o5) '$r.tmp2))
(let () (begin (set! $r.tmp0 $r.g1) '$r.tmp0))
(let () (begin (set! $r.e-top $r.i0) '$r.e-top))
(let () (begin (set! $r.e-limit $r.o3) '$r.e-limit))
(let () (begin (set! $r.timer $r.i4) '$r.timer))
(let () (begin (set! $r.millicode $r.i7) '$r.millicode))
(let () (begin (set! $r.globals $r.i7) '$r.globals))
(let () (begin (set! $r.reg0 $r.l0) '$r.reg0))
(let () (begin (set! $r.reg1 $r.l1) '$r.reg1))
(let () (begin (set! $r.reg2 $r.l2) '$r.reg2))
(let () (begin (set! $r.reg3 $r.l3) '$r.reg3))
(let () (begin (set! $r.reg4 $r.l4) '$r.reg4))
(let () (begin (set! $r.reg5 $r.l5) '$r.reg5))
(let () (begin (set! $r.reg6 $r.l6) '$r.reg6))
(let () (begin (set! $r.reg7 $r.l7) '$r.reg7))
(let () (begin (set! $ex.car 0) '$ex.car))
(let () (begin (set! $ex.cdr 1) '$ex.cdr))
(let () (begin (set! $ex.setcar 2) '$ex.setcar))
(let () (begin (set! $ex.setcdr 3) '$ex.setcdr))
(let () (begin (set! $ex.add 10) '$ex.add))
(let () (begin (set! $ex.sub 11) '$ex.sub))
(let () (begin (set! $ex.mul 12) '$ex.mul))
(let () (begin (set! $ex.div 13) '$ex.div))
(let () (begin (set! $ex.lessp 14) '$ex.lessp))
(let () (begin (set! $ex.lesseqp 15) '$ex.lesseqp))
(let () (begin (set! $ex.equalp 16) '$ex.equalp))
(let () (begin (set! $ex.greatereqp 17) '$ex.greatereqp))
(let () (begin (set! $ex.greaterp 18) '$ex.greaterp))
(let () (begin (set! $ex.quotient 19) '$ex.quotient))
(let () (begin (set! $ex.remainder 20) '$ex.remainder))
(let () (begin (set! $ex.modulo 21) '$ex.modulo))
(let () (begin (set! $ex.logior 22) '$ex.logior))
(let () (begin (set! $ex.logand 23) '$ex.logand))
(let () (begin (set! $ex.logxor 24) '$ex.logxor))
(let () (begin (set! $ex.lognot 25) '$ex.lognot))
(let () (begin (set! $ex.lsh 26) '$ex.lsh))
(let () (begin (set! $ex.rsha 27) '$ex.rsha))
(let () (begin (set! $ex.rshl 28) '$ex.rshl))
(let () (begin (set! $ex.e2i 29) '$ex.e2i))
(let () (begin (set! $ex.i2e 30) '$ex.i2e))
(let () (begin (set! $ex.exactp 31) '$ex.exactp))
(let () (begin (set! $ex.inexactp 32) '$ex.inexactp))
(let () (begin (set! $ex.round 33) '$ex.round))
(let () (begin (set! $ex.trunc 34) '$ex.trunc))
(let () (begin (set! $ex.zerop 35) '$ex.zerop))
(let () (begin (set! $ex.neg 36) '$ex.neg))
(let () (begin (set! $ex.abs 37) '$ex.abs))
(let () (begin (set! $ex.realpart 38) '$ex.realpart))
(let () (begin (set! $ex.imagpart 39) '$ex.imagpart))
(let () (begin (set! $ex.vref 40) '$ex.vref))
(let () (begin (set! $ex.vset 41) '$ex.vset))
(let () (begin (set! $ex.vlen 42) '$ex.vlen))
(let () (begin (set! $ex.pref 50) '$ex.pref))
(let () (begin (set! $ex.pset 51) '$ex.pset))
(let () (begin (set! $ex.plen 52) '$ex.plen))
(let () (begin (set! $ex.sref 60) '$ex.sref))
(let () (begin (set! $ex.sset 61) '$ex.sset))
(let () (begin (set! $ex.slen 62) '$ex.slen))
(let () (begin (set! $ex.bvref 70) '$ex.bvref))
(let () (begin (set! $ex.bvset 71) '$ex.bvset))
(let () (begin (set! $ex.bvlen 72) '$ex.bvlen))
(let () (begin (set! $ex.bvlref 80) '$ex.bvlref))
(let () (begin (set! $ex.bvlset 81) '$ex.bvlset))
(let () (begin (set! $ex.bvllen 82) '$ex.bvllen))
(let () (begin (set! $ex.vlref 90) '$ex.vlref))
(let () (begin (set! $ex.vlset 91) '$ex.vlset))
(let () (begin (set! $ex.vllen 92) '$ex.vllen))
(let () (begin (set! $ex.typetag 100) '$ex.typetag))
(let () (begin (set! $ex.typetagset 101) '$ex.typetagset))
(let () (begin (set! $ex.apply 102) '$ex.apply))
(let () (begin (set! $ex.argc 103) '$ex.argc))
(let () (begin (set! $ex.vargc 104) '$ex.vargc))
(let () (begin (set! $ex.nonproc 105) '$ex.nonproc))
(let () (begin (set! $ex.undef-global 106) '$ex.undef-global))
(let () (begin (set! $ex.dump 107) '$ex.dump))
(let () (begin (set! $ex.dumpfail 108) '$ex.dumpfail))
(let () (begin (set! $ex.timer 109) '$ex.timer))
(let () (begin (set! $ex.unsupported 110) '$ex.unsupported))
(let () (begin (set! $ex.int2char 111) '$ex.int2char))
(let () (begin (set! $ex.char2int 112) '$ex.char2int))
(let () (begin (set! $ex.mkbvl 113) '$ex.mkbvl))
(let () (begin (set! $ex.mkvl 114) '$ex.mkvl))
(let () (begin (set! $ex.char<? 115) '$ex.char<?))
(let () (begin (set! $ex.char<=? 116) '$ex.char<=?))
(let () (begin (set! $ex.char=? 117) '$ex.char=?))
(let () (begin (set! $ex.char>? 118) '$ex.char>?))
(let () (begin (set! $ex.char>=? 119) '$ex.char>=?))
(let () (begin (set! $ex.bvfill 120) '$ex.bvfill))
(let () (begin (set! $ex.enable-interrupts 121) '$ex.enable-interrupts))
(let () (begin (set! $ex.keyboard-interrupt 122) '$ex.keyboard-interrupt))
(let () (begin (set! $ex.arithmetic-exception 123) '$ex.arithmetic-exception))
(let () (begin (set! $ex.global-invoke 124) '$ex.global-invoke))
(let () (begin (set! $ex.fx+ 140) '$ex.fx+))
(let () (begin (set! $ex.fx- 141) '$ex.fx-))
(let () (begin (set! $ex.fx-- 142) '$ex.fx--))
(let () (begin (set! $ex.fx= 143) '$ex.fx=))
(let () (begin (set! $ex.fx< 144) '$ex.fx<))
(let () (begin (set! $ex.fx<= 145) '$ex.fx<=))
(let () (begin (set! $ex.fx> 146) '$ex.fx>))
(let () (begin (set! $ex.fx>= 147) '$ex.fx>=))
(let () (begin (set! $ex.fxpositive? 148) '$ex.fxpositive?))
(let () (begin (set! $ex.fxnegative? 149) '$ex.fxnegative?))
(let () (begin (set! $ex.fxzero? 150) '$ex.fxzero?))
(let () (begin (set! $ex.fx* 151) '$ex.fx*))
(let () (begin (set! $tag.tagmask 7) '$tag.tagmask))
(let () (begin (set! $tag.pair-tag 1) '$tag.pair-tag))
(let () (begin (set! $tag.vector-tag 3) '$tag.vector-tag))
(let () (begin (set! $tag.bytevector-tag 5) '$tag.bytevector-tag))
(let () (begin (set! $tag.procedure-tag 7) '$tag.procedure-tag))
(let () (begin (set! $imm.vector-header 162) '$imm.vector-header))
(let () (begin (set! $imm.bytevector-header 194) '$imm.bytevector-header))
(let () (begin (set! $imm.procedure-header 254) '$imm.procedure-header))
(let () (begin (set! $imm.true 6) '$imm.true))
(let () (begin (set! $imm.false 2) '$imm.false))
(let () (begin (set! $imm.null 10) '$imm.null))
(let () (begin (set! $imm.unspecified 278) '$imm.unspecified))
(let () (begin (set! $imm.eof 534) '$imm.eof))
(let () (begin (set! $imm.undefined 790) '$imm.undefined))
(let () (begin (set! $imm.character 38) '$imm.character))
(let () (begin (set! $tag.vector-typetag 0) '$tag.vector-typetag))
(let () (begin (set! $tag.rectnum-typetag 4) '$tag.rectnum-typetag))
(let () (begin (set! $tag.ratnum-typetag 8) '$tag.ratnum-typetag))
(let () (begin (set! $tag.symbol-typetag 12) '$tag.symbol-typetag))
(let () (begin (set! $tag.port-typetag 16) '$tag.port-typetag))
(let () (begin (set! $tag.structure-typetag 20) '$tag.structure-typetag))
(let () (begin (set! $tag.bytevector-typetag 0) '$tag.bytevector-typetag))
(let () (begin (set! $tag.string-typetag 4) '$tag.string-typetag))
(let () (begin (set! $tag.flonum-typetag 8) '$tag.flonum-typetag))
(let () (begin (set! $tag.compnum-typetag 12) '$tag.compnum-typetag))
(let () (begin (set! $tag.bignum-typetag 16) '$tag.bignum-typetag))
(let () (begin (set! $hdr.port 178) '$hdr.port))
(let () (begin (set! $hdr.struct 182) '$hdr.struct))
(let () (begin (set! $p.codevector -3) '$p.codevector))
(let () (begin (set! $p.constvector 1) '$p.constvector))
(let () (begin (set! $p.linkoffset 5) '$p.linkoffset))
(let () (begin (set! $p.reg0 5) '$p.reg0))
(let () (begin (set! $p.codeoffset -1) '$p.codeoffset))
(let () (begin (set! twobit-sort (lambda (.less?|1 .list|1) (compat:sort .list|1 .less?|1))) 'twobit-sort))
(let () (begin (set! renaming-prefix ".") 'renaming-prefix))
(let () (begin (set! cell-prefix (string-append renaming-prefix "CELL:")) 'cell-prefix))
(let () (begin (set! name:check! '.check!) 'name:check!))
(let () (begin (set! name:cons '.cons) 'name:cons))
(let () (begin (set! name:list '.list) 'name:list))
(let () (begin (set! name:make-cell '.make-cell) 'name:make-cell))
(let () (begin (set! name:cell-ref '.cell-ref) 'name:cell-ref))
(let () (begin (set! name:cell-set! '.cell-set!) 'name:cell-set!))
(let () (begin (set! name:ignored (string->symbol "IGNORED")) 'name:ignored))
(let () (begin (set! name:car '.car) 'name:car))
(let () (begin (set! name:cdr '.cdr) 'name:cdr))
(let () (begin (set! name:not 'not) 'name:not))
(let () (begin (set! name:memq 'memq) 'name:memq))
(let () (begin (set! name:memv 'memv) 'name:memv))
(let () (begin (set! name:eq? 'eq?) 'name:eq?))
(let () (begin (set! name:eqv? 'eqv?) 'name:eqv?))
(let () (begin (set! name:fixnum? 'fixnum?) 'name:fixnum?))
(let () (begin (set! name:char? 'char?) 'name:char?))
(let () (begin (set! name:symbol? 'symbol?) 'name:symbol?))
(let () (begin (set! name:fx< '<:fix:fix) 'name:fx<))
(let () (begin (set! name:fx- 'fx-) 'name:fx-))
(let () (begin (set! name:char->integer 'char->integer) 'name:char->integer))
(let () (begin (set! name:vector-ref 'vector-ref:trusted) 'name:vector-ref))
(let () (begin (set! constant-folding-entry (lambda (.name|1) (let ((.constant-folding-entry|2 0)) (begin (set! .constant-folding-entry|2 (lambda (.name|3) (assq .name|3 $usual-constant-folding-procedures$))) (.constant-folding-entry|2 .name|1))))) 'constant-folding-entry))
(let () (begin (set! constant-folding-predicates cadr) 'constant-folding-predicates))
(let () (begin (set! constant-folding-folder caddr) 'constant-folding-folder))
(let () (begin (set! $usual-constant-folding-procedures$ (let ((.always?|3 (lambda (.x|1468) #t)) (.charcode?|3 (lambda (.n|1469) (if (number? .n|1469) (if (exact? .n|1469) (if (<= 0 .n|1469) (< .n|1469 128) #f) #f) #f))) (.ratnum?|3 (lambda (.n|1474) (if (number? .n|1474) (if (exact? .n|1474) (rational? .n|1474) #f) #f))) (.smallint?|3 (lambda (.n|1478) (smallint? .n|1478)))) (.cons (.cons 'integer->char (.cons (.cons .charcode?|3 '()) (.cons integer->char '()))) (.cons (.cons 'char->integer (.cons (.cons char? '()) (.cons char->integer '()))) (.cons (.cons 'zero? (.cons (.cons .ratnum?|3 '()) (.cons zero? '()))) (.cons (.cons '< (.cons (.cons .ratnum?|3 (.cons .ratnum?|3 '())) (.cons < '()))) (.cons (.cons '<= (.cons (.cons .ratnum?|3 (.cons .ratnum?|3 '())) (.cons <= '()))) (.cons (.cons '= (.cons (.cons .ratnum?|3 (.cons .ratnum?|3 '())) (.cons = '()))) (.cons (.cons '>= (.cons (.cons .ratnum?|3 (.cons .ratnum?|3 '())) (.cons >= '()))) (.cons (.cons '> (.cons (.cons .ratnum?|3 (.cons .ratnum?|3 '())) (.cons > '()))) (.cons (.cons '+ (.cons (.cons .ratnum?|3 (.cons .ratnum?|3 '())) (.cons + '()))) (.cons (.cons '- (.cons (.cons .ratnum?|3 (.cons .ratnum?|3 '())) (.cons - '()))) (.cons (.cons '* (.cons (.cons .ratnum?|3 (.cons .ratnum?|3 '())) (.cons * '()))) (.cons (.cons '-- (.cons (.cons .ratnum?|3 '()) (.cons (lambda (.x|1467) (- 0 .x|1467)) '()))) (.cons (.cons 'eq? (.cons (.cons .always?|3 (.cons .always?|3 '())) (.cons eq? '()))) (.cons (.cons 'eqv? (.cons (.cons .always?|3 (.cons .always?|3 '())) (.cons eqv? '()))) (.cons (.cons 'equal? (.cons (.cons .always?|3 (.cons .always?|3 '())) (.cons equal? '()))) (.cons (.cons 'memq (.cons (.cons .always?|3 (.cons list? '())) (.cons memq '()))) (.cons (.cons 'memv (.cons (.cons .always?|3 (.cons list? '())) (.cons memv '()))) (.cons (.cons 'member (.cons (.cons .always?|3 (.cons list? '())) (.cons member '()))) (.cons (.cons 'assq (.cons (.cons .always?|3 (.cons list? '())) (.cons assq '()))) (.cons (.cons 'assv (.cons (.cons .always?|3 (.cons list? '())) (.cons assv '()))) (.cons (.cons 'assoc (.cons (.cons .always?|3 (.cons list? '())) (.cons assoc '()))) (.cons (.cons 'length (.cons (.cons list? '()) (.cons length '()))) (.cons (.cons 'fixnum? (.cons (.cons .smallint?|3 '()) (.cons .smallint?|3 '()))) (.cons (.cons '=:fix:fix (.cons (.cons .smallint?|3 (.cons .smallint?|3 '())) (.cons = '()))) (.cons (.cons '<:fix:fix (.cons (.cons .smallint?|3 (.cons .smallint?|3 '())) (.cons < '()))) (.cons (.cons '<=:fix:fix (.cons (.cons .smallint?|3 (.cons .smallint?|3 '())) (.cons <= '()))) (.cons (.cons '>:fix:fix (.cons (.cons .smallint?|3 (.cons .smallint?|3 '())) (.cons > '()))) (.cons (.cons '>=:fix:fix (.cons (.cons .smallint?|3 (.cons .smallint?|3 '())) (.cons >= '()))) '())))))))))))))))))))))))))))))) '$usual-constant-folding-procedures$))
(let () (begin '(define (.check! flag exn . args) (if (not flag) (apply error "Runtime check exception: " exn args))) #t))
(let () (let () (let ((.loop|6|8|11 (unspecified))) (begin (set! .loop|6|8|11 (lambda (.y1|1|2|12) (if (null? .y1|1|2|12) (if #f #f (unspecified)) (begin (begin #t (pass1 (let ((.x|16|19 .y1|1|2|12)) (begin (.check! (pair? .x|16|19) 0 .x|16|19) (car:pair .x|16|19))))) (.loop|6|8|11 (let ((.x|20|23 .y1|1|2|12)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23)))))))) (.loop|6|8|11 (.cons (.cons 'define-inline (.cons 'car (.cons (.cons 'syntax-rules (.cons '() (.cons (.cons '(car x0) (.cons (.cons 'let (.cons '((x x0)) (.cons (.cons '.check! (.cons '(pair? x) (.cons $ex.car '(x)))) '((car:pair x))))) '())) '()))) '()))) (.cons (.cons 'define-inline (.cons 'cdr (.cons (.cons 'syntax-rules (.cons '() (.cons (.cons '(car x0) (.cons (.cons 'let (.cons '((x x0)) (.cons (.cons '.check! (.cons '(pair? x) (.cons $ex.cdr '(x)))) '((cdr:pair x))))) '())) '()))) '()))) (.cons (.cons 'define-inline (.cons 'vector-length (.cons (.cons 'syntax-rules (.cons '() (.cons (.cons '(vector-length v0) (.cons (.cons 'let (.cons '((v v0)) (.cons (.cons '.check! (.cons '(vector? v) (.cons $ex.vlen '(v)))) '((vector-length:vec v))))) '())) '()))) '()))) (.cons (.cons 'define-inline (.cons 'vector-ref (.cons (.cons 'syntax-rules (.cons '() (.cons (.cons '(vector-ref v0 i0) (.cons (.cons 'let (.cons '((v v0) (i i0)) (.cons (.cons '.check! (.cons '(fixnum? i) (.cons $ex.vref '(v i)))) (.cons (.cons '.check! (.cons '(vector? v) (.cons $ex.vref '(v i)))) (.cons (.cons '.check! (.cons '(<:fix:fix i (vector-length:vec v)) (.cons $ex.vref '(v i)))) (.cons (.cons '.check! (.cons '(>=:fix:fix i 0) (.cons $ex.vref '(v i)))) '((vector-ref:trusted v i)))))))) '())) '()))) '()))) (.cons (.cons 'define-inline (.cons 'vector-set! (.cons (.cons 'syntax-rules (.cons '() (.cons (.cons '(vector-set! v0 i0 x0) (.cons (.cons 'let (.cons '((v v0) (i i0) (x x0)) (.cons (.cons '.check! (.cons '(fixnum? i) (.cons $ex.vset '(v i x)))) (.cons (.cons '.check! (.cons '(vector? v) (.cons $ex.vset '(v i x)))) (.cons (.cons '.check! (.cons '(<:fix:fix i (vector-length:vec v)) (.cons $ex.vset '(v i x)))) (.cons (.cons '.check! (.cons '(>=:fix:fix i 0) (.cons $ex.vset '(v i x)))) '((vector-set!:trusted v i x)))))))) '())) '()))) '()))) '((define-inline list (syntax-rules () ((list) '()) ((list ?e) (cons ?e '())) ((list ?e1 ?e2 ...) (let* ((t1 ?e1) (t2 (list ?e2 ...))) (cons t1 t2))))) (define-inline vector (syntax-rules () ((vector) '#()) ((vector ?e) (make-vector 1 ?e)) ((vector ?e1 ?e2 ...) (letrec-syntax ((vector-aux1 (... (syntax-rules () ((vector-aux1 () ?n ?exps ?indexes ?temps) (vector-aux2 ?n ?exps ?indexes ?temps)) ((vector-aux1 (?exp1 ?exp2 ...) ?n ?exps ?indexes ?temps) (vector-aux1 (?exp2 ...) (+ ?n 1) (?exp1 . ?exps) (?n . ?indexes) (t . ?temps)))))) (vector-aux2 (... (syntax-rules () ((vector-aux2 ?n (?exp1 ?exp2 ...) (?n1 ?n2 ...) (?t1 ?t2 ...)) (let* ((?t1 ?exp1) (?t2 ?exp2) ... (v (make-vector ?n ?t1))) (vector-set! v ?n2 ?t2) ... v)))))) (vector-aux1 (?e1 ?e2 ...) 0 () () ()))))) (define-inline cadddr (syntax-rules () ((cadddr ?e) (car (cdr (cdr (cdr ?e))))))) (define-inline cddddr (syntax-rules () ((cddddr ?e) (cdr (cdr (cdr (cdr ?e))))))) (define-inline cdddr (syntax-rules () ((cdddr ?e) (cdr (cdr (cdr ?e)))))) (define-inline caddr (syntax-rules () ((caddr ?e) (car (cdr (cdr ?e)))))) (define-inline cddr (syntax-rules () ((cddr ?e) (cdr (cdr ?e))))) (define-inline cdar (syntax-rules () ((cdar ?e) (cdr (car ?e))))) (define-inline cadr (syntax-rules () ((cadr ?e) (car (cdr ?e))))) (define-inline caar (syntax-rules () ((caar ?e) (car (car ?e))))) (define-inline make-vector (syntax-rules () ((make-vector ?n) (make-vector ?n '())))) (define-inline make-string (syntax-rules () ((make-string ?n) (make-string ?n #\space)))) (define-inline = (syntax-rules () ((= ?e1 ?e2 ?e3 ?e4 ...) (let ((t ?e2)) (and (= ?e1 t) (= t ?e3 ?e4 ...)))))) (define-inline < (syntax-rules () ((< ?e1 ?e2 ?e3 ?e4 ...) (let ((t ?e2)) (and (< ?e1 t) (< t ?e3 ?e4 ...)))))) (define-inline > (syntax-rules () ((> ?e1 ?e2 ?e3 ?e4 ...) (let ((t ?e2)) (and (> ?e1 t) (> t ?e3 ?e4 ...)))))) (define-inline <= (syntax-rules () ((<= ?e1 ?e2 ?e3 ?e4 ...) (let ((t ?e2)) (and (<= ?e1 t) (<= t ?e3 ?e4 ...)))))) (define-inline >= (syntax-rules () ((>= ?e1 ?e2 ?e3 ?e4 ...) (let ((t ?e2)) (and (>= ?e1 t) (>= t ?e3 ?e4 ...)))))) (define-inline + (syntax-rules () ((+) 0) ((+ ?e) ?e) ((+ ?e1 ?e2 ?e3 ?e4 ...) (+ (+ ?e1 ?e2) ?e3 ?e4 ...)))) (define-inline * (syntax-rules () ((*) 1) ((* ?e) ?e) ((* ?e1 ?e2 ?e3 ?e4 ...) (* (* ?e1 ?e2) ?e3 ?e4 ...)))) (define-inline - (syntax-rules () ((- ?e) (- 0 ?e)) ((- ?e1 ?e2 ?e3 ?e4 ...) (- (- ?e1 ?e2) ?e3 ?e4 ...)))) (define-inline / (syntax-rules () ((/ ?e) (/ 1 ?e)) ((/ ?e1 ?e2 ?e3 ?e4 ...) (/ (/ ?e1 ?e2) ?e3 ?e4 ...)))) (define-inline abs (syntax-rules () ((abs ?z) (let ((temp ?z)) (if (< temp 0) (-- temp) temp))))) (define-inline negative? (syntax-rules () ((negative? ?x) (< ?x 0)))) (define-inline positive? (syntax-rules () ((positive? ?x) (> ?x 0)))) (define-inline eqv? (transformer (lambda (exp rename compare) (let ((arg1 (cadr exp)) (arg2 (caddr exp))) (define (constant? exp) (or (boolean? exp) (char? exp) (and (pair? exp) (= (length exp) 2) (identifier? (car exp)) (compare (car exp) (rename 'quote)) (symbol? (cadr exp))))) (if (or (constant? arg1) (constant? arg2)) (cons (rename 'eq?) (cdr exp)) exp))))) (define-inline memq (syntax-rules (quote) ((memq ?expr '(?datum ...)) (letrec-syntax ((memq0 (... (syntax-rules (quote) ((memq0 '?xx '(?d ...)) (let ((t1 '(?d ...))) (memq1 '?xx t1 (?d ...)))) ((memq0 ?e '(?d ...)) (let ((t0 ?e) (t1 '(?d ...))) (memq1 t0 t1 (?d ...))))))) (memq1 (... (syntax-rules () ((memq1 ?t0 ?t1 ()) #f) ((memq1 ?t0 ?t1 (?d1 ?d2 ...)) (if (eq? ?t0 '?d1) ?t1 (let ((?t1 (cdr ?t1))) (memq1 ?t0 ?t1 (?d2 ...))))))))) (memq0 ?expr '(?datum ...)))))) (define-inline memv (transformer (lambda (exp rename compare) (let ((arg1 (cadr exp)) (arg2 (caddr exp))) (if (or (boolean? arg1) (fixnum? arg1) (char? arg1) (and (pair? arg1) (= (length arg1) 2) (identifier? (car arg1)) (compare (car arg1) (rename 'quote)) (symbol? (cadr arg1))) (and (pair? arg2) (= (length arg2) 2) (identifier? (car arg2)) (compare (car arg2) (rename 'quote)) (every1? (lambda (x) (or (boolean? x) (fixnum? x) (char? x) (symbol? x))) (cadr arg2)))) (cons (rename 'memq) (cdr exp)) exp))))) (define-inline assv (transformer (lambda (exp rename compare) (let ((arg1 (cadr exp)) (arg2 (caddr exp))) (if (or (boolean? arg1) (char? arg1) (and (pair? arg1) (= (length arg1) 2) (identifier? (car arg1)) (compare (car arg1) (rename 'quote)) (symbol? (cadr arg1))) (and (pair? arg2) (= (length arg2) 2) (identifier? (car arg2)) (compare (car arg2) (rename 'quote)) (every1? (lambda (y) (and (pair? y) (let ((x (car y))) (or (boolean? x) (char? x) (symbol? x))))) (cadr arg2)))) (cons (rename 'assq) (cdr exp)) exp))))) (define-inline map (syntax-rules (lambda) ((map ?proc ?exp1 ?exp2 ...) (letrec-syntax ((loop (... (syntax-rules (lambda) ((loop 1 () (?y1 ?y2 ...) ?f ?exprs) (loop 2 (?y1 ?y2 ...) ?f ?exprs)) ((loop 1 (?a1 ?a2 ...) (?y2 ...) ?f ?exprs) (loop 1 (?a2 ...) (y1 ?y2 ...) ?f ?exprs)) ((loop 2 ?ys (lambda ?formals ?body) ?exprs) (loop 3 ?ys (lambda ?formals ?body) ?exprs)) ((loop 2 ?ys (?f1 . ?f2) ?exprs) (let ((f (?f1 . ?f2))) (loop 3 ?ys f ?exprs))) ((loop 2 ?ys ?f ?exprs) (loop 3 ?ys ?f ?exprs)) ((loop 3 (?y1 ?y2 ...) ?f (?e1 ?e2 ...)) (do ((?y1 ?e1 (cdr ?y1)) (?y2 ?e2 (cdr ?y2)) ... (results '() (cons (?f (car ?y1) (car ?y2) ...) results))) ((or (null? ?y1) (null? ?y2) ...) (reverse results)))))))) (loop 1 (?exp1 ?exp2 ...) () ?proc (?exp1 ?exp2 ...)))))) (define-inline for-each (syntax-rules (lambda) ((for-each ?proc ?exp1 ?exp2 ...) (letrec-syntax ((loop (... (syntax-rules (lambda) ((loop 1 () (?y1 ?y2 ...) ?f ?exprs) (loop 2 (?y1 ?y2 ...) ?f ?exprs)) ((loop 1 (?a1 ?a2 ...) (?y2 ...) ?f ?exprs) (loop 1 (?a2 ...) (y1 ?y2 ...) ?f ?exprs)) ((loop 2 ?ys (lambda ?formals ?body) ?exprs) (loop 3 ?ys (lambda ?formals ?body) ?exprs)) ((loop 2 ?ys (?f1 . ?f2) ?exprs) (let ((f (?f1 . ?f2))) (loop 3 ?ys f ?exprs))) ((loop 2 ?ys ?f ?exprs) (loop 3 ?ys ?f ?exprs)) ((loop 3 (?y1 ?y2 ...) ?f (?e1 ?e2 ...)) (do ((?y1 ?e1 (cdr ?y1)) (?y2 ?e2 (cdr ?y2)) ...) ((or (null? ?y1) (null? ?y2) ...) (if #f #f)) (?f (car ?y1) (car ?y2) ...))))))) (loop 1 (?exp1 ?exp2 ...) () ?proc (?exp1 ?exp2 ...)))))))))))))))))
(let () (begin (set! extended-syntactic-environment (syntactic-copy global-syntactic-environment)) 'extended-syntactic-environment))
(let () (begin (set! make-extended-syntactic-environment (lambda () (let ((.make-extended-syntactic-environment|2 0)) (begin (set! .make-extended-syntactic-environment|2 (lambda () (syntactic-copy extended-syntactic-environment))) (.make-extended-syntactic-environment|2))))) 'make-extended-syntactic-environment))
(let () (begin (set! instruction.op car) 'instruction.op))
(let () (begin (set! instruction.arg1 cadr) 'instruction.arg1))
(let () (begin (set! instruction.arg2 caddr) 'instruction.arg2))
(let () (begin (set! instruction.arg3 cadddr) 'instruction.arg3))
(let () (begin (set! *mnemonic-names* '()) '*mnemonic-names*))
(let () (begin '(define *last-reserved-mnemonic* 32767) '(define make-mnemonic (let ((count 0)) (lambda (name) (set! count (+ count 1)) (if (= count *last-reserved-mnemonic*) (error "Error in make-mnemonic: conflict: " name)) (set! *mnemonic-names* (cons (cons count name) *mnemonic-names*)) count))) '(define (reserved-mnemonic name value) (if (and (> value 0) (< value *last-reserved-mnemonic*)) (set! *last-reserved-mnemonic* value)) (set! *mnemonic-names* (cons (cons value name) *mnemonic-names*)) value) #t))
(let () (begin (set! make-mnemonic (let ((.count|3 0)) (lambda (.name|4) (begin (set! .count|3 (+ .count|3 1)) (set! *mnemonic-names* (cons (cons .count|3 .name|4) *mnemonic-names*)) .count|3)))) 'make-mnemonic))
(let () (begin (set! reserved-mnemonic (lambda (.name|1 .ignored|1) (let ((.reserved-mnemonic|2 0)) (begin (set! .reserved-mnemonic|2 (lambda (.name|3 .ignored|3) (make-mnemonic .name|3))) (.reserved-mnemonic|2 .name|1 .ignored|1))))) 'reserved-mnemonic))
(let () (begin (set! $.linearize (reserved-mnemonic '.linearize -1)) '$.linearize))
(let () (begin (set! $.label (reserved-mnemonic '.label 63)) '$.label))
(let () (begin (set! $.proc (reserved-mnemonic '.proc 62)) '$.proc))
(let () (begin (set! $.cont (reserved-mnemonic '.cont 61)) '$.cont))
(let () (begin (set! $.align (reserved-mnemonic '.align 60)) '$.align))
(let () (begin (set! $.asm (reserved-mnemonic '.asm 59)) '$.asm))
(let () (begin (set! $.proc-doc (reserved-mnemonic '.proc-doc 58)) '$.proc-doc))
(let () (begin (set! $.end (reserved-mnemonic '.end 57)) '$.end))
(let () (begin (set! $.singlestep (reserved-mnemonic '.singlestep 56)) '$.singlestep))
(let () (begin (set! $.entry (reserved-mnemonic '.entry 55)) '$.entry))
(let () (begin (set! $op1 (make-mnemonic 'op1)) '$op1))
(let () (begin (set! $op2 (make-mnemonic 'op2)) '$op2))
(let () (begin (set! $op3 (make-mnemonic 'op3)) '$op3))
(let () (begin (set! $op2imm (make-mnemonic 'op2imm)) '$op2imm))
(let () (begin (set! $const (make-mnemonic 'const)) '$const))
(let () (begin (set! $global (make-mnemonic 'global)) '$global))
(let () (begin (set! $setglbl (make-mnemonic 'setglbl)) '$setglbl))
(let () (begin (set! $lexical (make-mnemonic 'lexical)) '$lexical))
(let () (begin (set! $setlex (make-mnemonic 'setlex)) '$setlex))
(let () (begin (set! $stack (make-mnemonic 'stack)) '$stack))
(let () (begin (set! $setstk (make-mnemonic 'setstk)) '$setstk))
(let () (begin (set! $load (make-mnemonic 'load)) '$load))
(let () (begin (set! $store (make-mnemonic 'store)) '$store))
(let () (begin (set! $reg (make-mnemonic 'reg)) '$reg))
(let () (begin (set! $setreg (make-mnemonic 'setreg)) '$setreg))
(let () (begin (set! $movereg (make-mnemonic 'movereg)) '$movereg))
(let () (begin (set! $lambda (make-mnemonic 'lambda)) '$lambda))
(let () (begin (set! $lexes (make-mnemonic 'lexes)) '$lexes))
(let () (begin (set! $args= (make-mnemonic 'args=)) '$args=))
(let () (begin (set! $args>= (make-mnemonic 'args>=)) '$args>=))
(let () (begin (set! $invoke (make-mnemonic 'invoke)) '$invoke))
(let () (begin (set! $save (make-mnemonic 'save)) '$save))
(let () (begin (set! $setrtn (make-mnemonic 'setrtn)) '$setrtn))
(let () (begin (set! $restore (make-mnemonic 'restore)) '$restore))
(let () (begin (set! $pop (make-mnemonic 'pop)) '$pop))
(let () (begin (set! $popstk (make-mnemonic 'popstk)) '$popstk))
(let () (begin (set! $return (make-mnemonic 'return)) '$return))
(let () (begin (set! $mvrtn (make-mnemonic 'mvrtn)) '$mvrtn))
(let () (begin (set! $apply (make-mnemonic 'apply)) '$apply))
(let () (begin (set! $nop (make-mnemonic 'nop)) '$nop))
(let () (begin (set! $jump (make-mnemonic 'jump)) '$jump))
(let () (begin (set! $skip (make-mnemonic 'skip)) '$skip))
(let () (begin (set! $branch (make-mnemonic 'branch)) '$branch))
(let () (begin (set! $branchf (make-mnemonic 'branchf)) '$branchf))
(let () (begin (set! $check (make-mnemonic 'check)) '$check))
(let () (begin (set! $trap (make-mnemonic 'trap)) '$trap))
(let () (begin (set! @maxargs-with-rest-arg@ 30) '@maxargs-with-rest-arg@))
(let () (begin (set! *nregs* 32) '*nregs*))
(let () (begin (set! *lastreg* (- *nregs* 1)) '*lastreg*))
(let () (begin (set! *fullregs* (quotient *nregs* 2)) '*fullregs*))
(let () (begin (set! *nhwregs* 8) '*nhwregs*))
(let () (begin (set! *regnames* (let () (let ((.loop|1|4|7 (unspecified))) (begin (set! .loop|1|4|7 (lambda (.alist|8 .r|8) (if (<= .r|8 0) .alist|8 (begin #t (.loop|1|4|7 (cons (cons (string->symbol (string-append ".REG" (number->string .r|8))) .r|8) .alist|8) (- .r|8 1)))))) (.loop|1|4|7 '() (- *nhwregs* 1)))))) '*regnames*))
(let () (begin (set! *number-of-mnemonics* 72) '*number-of-mnemonics*))
(let () (begin (set! prim-entry (lambda (.name|1) (let ((.prim-entry|2 0)) (begin (set! .prim-entry|2 (lambda (.name|3) (assq .name|3 $usual-integrable-procedures$))) (.prim-entry|2 .name|1))))) 'prim-entry))
(let () (begin (set! prim-arity cadr) 'prim-arity))
(let () (begin (set! prim-opcodename caddr) 'prim-opcodename))
(let () (begin (set! prim-immediate? cadddr) 'prim-immediate?))
(let () (begin (set! prim-primcode (lambda (.entry|1) (let ((.prim-primcode|2 0)) (begin (set! .prim-primcode|2 (lambda (.entry|3) (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|21|24 .entry|3)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.prim-primcode|2 .entry|1))))) 'prim-primcode))
(let () (begin (set! smallint? (let* ((.least|3 (- 0 (expt 2 29))) (.greatest|6 (- (- 0 .least|3) 1))) (let () (lambda (.x|10) (if (number? .x|10) (if (exact? .x|10) (if (integer? .x|10) (let ((.t|15|18 .x|10)) (if (<= .least|3 .t|15|18) (<= .t|15|18 .greatest|6) #f)) #f) #f) #f))))) 'smallint?))
(let () (begin (set! sparc-imm? (lambda (.x|1) (let ((.sparc-imm?|2 0)) (begin (set! .sparc-imm?|2 (lambda (.x|3) (if (fixnum? .x|3) (let ((.t|6|9 .x|3)) (if (<= -1024 .t|6|9) (<= .t|6|9 1023) #f)) #f))) (.sparc-imm?|2 .x|1))))) 'sparc-imm?))
(let () (begin (set! sparc-eq-imm? (lambda (.x|1) (let ((.sparc-eq-imm?|2 0)) (begin (set! .sparc-eq-imm?|2 (lambda (.x|3) (let ((.temp|4|7 (sparc-imm? .x|3))) (if .temp|4|7 .temp|4|7 (let ((.temp|8|11 (eq? .x|3 #t))) (if .temp|8|11 .temp|8|11 (let ((.temp|12|15 (eq? .x|3 #f))) (if .temp|12|15 .temp|12|15 (eq? .x|3 '()))))))))) (.sparc-eq-imm?|2 .x|1))))) 'sparc-eq-imm?))
(let () (begin (set! valid-typetag? (lambda (.x|1) (let ((.valid-typetag?|2 0)) (begin (set! .valid-typetag?|2 (lambda (.x|3) (if (fixnum? .x|3) (let ((.t|6|9 .x|3)) (if (<= 0 .t|6|9) (<= .t|6|9 7) #f)) #f))) (.valid-typetag?|2 .x|1))))) 'valid-typetag?))
(let () (begin (set! fixnum-primitives (lambda () (let ((.fixnum-primitives|2 0)) (begin (set! .fixnum-primitives|2 (lambda () #t)) (.fixnum-primitives|2))))) 'fixnum-primitives))
(let () (begin (set! flonum-primitives (lambda () (let ((.flonum-primitives|2 0)) (begin (set! .flonum-primitives|2 (lambda () #t)) (.flonum-primitives|2))))) 'flonum-primitives))
(let () (begin (set! prim-lives-until (lambda (.entry|1) (let ((.prim-lives-until|2 0)) (begin (set! .prim-lives-until|2 (lambda (.entry|3) (list-ref .entry|3 5))) (.prim-lives-until|2 .entry|1))))) 'prim-lives-until))
(let () (begin (set! prim-kills (lambda (.entry|1) (let ((.prim-kills|2 0)) (begin (set! .prim-kills|2 (lambda (.entry|3) (list-ref .entry|3 6))) (.prim-kills|2 .entry|1))))) 'prim-kills))
(let () (begin (set! $usual-integrable-procedures$ (let ((.:globals|3 available:killer:globals) (.:car|3 available:killer:car) (.:cdr|3 available:killer:cdr) (.:string|3 available:killer:string) (.:vector|3 available:killer:vector) (.:cell|3 available:killer:cell) (.:io|3 available:killer:io) (.:none|3 available:killer:none) (.:all|3 available:killer:all) (.:immortal|3 available:killer:immortal) (.:dead|3 available:killer:dead)) (.cons (.cons 'break (.cons 0 (.cons 'break (.cons #f (.cons 3 (.cons .:dead|3 (.cons .:all|3 '()))))))) (.cons (.cons 'creg (.cons 0 (.cons 'creg (.cons #f (.cons 7 (.cons .:dead|3 (.cons .:all|3 '()))))))) (.cons (.cons 'unspecified (.cons 0 (.cons 'unspecified (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'undefined (.cons 0 (.cons 'undefined (.cons #f (.cons 8 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'eof-object (.cons 0 (.cons 'eof-object (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'enable-interrupts (.cons 1 (.cons 'enable-interrupts (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:all|3 '()))))))) (.cons (.cons 'disable-interrupts (.cons 0 (.cons 'disable-interrupts (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:all|3 '()))))))) (.cons (.cons 'typetag (.cons 1 (.cons 'typetag (.cons #f (.cons 17 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'not (.cons 1 (.cons 'not (.cons #f (.cons 24 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'null? (.cons 1 (.cons 'null? (.cons #f (.cons 25 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'pair? (.cons 1 (.cons 'pair? (.cons #f (.cons 26 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'eof-object? (.cons 1 (.cons 'eof-object? (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'port? (.cons 1 (.cons 'port? (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'structure? (.cons 1 (.cons 'structure? (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'car (.cons 1 (.cons 'car (.cons #f (.cons 27 (.cons .:car|3 (.cons .:none|3 '()))))))) (.cons (.cons name:car (.cons 1 (.cons 'car (.cons #f (.cons 27 (.cons .:car|3 (.cons .:none|3 '()))))))) (.cons (.cons 'cdr (.cons 1 (.cons 'cdr (.cons #f (.cons 28 (.cons .:cdr|3 (.cons .:none|3 '()))))))) (.cons (.cons name:cdr (.cons 1 (.cons 'cdr (.cons #f (.cons 28 (.cons .:cdr|3 (.cons .:none|3 '()))))))) (.cons (.cons 'symbol? (.cons 1 (.cons 'symbol? (.cons #f (.cons 31 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'number? (.cons 1 (.cons 'complex? (.cons #f (.cons 32 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'complex? (.cons 1 (.cons 'complex? (.cons #f (.cons 32 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'real? (.cons 1 (.cons 'rational? (.cons #f (.cons 33 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'rational? (.cons 1 (.cons 'rational? (.cons #f (.cons 33 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'integer? (.cons 1 (.cons 'integer? (.cons #f (.cons 34 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fixnum? (.cons 1 (.cons 'fixnum? (.cons #f (.cons 35 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'flonum? (.cons 1 (.cons 'flonum? (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'compnum? (.cons 1 (.cons 'compnum? (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'exact? (.cons 1 (.cons 'exact? (.cons #f (.cons 36 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'inexact? (.cons 1 (.cons 'inexact? (.cons #f (.cons 37 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'exact->inexact (.cons 1 (.cons 'exact->inexact (.cons #f (.cons 38 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'inexact->exact (.cons 1 (.cons 'inexact->exact (.cons #f (.cons 39 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'round (.cons 1 (.cons 'round (.cons #f (.cons 40 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'truncate (.cons 1 (.cons 'truncate (.cons #f (.cons 41 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'zero? (.cons 1 (.cons 'zero? (.cons #f (.cons 44 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '-- (.cons 1 (.cons '-- (.cons #f (.cons 45 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'lognot (.cons 1 (.cons 'lognot (.cons #f (.cons 47 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'real-part (.cons 1 (.cons 'real-part (.cons #f (.cons 62 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'imag-part (.cons 1 (.cons 'imag-part (.cons #f (.cons 63 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'char? (.cons 1 (.cons 'char? (.cons #f (.cons 64 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'char->integer (.cons 1 (.cons 'char->integer (.cons #f (.cons 65 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'integer->char (.cons 1 (.cons 'integer->char (.cons #f (.cons 66 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'string? (.cons 1 (.cons 'string? (.cons #f (.cons 80 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'string-length (.cons 1 (.cons 'string-length (.cons #f (.cons 81 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'vector? (.cons 1 (.cons 'vector? (.cons #f (.cons 82 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'vector-length (.cons 1 (.cons 'vector-length (.cons #f (.cons 83 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'bytevector? (.cons 1 (.cons 'bytevector? (.cons #f (.cons 84 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'bytevector-length (.cons 1 (.cons 'bytevector-length (.cons #f (.cons 85 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'bytevector-fill! (.cons 2 (.cons 'bytevector-fill! (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:string|3 '()))))))) (.cons (.cons 'make-bytevector (.cons 1 (.cons 'make-bytevector (.cons #f (.cons 86 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'procedure? (.cons 1 (.cons 'procedure? (.cons #f (.cons 88 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'procedure-length (.cons 1 (.cons 'procedure-length (.cons #f (.cons 89 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'make-procedure (.cons 1 (.cons 'make-procedure (.cons #f (.cons 90 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'creg-set! (.cons 1 (.cons 'creg-set! (.cons #f (.cons 113 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons name:make-cell (.cons 1 (.cons 'make-cell (.cons #f (.cons 126 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons name:cell-ref (.cons 1 (.cons 'cell-ref (.cons #f (.cons 127 (.cons .:cell|3 (.cons .:none|3 '()))))))) (.cons (.cons name:cell-set! (.cons 2 (.cons 'cell-set! (.cons #f (.cons 223 (.cons .:dead|3 (.cons .:cell|3 '()))))))) (.cons (.cons 'typetag-set! (.cons 2 (.cons 'typetag-set! (.cons valid-typetag? (.cons 160 (.cons .:dead|3 (.cons .:all|3 '()))))))) (.cons (.cons 'eq? (.cons 2 (.cons 'eq? (.cons sparc-eq-imm? (.cons 161 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'eqv? (.cons 2 (.cons 'eqv? (.cons #f (.cons 162 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'cons (.cons 2 (.cons 'cons (.cons #f (.cons 168 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons name:cons (.cons 2 (.cons 'cons (.cons #f (.cons 168 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'set-car! (.cons 2 (.cons 'set-car! (.cons #f (.cons 169 (.cons .:dead|3 (.cons .:car|3 '()))))))) (.cons (.cons 'set-cdr! (.cons 2 (.cons 'set-cdr! (.cons #f (.cons 170 (.cons .:dead|3 (.cons .:cdr|3 '()))))))) (.cons (.cons '+ (.cons 2 (.cons '+ (.cons sparc-imm? (.cons 176 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '- (.cons 2 (.cons '- (.cons sparc-imm? (.cons 177 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '* (.cons 2 (.cons '* (.cons sparc-imm? (.cons 178 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '/ (.cons 2 (.cons '/ (.cons #f (.cons 179 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'quotient (.cons 2 (.cons 'quotient (.cons #f (.cons 180 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '< (.cons 2 (.cons '< (.cons sparc-imm? (.cons 181 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '<= (.cons 2 (.cons '<= (.cons sparc-imm? (.cons 182 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '= (.cons 2 (.cons '= (.cons sparc-imm? (.cons 183 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '> (.cons 2 (.cons '> (.cons sparc-imm? (.cons 184 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '>= (.cons 2 (.cons '>= (.cons sparc-imm? (.cons 185 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'logand (.cons 2 (.cons 'logand (.cons #f (.cons 192 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'logior (.cons 2 (.cons 'logior (.cons #f (.cons 193 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'logxor (.cons 2 (.cons 'logxor (.cons #f (.cons 194 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'lsh (.cons 2 (.cons 'lsh (.cons #f (.cons 195 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'rsha (.cons 2 (.cons 'rsha (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'rshl (.cons 2 (.cons 'rshl (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'rot (.cons 2 (.cons 'rot (.cons #f (.cons 196 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'make-string (.cons 2 (.cons 'make-string (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'string-ref (.cons 2 (.cons 'string-ref (.cons sparc-imm? (.cons 209 (.cons .:string|3 (.cons .:none|3 '()))))))) (.cons (.cons 'string-set! (.cons 3 (.cons 'string-set! (.cons sparc-imm? (.cons -1 (.cons .:dead|3 (.cons .:string|3 '()))))))) (.cons (.cons 'make-vector (.cons 2 (.cons 'make-vector (.cons #f (.cons 210 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'vector-ref (.cons 2 (.cons 'vector-ref (.cons sparc-imm? (.cons 211 (.cons .:vector|3 (.cons .:none|3 '()))))))) (.cons (.cons 'bytevector-ref (.cons 2 (.cons 'bytevector-ref (.cons sparc-imm? (.cons 213 (.cons .:string|3 (.cons .:none|3 '()))))))) (.cons (.cons 'procedure-ref (.cons 2 (.cons 'procedure-ref (.cons #f (.cons 215 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'char<? (.cons 2 (.cons 'char<? (.cons char? (.cons 224 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'char<=? (.cons 2 (.cons 'char<=? (.cons char? (.cons 225 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'char=? (.cons 2 (.cons 'char=? (.cons char? (.cons 226 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'char>? (.cons 2 (.cons 'char>? (.cons char? (.cons 227 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'char>=? (.cons 2 (.cons 'char>=? (.cons char? (.cons 228 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'sys$partial-list->vector (.cons 2 (.cons 'sys$partial-list->vector (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:all|3 '()))))))) (.cons (.cons 'vector-set! (.cons 3 (.cons 'vector-set! (.cons #f (.cons 241 (.cons .:dead|3 (.cons .:vector|3 '()))))))) (.cons (.cons 'bytevector-set! (.cons 3 (.cons 'bytevector-set! (.cons #f (.cons 242 (.cons .:dead|3 (.cons .:string|3 '()))))))) (.cons (.cons 'procedure-set! (.cons 3 (.cons 'procedure-set! (.cons #f (.cons 243 (.cons .:dead|3 (.cons .:all|3 '()))))))) (.cons (.cons 'bytevector-like? (.cons 1 (.cons 'bytevector-like? (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'vector-like? (.cons 1 (.cons 'vector-like? (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'bytevector-like-ref (.cons 2 (.cons 'bytevector-like-ref (.cons #f (.cons -1 (.cons .:string|3 (.cons .:none|3 '()))))))) (.cons (.cons 'bytevector-like-set! (.cons 3 (.cons 'bytevector-like-set! (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:string|3 '()))))))) (.cons (.cons 'sys$bvlcmp (.cons 2 (.cons 'sys$bvlcmp (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:all|3 '()))))))) (.cons (.cons 'vector-like-ref (.cons 2 (.cons 'vector-like-ref (.cons #f (.cons -1 (.cons .:vector|3 (.cons .:none|3 '()))))))) (.cons (.cons 'vector-like-set! (.cons 3 (.cons 'vector-like-set! (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:vector|3 '()))))))) (.cons (.cons 'vector-like-length (.cons 1 (.cons 'vector-like-length (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'bytevector-like-length (.cons 1 (.cons 'bytevector-like-length (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'remainder (.cons 2 (.cons 'remainder (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'sys$read-char (.cons 1 (.cons 'sys$read-char (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:io|3 '()))))))) (.cons (.cons 'gc-counter (.cons 0 (.cons 'gc-counter (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:none|3 '()))))))) (append (if (fixnum-primitives) (.cons (.cons 'most-positive-fixnum (.cons 0 (.cons 'most-positive-fixnum (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'most-negative-fixnum (.cons 0 (.cons 'most-negative-fixnum (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx+ (.cons 2 (.cons 'fx+ (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx- (.cons 2 (.cons 'fx- (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx-- (.cons 1 (.cons 'fx-- (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx* (.cons 2 (.cons 'fx* (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx= (.cons 2 (.cons 'fx= (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx< (.cons 2 (.cons 'fx< (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx<= (.cons 2 (.cons 'fx<= (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx> (.cons 2 (.cons 'fx> (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fx>= (.cons 2 (.cons 'fx>= (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fxzero? (.cons 1 (.cons 'fxzero? (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fxpositive? (.cons 1 (.cons 'fxpositive? (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fxnegative? (.cons 1 (.cons 'fxnegative? (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) '())))))))))))))) '()) (append (if (flonum-primitives) (.cons (.cons 'fl+ (.cons 2 (.cons '+ (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fl- (.cons 2 (.cons '- (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fl-- (.cons 1 (.cons '-- (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fl* (.cons 2 (.cons '* (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fl= (.cons 2 (.cons '= (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fl< (.cons 2 (.cons '< (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fl<= (.cons 2 (.cons '<= (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fl> (.cons 2 (.cons '> (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'fl>= (.cons 2 (.cons '>= (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) '()))))))))) '()) (.cons (.cons name:check! (.cons -1 (.cons 'check! (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:none|3 '()))))))) (.cons (.cons 'vector-length:vec (.cons 1 (.cons 'vector-length:vec (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons 'vector-ref:trusted (.cons 2 (.cons 'vector-ref:trusted (.cons sparc-imm? (.cons -1 (.cons .:vector|3 (.cons .:none|3 '()))))))) (.cons (.cons 'vector-set!:trusted (.cons 3 (.cons 'vector-set!:trusted (.cons #f (.cons -1 (.cons .:dead|3 (.cons .:vector|3 '()))))))) (.cons (.cons 'car:pair (.cons 1 (.cons 'car:pair (.cons #f (.cons -1 (.cons .:car|3 (.cons .:none|3 '()))))))) (.cons (.cons 'cdr:pair (.cons 1 (.cons 'cdr:pair (.cons #f (.cons -1 (.cons .:cdr|3 (.cons .:none|3 '()))))))) (.cons (.cons '=:fix:fix (.cons 2 (.cons '=:fix:fix (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '<:fix:fix (.cons 2 (.cons '<:fix:fix (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '<=:fix:fix (.cons 2 (.cons '<=:fix:fix (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '>=:fix:fix (.cons 2 (.cons '>=:fix:fix (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '>:fix:fix (.cons 2 (.cons '>:fix:fix (.cons sparc-imm? (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '+:idx:idx (.cons 2 (.cons '+:idx:idx (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '+:fix:fix (.cons 2 (.cons '+:idx:idx (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '+:exi:exi (.cons 2 (.cons '+:idx:idx (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '+:flo:flo (.cons 2 (.cons '+:idx:idx (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '=:flo:flo (.cons 2 (.cons '=:flo:flo (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '=:obj:flo (.cons 2 (.cons '=:obj:flo (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) (.cons (.cons '=:flo:obj (.cons 2 (.cons '=:flo:obj (.cons #f (.cons -1 (.cons .:immortal|3 (.cons .:none|3 '()))))))) '())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) '$usual-integrable-procedures$))
(let () (begin (set! $immediate-primops$ '((typetag-set! 128) (eq? 129) (+ 130) (- 131) (< 132) (<= 133) (= 134) (> 135) (>= 136) (char<? 137) (char<=? 138) (char=? 139) (char>? 140) (char>=? 141) (string-ref 144) (vector-ref 145) (bytevector-ref 146) (bytevector-like-ref -1) (vector-like-ref -1) (fx+ -1) (fx- -1) (fx-- -1) (fx= -1) (fx< -1) (fx<= -1) (fx> -1) (fx>= -1))) '$immediate-primops$))
(let () (begin (set! $reg/op1/branchf (make-mnemonic 'reg/op1/branchf)) '$reg/op1/branchf))
(let () (begin (set! $reg/op2/branchf (make-mnemonic 'reg/op2/branchf)) '$reg/op2/branchf))
(let () (begin (set! $reg/op2imm/branchf (make-mnemonic 'reg/op2imm/branchf)) '$reg/op2imm/branchf))
(let () (begin (set! $reg/op1/check (make-mnemonic 'reg/op1/check)) '$reg/op1/check))
(let () (begin (set! $reg/op2/check (make-mnemonic 'reg/op2/check)) '$reg/op2/check))
(let () (begin (set! $reg/op2imm/check (make-mnemonic 'reg/op2imm/check)) '$reg/op2imm/check))
(let () (begin (set! $reg/op1/setreg (make-mnemonic 'reg/op1/setreg)) '$reg/op1/setreg))
(let () (begin (set! $reg/op2/setreg (make-mnemonic 'reg/op2/setreg)) '$reg/op2/setreg))
(let () (begin (set! $reg/op2imm/setreg (make-mnemonic 'reg/op2imm/setreg)) '$reg/op2imm/setreg))
(let () (begin (set! $reg/branchf (make-mnemonic 'reg/branchf)) '$reg/branchf))
(let () (begin (set! $reg/return (make-mnemonic 'reg/return)) '$reg/return))
(let () (begin (set! $reg/setglbl (make-mnemonic 'reg/setglbl)) '$reg/setglbl))
(let () (begin (set! $reg/op3 (make-mnemonic 'reg/op3)) '$reg/op3))
(let () (begin (set! $const/setreg (make-mnemonic 'const/setreg)) '$const/setreg))
(let () (begin (set! $const/return (make-mnemonic 'const/return)) '$const/return))
(let () (begin (set! $global/setreg (make-mnemonic 'global/setreg)) '$global/setreg))
(let () (begin (set! $setrtn/branch (make-mnemonic 'setrtn/branch)) '$setrtn/branch))
(let () (begin (set! $setrtn/invoke (make-mnemonic 'setrtn/invoke)) '$setrtn/invoke))
(let () (begin (set! $global/invoke (make-mnemonic 'global/invoke)) '$global/invoke))
(let () (begin (set! $cons 'cons) '$cons))
(let () (begin (set! $car:pair 'car) '$car:pair))
(let () (begin (set! $cdr:pair 'cdr) '$cdr:pair))
(let () (define-subtype 'true 'object))
(let () (define-subtype 'eqtype 'object))
(let () (define-subtype 'nonpointer 'eqtype))
(let () (define-subtype 'eqtype1 'eqtype))
(let () (define-subtype 'boolean 'nonpointer))
(let () (define-subtype 'truth 'eqtype1))
(let () (define-subtype 'truth 'boolean))
(let () (define-subtype 'false 'boolean))
(let () (define-subtype 'eqtype1 'true))
(let () (define-subtype 'procedure 'true))
(let () (define-subtype 'vector 'true))
(let () (define-subtype 'bytevector 'true))
(let () (define-subtype 'string 'true))
(let () (define-subtype 'pair 'true))
(let () (define-subtype 'emptylist 'eqtype1))
(let () (define-subtype 'emptylist 'nonpointer))
(let () (define-subtype 'symbol 'eqtype1))
(let () (define-subtype 'char 'eqtype1))
(let () (define-subtype 'char 'nonpointer))
(let () (define-subtype 'number 'true))
(let () (define-subtype 'inexact 'number))
(let () (define-subtype 'flonum 'inexact))
(let () (define-subtype 'integer 'number))
(let () (define-subtype 'exact 'number))
(let () (define-subtype 'exactint 'integer))
(let () (define-subtype 'exactint 'exact))
(let () (define-subtype 'fixnum 'exactint))
(let () (define-subtype '!fixnum 'fixnum))
(let () (define-subtype 'fixnum! 'fixnum))
(let () (define-subtype 'index '!fixnum))
(let () (define-subtype 'index 'fixnum!))
(let () (define-subtype 'zero 'index))
(let () (define-subtype 'fixnum 'eqtype1))
(let () (define-subtype 'fixnum 'nonpointer))
(let () (compute-type-structure!))
(let () (define-intersection 'true 'eqtype 'eqtype1))
(let () (define-intersection 'true 'boolean 'truth))
(let () (define-intersection 'exact 'integer 'exactint))
(let () (define-intersection '!fixnum 'fixnum! 'index))
(let () (begin (set! rep:min_fixnum (- 0 (expt 2 29))) 'rep:min_fixnum))
(let () (begin (set! rep:max_fixnum (- (expt 2 29) 1)) 'rep:max_fixnum))
(let () (begin (set! rep:max_index (- (expt 2 24) 1)) 'rep:max_index))
(let () (begin (set! rep:object (symbol->rep 'object)) 'rep:object))
(let () (begin (set! rep:true (symbol->rep 'true)) 'rep:true))
(let () (begin (set! rep:truth (symbol->rep 'truth)) 'rep:truth))
(let () (begin (set! rep:false (symbol->rep 'false)) 'rep:false))
(let () (begin (set! rep:boolean (symbol->rep 'boolean)) 'rep:boolean))
(let () (begin (set! rep:pair (symbol->rep 'pair)) 'rep:pair))
(let () (begin (set! rep:symbol (symbol->rep 'symbol)) 'rep:symbol))
(let () (begin (set! rep:number (symbol->rep 'number)) 'rep:number))
(let () (begin (set! rep:zero (symbol->rep 'zero)) 'rep:zero))
(let () (begin (set! rep:index (symbol->rep 'index)) 'rep:index))
(let () (begin (set! rep:fixnum (symbol->rep 'fixnum)) 'rep:fixnum))
(let () (begin (set! rep:exactint (symbol->rep 'exactint)) 'rep:exactint))
(let () (begin (set! rep:flonum (symbol->rep 'flonum)) 'rep:flonum))
(let () (begin (set! rep:exact (symbol->rep 'exact)) 'rep:exact))
(let () (begin (set! rep:inexact (symbol->rep 'inexact)) 'rep:inexact))
(let () (begin (set! rep:integer (symbol->rep 'integer)) 'rep:integer))
(let () (begin (set! rep:char (symbol->rep 'char)) 'rep:char))
(let () (begin (set! rep:string (symbol->rep 'string)) 'rep:string))
(let () (begin (set! rep:vector (symbol->rep 'vector)) 'rep:vector))
(let () (begin (set! rep:procedure (symbol->rep 'procedure)) 'rep:procedure))
(let () (begin (set! rep:bottom (symbol->rep 'bottom)) 'rep:bottom))
(let () (begin (set! representation-of-value (lambda (.x|1) (let ((.representation-of-value|2 0)) (begin (set! .representation-of-value|2 (lambda (.x|3) (if (boolean? .x|3) (if .x|3 rep:truth rep:false) (if (pair? .x|3) rep:pair (if (symbol? .x|3) rep:symbol (if (number? .x|3) (if (if (exact? .x|3) (integer? .x|3) #f) (if (zero? .x|3) rep:zero (if (let ((.t|13|16 .x|3)) (if (<= 0 .t|13|16) (<= .t|13|16 rep:max_index) #f)) rep:index (if (let ((.t|20|23 .x|3)) (if (<= rep:min_fixnum .t|20|23) (<= .t|20|23 rep:max_fixnum) #f)) rep:fixnum rep:exactint))) (if (if (inexact? .x|3) (real? .x|3) #f) rep:flonum rep:number)) (if (char? .x|3) rep:char (if (string? .x|3) rep:string (if (vector? .x|3) rep:vector rep:true))))))))) (.representation-of-value|2 .x|1))))) 'representation-of-value))
(let () (begin (set! rep-specific (representation-table '((= (fixnum fixnum) =:fix:fix) (< (fixnum fixnum) <:fix:fix) (<= (fixnum fixnum) <=:fix:fix) (> (fixnum fixnum) >:fix:fix) (>= (fixnum fixnum) >=:fix:fix)))) 'rep-specific))
(let () (begin (set! rep-result (representation-table '((fixnum? (fixnum) (truth)) (vector? (vector) (truth)) (<= (zero !fixnum) (truth)) (>= (!fixnum zero) (truth)) (<=:fix:fix (zero !fixnum) (truth)) (>=:fix:fix (!fixnum zero) (truth)) (+ (index index) (!fixnum)) (+ (fixnum fixnum) (exactint)) (- (index index) (fixnum!)) (- (fixnum fixnum) (exactint)) (+ (flonum flonum) (flonum)) (- (flonum flonum) (flonum)) (make-vector (object object) (vector)) (vector-length:vec (vector) (index)) (cons (object object) (pair)) (= (number number) (boolean)) (< (number number) (boolean)) (<= (number number) (boolean)) (> (number number) (boolean)) (>= (number number) (boolean)) (=:fix:fix (fixnum fixnum) (boolean)) (<:fix:fix (fixnum fixnum) (boolean)) (<=:fix:fix (fixnum fixnum) (boolean)) (>:fix:fix (fixnum fixnum) (boolean)) (>=:fix:fix (fixnum fixnum) (boolean))))) 'rep-result))
(let () (begin (set! rep-informing (representation-table '((fixnum? (object) (fixnum) (object)) (flonum? (object) (flonum) (object)) (vector? (object) (vector) (object)) (pair? (object) (pair) (object)) (= (exactint index) (index index) (exactint index)) (= (index exactint) (index index) (index exactint)) (= (exactint !fixnum) (!fixnum !fixnum) (exactint !fixnum)) (= (!fixnum exactint) (!fixnum !fixnum) (!fixnum exactint)) (= (exactint fixnum!) (fixnum! fixnum!) (exactint fixnum!)) (= (fixnum! exactint) (fixnum! fixnum!) (fixnum! exactint)) (< (!fixnum fixnum!) (index index) (!fixnum fixnum!)) (< (fixnum fixnum!) (fixnum! fixnum!) (fixnum fixnum!)) (< (!fixnum fixnum) (!fixnum !fixnum) (!fixnum fixnum)) (< (fixnum! !fixnum) (fixnum! !fixnum) (index index)) (<= (!fixnum fixnum!) (index index) (!fixnum fixnum!)) (<= (fixnum! !fixnum) (fixnum! !fixnum) (index index)) (<= (fixnum fixnum!) (fixnum! fixnum!) (fixnum fixnum!)) (<= (!fixnum fixnum) (!fixnum !fixnum) (!fixnum fixnum)) (> (!fixnum fixnum!) (!fixnum fixnum!) (index index)) (> (fixnum! !fixnum) (index index) (fixnum! !fixnum)) (> (fixnum fixnum!) (fixnum fixnum!) (fixnum! fixnum!)) (> (!fixnum fixnum) (!fixnum fixnum) (!fixnum !fixnum)) (>= (!fixnum fixnum!) (!fixnum fixnum!) (index index)) (>= (fixnum! !fixnum) (index index) (fixnum! !fixnum)) (>= (fixnum fixnum!) (fixnum fixnum!) (fixnum! fixnum!)) (>= (!fixnum fixnum) (!fixnum fixnum) (!fixnum !fixnum)) (=:fix:fix (exactint index) (index index) (exactint index)) (=:fix:fix (index exactint) (index index) (index exactint)) (=:fix:fix (exactint !fixnum) (!fixnum !fixnum) (exactint !fixnum)) (=:fix:fix (!fixnum exactint) (!fixnum !fixnum) (!fixnum exactint)) (=:fix:fix (exactint fixnum!) (fixnum! fixnum!) (exactint fixnum!)) (=:fix:fix (fixnum! exactint) (fixnum! fixnum!) (fixnum! exactint)) (<:fix:fix (!fixnum fixnum!) (index index) (!fixnum fixnum!)) (<:fix:fix (fixnum! !fixnum) (fixnum! !fixnum) (index index)) (<:fix:fix (fixnum fixnum!) (fixnum! fixnum!) (fixnum fixnum!)) (<:fix:fix (!fixnum fixnum) (!fixnum !fixnum) (!fixnum fixnum)) (<=:fix:fix (!fixnum fixnum!) (index index) (!fixnum fixnum!)) (<=:fix:fix (fixnum! !fixnum) (fixnum! !fixnum) (index index)) (<=:fix:fix (fixnum fixnum!) (fixnum! fixnum!) (fixnum fixnum!)) (<=:fix:fix (!fixnum fixnum) (!fixnum !fixnum) (!fixnum fixnum)) (>:fix:fix (!fixnum fixnum!) (!fixnum fixnum!) (index index)) (>:fix:fix (fixnum! !fixnum) (index index) (fixnum! !fixnum)) (>:fix:fix (fixnum fixnum!) (fixnum fixnum!) (fixnum! fixnum!)) (>:fix:fix (!fixnum fixnum) (!fixnum fixnum) (!fixnum !fixnum)) (>=:fix:fix (!fixnum fixnum!) (!fixnum fixnum!) (index index)) (>=:fix:fix (fixnum! !fixnum) (index index) (fixnum! !fixnum)) (>=:fix:fix (fixnum fixnum!) (fixnum fixnum!) (fixnum! fixnum!)) (>=:fix:fix (!fixnum fixnum) (!fixnum fixnum) (!fixnum !fixnum))))) 'rep-informing))
(let () (begin (set! pass2 (lambda (.exp|1) (let ((.pass2|2 0)) (begin (set! .pass2|2 (lambda (.exp|3) (simplify .exp|3 (make-notepad #f)))) (.pass2|2 .exp|1))))) 'pass2))
(let () (begin (set! simplify (lambda (.exp|1 .notepad|1) (let ((.simplify|2 0)) (begin (set! .simplify|2 (lambda (.exp|3 .notepad|3) (let ((.temp|4|7 (let ((.x|14|17 .exp|3)) (begin (.check! (pair? .x|14|17) 0 .x|14|17) (car:pair .x|14|17))))) (if (memv .temp|4|7 '(quote)) .exp|3 (if (memv .temp|4|7 '(lambda)) (simplify-lambda .exp|3 .notepad|3) (if (memv .temp|4|7 '(set!)) (simplify-assignment .exp|3 .notepad|3) (if (memv .temp|4|7 '(if)) (simplify-conditional .exp|3 .notepad|3) (if (memv .temp|4|7 '(begin)) (if (variable? .exp|3) (begin (notepad-var-add! .notepad|3 (variable.name .exp|3)) .exp|3) (simplify-sequential .exp|3 .notepad|3)) (simplify-call .exp|3 .notepad|3))))))))) (.simplify|2 .exp|1 .notepad|1))))) 'simplify))
(let () (begin (set! simplify-lambda (lambda (.exp|1 .notepad|1) (let ((.simplify-lambda|2 0)) (begin (set! .simplify-lambda|2 (lambda (.exp|3 .notepad|3) (begin (notepad-lambda-add! .notepad|3 .exp|3) (let ((.defs|6 (lambda.defs .exp|3)) (.body|6 (lambda.body .exp|3)) (.newnotepad|6 (make-notepad .exp|3))) (begin (let () (let ((.loop|12|14|17 (unspecified))) (begin (set! .loop|12|14|17 (lambda (.y1|7|8|18) (if (null? .y1|7|8|18) (if #f #f (unspecified)) (begin (begin #t (let ((.def|22 (let ((.x|23|26 .y1|7|8|18)) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26))))) (.simplify-lambda|2 (def.rhs .def|22) .newnotepad|6))) (.loop|12|14|17 (let ((.x|27|30 .y1|7|8|18)) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30)))))))) (.loop|12|14|17 .defs|6)))) (lambda.body-set! .exp|3 (simplify .body|6 .newnotepad|6)) (lambda.f-set! .exp|3 (notepad-free-variables .newnotepad|6)) (lambda.g-set! .exp|3 (notepad-captured-variables .newnotepad|6)) (single-assignment-analysis .exp|3 .newnotepad|6) (let ((.known-lambdas|33 (notepad.nonescaping .newnotepad|6))) (let () (let ((.loop|39|41|44 (unspecified))) (begin (set! .loop|39|41|44 (lambda (.y1|34|35|45) (if (null? .y1|34|35|45) (if #f #f (unspecified)) (begin (begin #t (let ((.l|49 (let ((.x|50|53 .y1|34|35|45)) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53))))) (if (memq .l|49 .known-lambdas|33) (lambda-lifting .l|49 .exp|3) (lambda-lifting .l|49 .l|49)))) (.loop|39|41|44 (let ((.x|54|57 .y1|34|35|45)) (begin (.check! (pair? .x|54|57) 1 .x|54|57) (cdr:pair .x|54|57)))))))) (.loop|39|41|44 (notepad.lambdas .newnotepad|6)))))))) (single-assignment-elimination .exp|3 .notepad|3) (assignment-elimination .exp|3) (if (not (notepad.parent .notepad|3)) (lambda-lifting .exp|3 .exp|3) (unspecified)) .exp|3))) (.simplify-lambda|2 .exp|1 .notepad|1))))) 'simplify-lambda))
(let () (begin (set! simplify-assignment (lambda (.exp|1 .notepad|1) (let ((.simplify-assignment|2 0)) (begin (set! .simplify-assignment|2 (lambda (.exp|3 .notepad|3) (begin (notepad-var-add! .notepad|3 (assignment.lhs .exp|3)) (let ((.rhs|6 (simplify (assignment.rhs .exp|3) .notepad|3))) (if (begin? .rhs|6) (let ((.exprs|10 (reverse (begin.exprs .rhs|6)))) (begin (assignment.rhs-set! .exp|3 (let ((.x|11|14 .exprs|10)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14)))) (post-simplify-begin (make-begin (reverse (cons .exp|3 (let ((.x|15|18 .exprs|10)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18)))))) .notepad|3))) (begin (assignment.rhs-set! .exp|3 .rhs|6) .exp|3)))))) (.simplify-assignment|2 .exp|1 .notepad|1))))) 'simplify-assignment))
(let () (begin (set! simplify-sequential (lambda (.exp|1 .notepad|1) (let ((.simplify-sequential|2 0)) (begin (set! .simplify-sequential|2 (lambda (.exp|3 .notepad|3) (let ((.exprs|6 (let () (let ((.loop|12|15|18 (unspecified))) (begin (set! .loop|12|15|18 (lambda (.y1|7|8|19 .results|7|11|19) (if (null? .y1|7|8|19) (reverse .results|7|11|19) (begin #t (.loop|12|15|18 (let ((.x|23|26 .y1|7|8|19)) (begin (.check! (pair? .x|23|26) 1 .x|23|26) (cdr:pair .x|23|26))) (cons (let ((.exp|27 (let ((.x|28|31 .y1|7|8|19)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31))))) (simplify .exp|27 .notepad|3)) .results|7|11|19)))))) (.loop|12|15|18 (begin.exprs .exp|3) '())))))) (begin (begin.exprs-set! .exp|3 .exprs|6) (post-simplify-begin .exp|3 .notepad|3))))) (.simplify-sequential|2 .exp|1 .notepad|1))))) 'simplify-sequential))
(let () (begin (set! post-simplify-begin (lambda (.exp|1 .notepad|1) (let ((.post-simplify-begin|2 0)) (begin (set! .post-simplify-begin|2 (lambda (.exp|3 .notepad|3) (let ((.unspecified-expression|6 (make-unspecified))) (let ((.filter|9 (unspecified)) (.flatten|9 (unspecified))) (begin (set! .filter|9 (lambda (.exprs|10 .filtered|10) (if (null? .exprs|10) .filtered|10 (let ((.exp|13 (let ((.x|39|42 .exprs|10)) (begin (.check! (pair? .x|39|42) 0 .x|39|42) (car:pair .x|39|42))))) (if (constant? .exp|13) (.filter|9 (let ((.x|15|18 .exprs|10)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))) .filtered|10) (if (variable? .exp|13) (.filter|9 (let ((.x|20|23 .exprs|10)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) .filtered|10) (if (lambda? .exp|13) (begin (notepad.lambdas-set! .notepad|3 (remq .exp|13 (notepad.lambdas .notepad|3))) (.filter|9 (let ((.x|25|28 .exprs|10)) (begin (.check! (pair? .x|25|28) 1 .x|25|28) (cdr:pair .x|25|28))) .filtered|10)) (if (equal? .exp|13 .unspecified-expression|6) (.filter|9 (let ((.x|30|33 .exprs|10)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))) .filtered|10) (.filter|9 (let ((.x|35|38 .exprs|10)) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))) (cons .exp|13 .filtered|10)))))))))) (set! .flatten|9 (lambda (.exprs|43 .flattened|43) (if (null? .exprs|43) .flattened|43 (if (begin? (let ((.x|46|49 .exprs|43)) (begin (.check! (pair? .x|46|49) 0 .x|46|49) (car:pair .x|46|49)))) (.flatten|9 (let ((.x|50|53 .exprs|43)) (begin (.check! (pair? .x|50|53) 1 .x|50|53) (cdr:pair .x|50|53))) (.flatten|9 (begin.exprs (let ((.x|54|57 .exprs|43)) (begin (.check! (pair? .x|54|57) 0 .x|54|57) (car:pair .x|54|57)))) .flattened|43)) (.flatten|9 (let ((.x|59|62 .exprs|43)) (begin (.check! (pair? .x|59|62) 1 .x|59|62) (cdr:pair .x|59|62))) (cons (let ((.x|63|66 .exprs|43)) (begin (.check! (pair? .x|63|66) 0 .x|63|66) (car:pair .x|63|66))) .flattened|43)))))) (let ((.exprs|67 (.flatten|9 (begin.exprs .exp|3) '()))) (begin (begin.exprs-set! .exp|3 (.filter|9 (let ((.x|68|71 .exprs|67)) (begin (.check! (pair? .x|68|71) 1 .x|68|71) (cdr:pair .x|68|71))) (cons (let ((.x|73|76 .exprs|67)) (begin (.check! (pair? .x|73|76) 0 .x|73|76) (car:pair .x|73|76))) '()))) (if (null? (let ((.x|77|80 (begin.exprs .exp|3))) (begin (.check! (pair? .x|77|80) 1 .x|77|80) (cdr:pair .x|77|80)))) (let ((.x|81|84 (begin.exprs .exp|3))) (begin (.check! (pair? .x|81|84) 0 .x|81|84) (car:pair .x|81|84))) .exp|3)))))))) (.post-simplify-begin|2 .exp|1 .notepad|1))))) 'post-simplify-begin))
(let () (begin (set! simplify-call (lambda (.exp|1 .notepad|1) (let ((.simplify-call|2 0)) (begin (set! .simplify-call|2 (lambda (.exp|3 .notepad|3) (let ((.finish|4 (unspecified)) (.loop|4 (unspecified))) (begin (set! .finish|4 (lambda (.newargs|5 .exprs|5) (begin (call.args-set! .exp|3 (reverse .newargs|5)) (let* ((.newexp|8 (if (lambda? (call.proc .exp|3)) (simplify-let .exp|3 .notepad|3) (begin (call.proc-set! .exp|3 (simplify (call.proc .exp|3) .notepad|3)) .exp|3))) (.newexp|11 (if (if (call? .newexp|8) (variable? (call.proc .newexp|8)) #f) (let* ((.procname|35 (variable.name (call.proc .newexp|8))) (.args|38 (call.args .newexp|8)) (.entry|41 (if (not (null? .args|38)) (if (constant? (let ((.x|71|74 .args|38)) (begin (.check! (pair? .x|71|74) 0 .x|71|74) (car:pair .x|71|74)))) (if (integrate-usual-procedures) (if (every? constant? .args|38) (let ((.entry|80 (constant-folding-entry .procname|35))) (if .entry|80 (let ((.predicates|85 (constant-folding-predicates .entry|80))) (if (= (length .args|38) (length .predicates|85)) (let ((.args|90 .args|38) (.predicates|90 .predicates|85)) (let () (let ((.loop|93 (unspecified))) (begin (set! .loop|93 (lambda (.args|94 .predicates|94) (if (null? .args|94) .entry|80 (if ((let ((.x|97|100 .predicates|94)) (begin (.check! (pair? .x|97|100) 0 .x|97|100) (car:pair .x|97|100))) (constant.value (let ((.x|101|104 .args|94)) (begin (.check! (pair? .x|101|104) 0 .x|101|104) (car:pair .x|101|104))))) (.loop|93 (let ((.x|105|108 .args|94)) (begin (.check! (pair? .x|105|108) 1 .x|105|108) (cdr:pair .x|105|108))) (let ((.x|109|112 .predicates|94)) (begin (.check! (pair? .x|109|112) 1 .x|109|112) (cdr:pair .x|109|112)))) #f)))) (.loop|93 .args|90 .predicates|90))))) #f)) #f)) #f) #f) #f) #f))) (let () (if .entry|41 (make-constant (apply (constant-folding-folder .entry|41) (let () (let ((.loop|50|53|56 (unspecified))) (begin (set! .loop|50|53|56 (lambda (.y1|45|46|57 .results|45|49|57) (if (null? .y1|45|46|57) (reverse .results|45|49|57) (begin #t (.loop|50|53|56 (let ((.x|61|64 .y1|45|46|57)) (begin (.check! (pair? .x|61|64) 1 .x|61|64) (cdr:pair .x|61|64))) (cons (constant.value (let ((.x|65|68 .y1|45|46|57)) (begin (.check! (pair? .x|65|68) 0 .x|65|68) (car:pair .x|65|68)))) .results|45|49|57)))))) (.loop|50|53|56 .args|38 '())))))) .newexp|8))) .newexp|8))) (let () (if (if (call? .newexp|11) (begin? (call.proc .newexp|11)) #f) (let ((.exprs0|20 (reverse (begin.exprs (call.proc .newexp|11))))) (begin (call.proc-set! .newexp|11 (let ((.x|21|24 .exprs0|20)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24)))) (post-simplify-begin (make-begin (reverse (cons .newexp|11 (append (let ((.x|25|28 .exprs0|20)) (begin (.check! (pair? .x|25|28) 1 .x|25|28) (cdr:pair .x|25|28))) .exprs|5)))) .notepad|3))) (if (null? .exprs|5) .newexp|11 (post-simplify-begin (make-begin (reverse (cons .newexp|11 .exprs|5))) .notepad|3)))))))) (set! .loop|4 (lambda (.args|114 .newargs|114 .exprs|114) (if (null? .args|114) (.finish|4 .newargs|114 .exprs|114) (if (begin? (let ((.x|117|120 .args|114)) (begin (.check! (pair? .x|117|120) 0 .x|117|120) (car:pair .x|117|120)))) (let ((.newexprs|123 (reverse (begin.exprs (let ((.x|136|139 .args|114)) (begin (.check! (pair? .x|136|139) 0 .x|136|139) (car:pair .x|136|139))))))) (.loop|4 (let ((.x|124|127 .args|114)) (begin (.check! (pair? .x|124|127) 1 .x|124|127) (cdr:pair .x|124|127))) (cons (let ((.x|128|131 .newexprs|123)) (begin (.check! (pair? .x|128|131) 0 .x|128|131) (car:pair .x|128|131))) .newargs|114) (append (let ((.x|132|135 .newexprs|123)) (begin (.check! (pair? .x|132|135) 1 .x|132|135) (cdr:pair .x|132|135))) .exprs|114))) (.loop|4 (let ((.x|141|144 .args|114)) (begin (.check! (pair? .x|141|144) 1 .x|141|144) (cdr:pair .x|141|144))) (cons (let ((.x|145|148 .args|114)) (begin (.check! (pair? .x|145|148) 0 .x|145|148) (car:pair .x|145|148))) .newargs|114) .exprs|114))))) (call.args-set! .exp|3 (let () (let ((.loop|154|157|160 (unspecified))) (begin (set! .loop|154|157|160 (lambda (.y1|149|150|161 .results|149|153|161) (if (null? .y1|149|150|161) (reverse .results|149|153|161) (begin #t (.loop|154|157|160 (let ((.x|165|168 .y1|149|150|161)) (begin (.check! (pair? .x|165|168) 1 .x|165|168) (cdr:pair .x|165|168))) (cons (let ((.arg|169 (let ((.x|170|173 .y1|149|150|161)) (begin (.check! (pair? .x|170|173) 0 .x|170|173) (car:pair .x|170|173))))) (simplify .arg|169 .notepad|3)) .results|149|153|161)))))) (.loop|154|157|160 (call.args .exp|3) '()))))) (.loop|4 (call.args .exp|3) '() '()))))) (.simplify-call|2 .exp|1 .notepad|1))))) 'simplify-call))
(let () (begin (set! simplify-let (lambda (.exp|1 .notepad|1) (let ((.simplify-let|2 0)) (begin (set! .simplify-let|2 (lambda (.exp|3 .notepad|3) (let ((.return2|4 (unspecified)) (.loop2|4 (unspecified)) (.return1-finish|4 (unspecified)) (.return1|4 (unspecified)) (.loop1|4 (unspecified)) (.proc|4 (unspecified))) (begin (set! .return2|4 (lambda (.rev-formals|5 .rev-actuals|5 .rev-for-effect|5) (let ((.formals|8 (reverse .rev-formals|5)) (.actuals|8 (reverse .rev-actuals|5)) (.for-effect|8 (reverse .rev-for-effect|5))) (begin (lambda.args-set! .proc|4 .formals|8) (call.args-set! .exp|3 .actuals|8) (let ((.exp|11 (if (if (null? .actuals|8) (let ((.temp|15|18 (null? (lambda.defs .proc|4)))) (if .temp|15|18 .temp|15|18 (if (notepad.parent .notepad|3) (policy:lift? .proc|4 (notepad.parent .notepad|3) (let () (let ((.loop|27|30|33 (unspecified))) (begin (set! .loop|27|30|33 (lambda (.y1|22|23|34 .results|22|26|34) (if (null? .y1|22|23|34) (reverse .results|22|26|34) (begin #t (.loop|27|30|33 (let ((.x|38|41 .y1|22|23|34)) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41))) (cons (let ((.def|42 (let ((.x|43|46 .y1|22|23|34)) (begin (.check! (pair? .x|43|46) 0 .x|43|46) (car:pair .x|43|46))))) '()) .results|22|26|34)))))) (.loop|27|30|33 (lambda.defs .proc|4) '()))))) #f))) #f) (begin (let () (let ((.loop|52|54|57 (unspecified))) (begin (set! .loop|52|54|57 (lambda (.y1|47|48|58) (if (null? .y1|47|48|58) (if #f #f (unspecified)) (begin (begin #t (let ((.i|62 (let ((.x|63|66 .y1|47|48|58)) (begin (.check! (pair? .x|63|66) 0 .x|63|66) (car:pair .x|63|66))))) (notepad-var-add! .notepad|3 .i|62))) (.loop|52|54|57 (let ((.x|67|70 .y1|47|48|58)) (begin (.check! (pair? .x|67|70) 1 .x|67|70) (cdr:pair .x|67|70)))))))) (.loop|52|54|57 (lambda.f .proc|4))))) (if (not (null? (lambda.defs .proc|4))) (let ((.parent|73 (notepad.parent .notepad|3)) (.defs|73 (lambda.defs .proc|4)) (.r|73 (lambda.r .proc|4))) (begin (lambda.defs-set! .parent|73 (append .defs|73 (lambda.defs .parent|73))) (lambda.defs-set! .proc|4 '()) (lambda.r-set! .parent|73 (append (let () (let ((.loop|79|82|85 (unspecified))) (begin (set! .loop|79|82|85 (lambda (.y1|74|75|86 .results|74|78|86) (if (null? .y1|74|75|86) (reverse .results|74|78|86) (begin #t (.loop|79|82|85 (let ((.x|90|93 .y1|74|75|86)) (begin (.check! (pair? .x|90|93) 1 .x|90|93) (cdr:pair .x|90|93))) (cons (let ((.def|94 (let ((.x|95|98 .y1|74|75|86)) (begin (.check! (pair? .x|95|98) 0 .x|95|98) (car:pair .x|95|98))))) (r-lookup .r|73 (def.lhs .def|94))) .results|74|78|86)))))) (.loop|79|82|85 .defs|73 '())))) (lambda.r .parent|73))))) (unspecified)) (lambda.body .proc|4)) .exp|3))) (if (null? .for-effect|8) .exp|11 (post-simplify-begin (make-begin (append .for-effect|8 (cons .exp|11 '()))) .notepad|3))))))) (set! .loop2|4 (lambda (.formals|99 .actuals|99 .processed-formals|99 .processed-actuals|99 .for-effect|99) (if (null? .formals|99) (.return2|4 .processed-formals|99 .processed-actuals|99 .for-effect|99) (if (ignored? (let ((.x|102|105 .formals|99)) (begin (.check! (pair? .x|102|105) 0 .x|102|105) (car:pair .x|102|105)))) (.loop2|4 (let ((.x|106|109 .formals|99)) (begin (.check! (pair? .x|106|109) 1 .x|106|109) (cdr:pair .x|106|109))) (let ((.x|110|113 .actuals|99)) (begin (.check! (pair? .x|110|113) 1 .x|110|113) (cdr:pair .x|110|113))) .processed-formals|99 .processed-actuals|99 (cons (let ((.x|114|117 .actuals|99)) (begin (.check! (pair? .x|114|117) 0 .x|114|117) (car:pair .x|114|117))) .for-effect|99)) (.loop2|4 (let ((.x|119|122 .formals|99)) (begin (.check! (pair? .x|119|122) 1 .x|119|122) (cdr:pair .x|119|122))) (let ((.x|123|126 .actuals|99)) (begin (.check! (pair? .x|123|126) 1 .x|123|126) (cdr:pair .x|123|126))) (cons (let ((.x|127|130 .formals|99)) (begin (.check! (pair? .x|127|130) 0 .x|127|130) (car:pair .x|127|130))) .processed-formals|99) (cons (let ((.x|131|134 .actuals|99)) (begin (.check! (pair? .x|131|134) 0 .x|131|134) (car:pair .x|131|134))) .processed-actuals|99) .for-effect|99))))) (set! .return1-finish|4 (lambda (.formals|135 .actuals|135) (begin (simplify-lambda .proc|4 .notepad|3) (.loop2|4 .formals|135 .actuals|135 '() '() '())))) (set! .return1|4 (lambda (.rev-formals|136 .rev-actuals|136) (let ((.formals|139 (reverse .rev-formals|136)) (.actuals|139 (reverse .rev-actuals|136))) (begin (lambda.args-set! .proc|4 .formals|139) (if (if (not (null? .formals|139)) (if (null? (let ((.x|142|145 .formals|139)) (begin (.check! (pair? .x|142|145) 1 .x|142|145) (cdr:pair .x|142|145)))) (let* ((.x|149 (let ((.x|161|164 .formals|139)) (begin (.check! (pair? .x|161|164) 0 .x|161|164) (car:pair .x|161|164)))) (.r|152 (lambda.r .proc|4)) (.refs|155 (references .r|152 .x|149))) (let () (if (= 1 (length .refs|155)) (null? (assignments .r|152 .x|149)) #f))) #f) #f) (let ((.x|167 (let ((.x|186|189 .formals|139)) (begin (.check! (pair? .x|186|189) 0 .x|186|189) (car:pair .x|186|189)))) (.body|167 (lambda.body .proc|4))) (if (if (variable? .body|167) (eq? .x|167 (variable.name .body|167)) #f) (simplify (let ((.x|171|174 .actuals|139)) (begin (.check! (pair? .x|171|174) 0 .x|171|174) (car:pair .x|171|174))) .notepad|3) (if (if (conditional? .body|167) (let ((.b0|180 (if.test .body|167))) (begin (variable? .b0|180) (eq? .x|167 (variable.name .b0|180)))) #f) (begin (if.test-set! .body|167 (let ((.x|181|184 .actuals|139)) (begin (.check! (pair? .x|181|184) 0 .x|181|184) (car:pair .x|181|184)))) (simplify .body|167 .notepad|3)) (.return1-finish|4 .formals|139 .actuals|139)))) (.return1-finish|4 .formals|139 .actuals|139)))))) (set! .loop1|4 (lambda (.formals|190 .actuals|190 .processed-formals|190 .processed-actuals|190) (if (null? .formals|190) (begin (if (not (null? .actuals|190)) (pass2-error p2error:wna .exp|3) (unspecified)) (.return1|4 .processed-formals|190 .processed-actuals|190)) (if (symbol? .formals|190) (.return1|4 (cons .formals|190 .processed-formals|190) (cons (make-call-to-list .actuals|190) .processed-actuals|190)) (if (null? .actuals|190) (begin (pass2-error p2error:wna .exp|3) (.return1|4 .processed-formals|190 .processed-actuals|190)) (if (if (lambda? (let ((.x|196|199 .actuals|190)) (begin (.check! (pair? .x|196|199) 0 .x|196|199) (car:pair .x|196|199)))) (let ((.rinfo|203 (r-lookup (lambda.r .proc|4) (let ((.x|206|209 .formals|190)) (begin (.check! (pair? .x|206|209) 0 .x|206|209) (car:pair .x|206|209)))))) (if (null? (r-entry.assignments .rinfo|203)) (= (length (r-entry.references .rinfo|203)) (length (r-entry.calls .rinfo|203))) #f)) #f) (begin (let ((.i|212 (let ((.x|213|216 .formals|190)) (begin (.check! (pair? .x|213|216) 0 .x|213|216) (car:pair .x|213|216)))) (.l|212 (let ((.x|217|220 .actuals|190)) (begin (.check! (pair? .x|217|220) 0 .x|217|220) (car:pair .x|217|220))))) (begin (notepad-nonescaping-add! .notepad|3 .l|212) (lambda.defs-set! .proc|4 (cons (make-definition .i|212 .l|212) (lambda.defs .proc|4))) (standardize-known-calls .l|212 (r-entry.calls (r-lookup (lambda.r .proc|4) .i|212))) (lambda.f-set! .proc|4 (union (lambda.f .proc|4) (free-variables .l|212))) (lambda.g-set! .proc|4 (union (lambda.g .proc|4) (lambda.g .l|212))))) (.loop1|4 (let ((.x|221|224 .formals|190)) (begin (.check! (pair? .x|221|224) 1 .x|221|224) (cdr:pair .x|221|224))) (let ((.x|225|228 .actuals|190)) (begin (.check! (pair? .x|225|228) 1 .x|225|228) (cdr:pair .x|225|228))) .processed-formals|190 .processed-actuals|190)) (if (if (constant? (let ((.x|231|234 .actuals|190)) (begin (.check! (pair? .x|231|234) 0 .x|231|234) (car:pair .x|231|234)))) (let* ((.x|238 (constant.value (let ((.x|252|255 .actuals|190)) (begin (.check! (pair? .x|252|255) 0 .x|252|255) (car:pair .x|252|255))))) (.temp|239|242 (boolean? .x|238))) (if .temp|239|242 .temp|239|242 (let ((.temp|243|246 (number? .x|238))) (if .temp|243|246 .temp|243|246 (let ((.temp|247|250 (symbol? .x|238))) (if .temp|247|250 .temp|247|250 (char? .x|238))))))) #f) (let* ((.i|258 (let ((.x|317|320 .formals|190)) (begin (.check! (pair? .x|317|320) 0 .x|317|320) (car:pair .x|317|320)))) (.rinfo|261 (r-lookup (lambda.r .proc|4) .i|258))) (let () (if (null? (r-entry.assignments .rinfo|261)) (begin (let () (let ((.loop|270|272|275 (unspecified))) (begin (set! .loop|270|272|275 (lambda (.y1|265|266|276) (if (null? .y1|265|266|276) (if #f #f (unspecified)) (begin (begin #t (let ((.ref|280 (let ((.x|285|288 .y1|265|266|276)) (begin (.check! (pair? .x|285|288) 0 .x|285|288) (car:pair .x|285|288))))) (variable-set! .ref|280 (let ((.x|281|284 .actuals|190)) (begin (.check! (pair? .x|281|284) 0 .x|281|284) (car:pair .x|281|284)))))) (.loop|270|272|275 (let ((.x|289|292 .y1|265|266|276)) (begin (.check! (pair? .x|289|292) 1 .x|289|292) (cdr:pair .x|289|292)))))))) (.loop|270|272|275 (r-entry.references .rinfo|261))))) (lambda.r-set! .proc|4 (remq .rinfo|261 (lambda.r .proc|4))) (lambda.f-set! .proc|4 (remq .i|258 (lambda.f .proc|4))) (lambda.g-set! .proc|4 (remq .i|258 (lambda.g .proc|4))) (.loop1|4 (let ((.x|293|296 .formals|190)) (begin (.check! (pair? .x|293|296) 1 .x|293|296) (cdr:pair .x|293|296))) (let ((.x|297|300 .actuals|190)) (begin (.check! (pair? .x|297|300) 1 .x|297|300) (cdr:pair .x|297|300))) .processed-formals|190 .processed-actuals|190)) (.loop1|4 (let ((.x|301|304 .formals|190)) (begin (.check! (pair? .x|301|304) 1 .x|301|304) (cdr:pair .x|301|304))) (let ((.x|305|308 .actuals|190)) (begin (.check! (pair? .x|305|308) 1 .x|305|308) (cdr:pair .x|305|308))) (cons (let ((.x|309|312 .formals|190)) (begin (.check! (pair? .x|309|312) 0 .x|309|312) (car:pair .x|309|312))) .processed-formals|190) (cons (let ((.x|313|316 .actuals|190)) (begin (.check! (pair? .x|313|316) 0 .x|313|316) (car:pair .x|313|316))) .processed-actuals|190))))) (begin (if (null? .actuals|190) (pass2-error p2error:wna .exp|3) (unspecified)) (.loop1|4 (let ((.x|322|325 .formals|190)) (begin (.check! (pair? .x|322|325) 1 .x|322|325) (cdr:pair .x|322|325))) (let ((.x|326|329 .actuals|190)) (begin (.check! (pair? .x|326|329) 1 .x|326|329) (cdr:pair .x|326|329))) (cons (let ((.x|330|333 .formals|190)) (begin (.check! (pair? .x|330|333) 0 .x|330|333) (car:pair .x|330|333))) .processed-formals|190) (cons (let ((.x|334|337 .actuals|190)) (begin (.check! (pair? .x|334|337) 0 .x|334|337) (car:pair .x|334|337))) .processed-actuals|190)))))))))) (set! .proc|4 (call.proc .exp|3)) (notepad-nonescaping-add! .notepad|3 .proc|4) (.loop1|4 (lambda.args .proc|4) (call.args .exp|3) '() '()))))) (.simplify-let|2 .exp|1 .notepad|1))))) 'simplify-let))
(let () (begin (set! single-assignment-analysis (lambda (.l|1 .notepad|1) (let ((.single-assignment-analysis|2 0)) (begin (set! .single-assignment-analysis|2 (lambda (.l|3 .notepad|3) (let ((.formals|6 (lambda.args .l|3)) (.defs|6 (lambda.defs .l|3)) (.r|6 (lambda.r .l|3)) (.body|6 (lambda.body .l|3))) (let ((.finish!|7 (unspecified))) (begin (set! .finish!|7 (lambda (.exprs|8 .escapees|8) (begin (begin.exprs-set! .body|6 (append (reverse .escapees|8) .exprs|8)) (lambda.body-set! .l|3 (post-simplify-begin .body|6 '()))))) (if (begin? .body|6) (let ((.exprs|11 (begin.exprs .body|6)) (.escapees|11 '())) (let () (let ((.loop|14 (unspecified))) (begin (set! .loop|14 (lambda (.exprs|15 .escapees|15) (let ((.first|18 (let ((.x|43|46 .exprs|15)) (begin (.check! (pair? .x|43|46) 0 .x|43|46) (car:pair .x|43|46))))) (if (if (assignment? .first|18) (not (null? (let ((.x|21|24 .exprs|15)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) #f) (let ((.i|27 (assignment.lhs .first|18)) (.rhs|27 (assignment.rhs .first|18))) (if (if (lambda? .rhs|27) (if (local? .r|6 .i|27) (= 1 (length (assignments .r|6 .i|27))) #f) #f) (if (= (length (calls .r|6 .i|27)) (length (references .r|6 .i|27))) (begin (notepad-nonescaping-add! .notepad|3 .rhs|27) (flag-as-ignored .i|27 .l|3) (lambda.defs-set! .l|3 (cons (make-definition .i|27 .rhs|27) (lambda.defs .l|3))) (assignments-set! .r|6 .i|27 '()) (standardize-known-calls .rhs|27 (r-entry.calls (r-lookup .r|6 .i|27))) (.loop|14 (let ((.x|31|34 .exprs|15)) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34))) .escapees|15)) (.loop|14 (let ((.x|35|38 .exprs|15)) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))) (cons (let ((.x|39|42 .exprs|15)) (begin (.check! (pair? .x|39|42) 0 .x|39|42) (car:pair .x|39|42))) .escapees|15))) (.finish!|7 .exprs|15 .escapees|15))) (.finish!|7 .exprs|15 .escapees|15))))) (.loop|14 .exprs|11 .escapees|11))))) (unspecified))))))) (.single-assignment-analysis|2 .l|1 .notepad|1))))) 'single-assignment-analysis))
(let () (begin (set! standardize-known-calls (lambda (.l|1 .calls|1) (let ((.standardize-known-calls|2 0)) (begin (set! .standardize-known-calls|2 (lambda (.l|3 .calls|3) (let ((.formals|6 (lambda.args .l|3))) (if (not (list? .formals|6)) (let* ((.newformals|10 (make-null-terminated .formals|6)) (.n|13 (- (length .newformals|10) 1))) (let () (begin (lambda.args-set! .l|3 .newformals|10) (let () (let ((.loop|22|24|27 (unspecified))) (begin (set! .loop|22|24|27 (lambda (.y1|17|18|28) (if (null? .y1|17|18|28) (if #f #f (unspecified)) (begin (begin #t (let ((.call|32 (let ((.x|34|37 .y1|17|18|28)) (begin (.check! (pair? .x|34|37) 0 .x|34|37) (car:pair .x|34|37))))) (if (>= (length (call.args .call|32)) .n|13) (call.args-set! .call|32 (append (list-head (call.args .call|32) .n|13) (cons (make-call-to-list (list-tail (call.args .call|32) .n|13)) '()))) (pass2-error p2error:wna .call|32)))) (.loop|22|24|27 (let ((.x|38|41 .y1|17|18|28)) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41)))))))) (.loop|22|24|27 .calls|3))))))) (let ((.n|45 (length .formals|6))) (let () (let ((.loop|51|53|56 (unspecified))) (begin (set! .loop|51|53|56 (lambda (.y1|46|47|57) (if (null? .y1|46|47|57) (if #f #f (unspecified)) (begin (begin #t (let ((.call|61 (let ((.x|62|65 .y1|46|47|57)) (begin (.check! (pair? .x|62|65) 0 .x|62|65) (car:pair .x|62|65))))) (if (not (= (length (call.args .call|61)) .n|45)) (pass2-error p2error:wna .call|61) (unspecified)))) (.loop|51|53|56 (let ((.x|66|69 .y1|46|47|57)) (begin (.check! (pair? .x|66|69) 1 .x|66|69) (cdr:pair .x|66|69)))))))) (.loop|51|53|56 .calls|3))))))))) (.standardize-known-calls|2 .l|1 .calls|1))))) 'standardize-known-calls))
(let () (begin (set! single-assignment-elimination (lambda (.l|1 .notepad|1) (let ((.single-assignment-elimination|2 0)) (begin (set! .single-assignment-elimination|2 (lambda (.l|3 .notepad|3) (begin (if (begin? (lambda.body .l|3)) (let* ((.formals|6 (make-null-terminated (lambda.args .l|3))) (.defined|9 (let () (let ((.loop|190|193|196 (unspecified))) (begin (set! .loop|190|193|196 (lambda (.y1|185|186|197 .results|185|189|197) (if (null? .y1|185|186|197) (reverse .results|185|189|197) (begin #t (.loop|190|193|196 (let ((.x|201|204 .y1|185|186|197)) (begin (.check! (pair? .x|201|204) 1 .x|201|204) (cdr:pair .x|201|204))) (cons (def.lhs (let ((.x|205|208 .y1|185|186|197)) (begin (.check! (pair? .x|205|208) 0 .x|205|208) (car:pair .x|205|208)))) .results|185|189|197)))))) (.loop|190|193|196 (lambda.defs .l|3) '()))))) (.escaping|12 (intersection .formals|6 (notepad-captured-variables .notepad|3))) (.r|15 (lambda.r .l|3))) (let () (let ((.return-loop|19 (unspecified)) (.return|19 (unspecified)) (.loop|19 (unspecified))) (begin (set! .return-loop|19 (lambda (.assigns|20 .body|20) (if (null? .assigns|20) (let ((.l3|23 (call.proc .body|20))) (begin (lambda.body-set! .l|3 .body|20) (lambda-lifting .l3|23 .l|3))) (let* ((.i|26 (assignment.lhs (let ((.x|56|59 .assigns|20)) (begin (.check! (pair? .x|56|59) 0 .x|56|59) (car:pair .x|56|59))))) (.e|29 (assignment.rhs (let ((.x|52|55 .assigns|20)) (begin (.check! (pair? .x|52|55) 0 .x|52|55) (car:pair .x|52|55))))) (.l3|32 (call.proc .body|20)) (.f|35 (remq .i|26 (lambda.f .l3|32))) (.g|38 (remq .i|26 (lambda.g .l3|32)))) (let () (begin (flag-as-ignored .i|26 .l|3) (assignments-set! .r|15 .i|26 '()) (let ((.l2|44 (make-lambda (cons .i|26 '()) '() (cons (r-entry .r|15 .i|26) '()) .f|35 .g|38 (lambda.decls .l|3) (lambda.doc .l|3) .body|20))) (begin (lambda.r-set! .l|3 (remq (r-entry .r|15 .i|26) .r|15)) (lambda-lifting .l3|32 .l2|44) (.return-loop|19 (let ((.x|45|48 .assigns|20)) (begin (.check! (pair? .x|45|48) 1 .x|45|48) (cdr:pair .x|45|48))) (make-call .l2|44 (cons .e|29 '()))))))))))) (set! .return|19 (lambda (.exprs|60 .assigns|60) (if (not (null? .assigns|60)) (let ((.i|63 (assignment.lhs (let ((.x|122|125 .assigns|60)) (begin (.check! (pair? .x|122|125) 0 .x|122|125) (car:pair .x|122|125))))) (.e|63 (assignment.rhs (let ((.x|126|129 .assigns|60)) (begin (.check! (pair? .x|126|129) 0 .x|126|129) (car:pair .x|126|129))))) (.defs|63 (lambda.defs .l|3)) (.f|63 (lambda.f .l|3)) (.g|63 (lambda.g .l|3))) (begin (flag-as-ignored .i|63 .l|3) (assignments-set! .r|15 .i|63 '()) (let ((.l2|66 (make-lambda (cons .i|63 '()) .defs|63 (cons (r-entry .r|15 .i|63) (let () (let ((.loop|102|105|108 (unspecified))) (begin (set! .loop|102|105|108 (lambda (.y1|97|98|109 .results|97|101|109) (if (null? .y1|97|98|109) (reverse .results|97|101|109) (begin #t (.loop|102|105|108 (let ((.x|113|116 .y1|97|98|109)) (begin (.check! (pair? .x|113|116) 1 .x|113|116) (cdr:pair .x|113|116))) (cons (let ((.def|117 (let ((.x|118|121 .y1|97|98|109)) (begin (.check! (pair? .x|118|121) 0 .x|118|121) (car:pair .x|118|121))))) (r-entry .r|15 (def.lhs .def|117))) .results|97|101|109)))))) (.loop|102|105|108 .defs|63 '()))))) .f|63 .g|63 (lambda.decls .l|3) (lambda.doc .l|3) (make-begin .exprs|60)))) (begin (lambda.defs-set! .l|3 '()) (let () (let ((.loop|72|74|77 (unspecified))) (begin (set! .loop|72|74|77 (lambda (.y1|67|68|78) (if (null? .y1|67|68|78) (if #f #f (unspecified)) (begin (begin #t (let ((.entry|82 (let ((.x|83|86 .y1|67|68|78)) (begin (.check! (pair? .x|83|86) 0 .x|83|86) (car:pair .x|83|86))))) (lambda.r-set! .l|3 (remq .entry|82 .r|15)))) (.loop|72|74|77 (let ((.x|87|90 .y1|67|68|78)) (begin (.check! (pair? .x|87|90) 1 .x|87|90) (cdr:pair .x|87|90)))))))) (.loop|72|74|77 (lambda.r .l2|66))))) (.return-loop|19 (let ((.x|91|94 .assigns|60)) (begin (.check! (pair? .x|91|94) 1 .x|91|94) (cdr:pair .x|91|94))) (make-call .l2|66 (cons .e|63 '()))))))) (unspecified)))) (set! .loop|19 (lambda (.exprs|130 .assigns|130 .call-has-occurred?|130 .free|130) (if (null? (let ((.x|132|135 .exprs|130)) (begin (.check! (pair? .x|132|135) 1 .x|132|135) (cdr:pair .x|132|135)))) (.return|19 .exprs|130 .assigns|130) (if (assignment? (let ((.x|137|140 .exprs|130)) (begin (.check! (pair? .x|137|140) 0 .x|137|140) (car:pair .x|137|140)))) (let ((.i1|143 (assignment.lhs (let ((.x|176|179 .exprs|130)) (begin (.check! (pair? .x|176|179) 0 .x|176|179) (car:pair .x|176|179))))) (.e1|143 (assignment.rhs (let ((.x|180|183 .exprs|130)) (begin (.check! (pair? .x|180|183) 0 .x|180|183) (car:pair .x|180|183)))))) (if (if (memq .i1|143 .formals|6) (if (= (length (assignments .r|15 .i1|143)) 1) (not (if .call-has-occurred?|130 (memq .i1|143 .escaping|12) #f)) #f) #f) (let* ((.free-in-e1|151 (free-variables .e1|143)) (.newfree|154 (union .free-in-e1|151 .free|130))) (let () (if (let ((.temp|158|161 (memq .i1|143 .newfree|154))) (if .temp|158|161 .temp|158|161 (not (empty-set? (intersection .free-in-e1|151 .defined|9))))) (.return|19 .exprs|130 .assigns|130) (.loop|19 (let ((.x|163|166 .exprs|130)) (begin (.check! (pair? .x|163|166) 1 .x|163|166) (cdr:pair .x|163|166))) (cons (let ((.x|167|170 .exprs|130)) (begin (.check! (pair? .x|167|170) 0 .x|167|170) (car:pair .x|167|170))) .assigns|130) (let ((.temp|171|174 .call-has-occurred?|130)) (if .temp|171|174 .temp|171|174 (might-return-twice? .e1|143))) .newfree|154)))) (.return|19 .exprs|130 .assigns|130))) (.return|19 .exprs|130 .assigns|130))))) (.loop|19 (begin.exprs (lambda.body .l|3)) '() #f '()))))) (unspecified)) .l|3))) (.single-assignment-elimination|2 .l|1 .notepad|1))))) 'single-assignment-elimination))
(let () (begin (set! free-variables (lambda (.exp|1) (let ((.free-variables|2 0)) (begin (set! .free-variables|2 (lambda (.exp|3) (let ((.temp|4|7 (let ((.x|64|67 .exp|3)) (begin (.check! (pair? .x|64|67) 0 .x|64|67) (car:pair .x|64|67))))) (if (memv .temp|4|7 '(quote)) '() (if (memv .temp|4|7 '(lambda)) (difference (lambda.f .exp|3) (make-null-terminated (lambda.args .exp|3))) (if (memv .temp|4|7 '(set!)) (union (cons (assignment.lhs .exp|3) '()) (.free-variables|2 (assignment.rhs .exp|3))) (if (memv .temp|4|7 '(if)) (union (.free-variables|2 (if.test .exp|3)) (.free-variables|2 (if.then .exp|3)) (.free-variables|2 (if.else .exp|3))) (if (memv .temp|4|7 '(begin)) (if (variable? .exp|3) (cons (variable.name .exp|3) '()) (apply union (let () (let ((.loop|20|23|26 (unspecified))) (begin (set! .loop|20|23|26 (lambda (.y1|15|16|27 .results|15|19|27) (if (null? .y1|15|16|27) (reverse .results|15|19|27) (begin #t (.loop|20|23|26 (let ((.x|31|34 .y1|15|16|27)) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34))) (cons (.free-variables|2 (let ((.x|35|38 .y1|15|16|27)) (begin (.check! (pair? .x|35|38) 0 .x|35|38) (car:pair .x|35|38)))) .results|15|19|27)))))) (.loop|20|23|26 (begin.exprs .exp|3) '())))))) (apply union (let () (let ((.loop|45|48|51 (unspecified))) (begin (set! .loop|45|48|51 (lambda (.y1|40|41|52 .results|40|44|52) (if (null? .y1|40|41|52) (reverse .results|40|44|52) (begin #t (.loop|45|48|51 (let ((.x|56|59 .y1|40|41|52)) (begin (.check! (pair? .x|56|59) 1 .x|56|59) (cdr:pair .x|56|59))) (cons (.free-variables|2 (let ((.x|60|63 .y1|40|41|52)) (begin (.check! (pair? .x|60|63) 0 .x|60|63) (car:pair .x|60|63)))) .results|40|44|52)))))) (.loop|45|48|51 .exp|3 '()))))))))))))) (.free-variables|2 .exp|1))))) 'free-variables))
(let () (begin (set! might-return-twice? (lambda (.exp|1) (let ((.might-return-twice?|2 0)) (begin (set! .might-return-twice?|2 (lambda (.exp|3) (let ((.temp|4|7 (let ((.x|23|26 .exp|3)) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26))))) (if (memv .temp|4|7 '(quote)) #f (if (memv .temp|4|7 '(lambda)) #f (if (memv .temp|4|7 '(set!)) (.might-return-twice?|2 (assignment.rhs .exp|3)) (if (memv .temp|4|7 '(if)) (let ((.temp|12|15 (.might-return-twice?|2 (if.test .exp|3)))) (if .temp|12|15 .temp|12|15 (let ((.temp|16|19 (.might-return-twice?|2 (if.then .exp|3)))) (if .temp|16|19 .temp|16|19 (.might-return-twice?|2 (if.else .exp|3)))))) (if (memv .temp|4|7 '(begin)) (if (variable? .exp|3) #f (some? .might-return-twice?|2 (begin.exprs .exp|3))) #t)))))))) (.might-return-twice?|2 .exp|1))))) 'might-return-twice?))
(let () (begin (set! assignment-elimination (lambda (.l|1) (let ((.assignment-elimination|2 0)) (begin (set! .assignment-elimination|2 (lambda (.l|3) (let ((.r|6 (lambda.r .l|3))) (let ((.update-old-reference-info!|7 (unspecified)) (.new-reference-info|7 (unspecified)) (.cellify!|7 (unspecified)) (.generate-new-name|7 (unspecified)) (.eliminate|7 (unspecified)) (.loop|7 (unspecified))) (begin (set! .update-old-reference-info!|7 (lambda (.ref|8) (begin (references-set! .r|6 (variable.name .ref|8) (cons .ref|8 '())) (assignments-set! .r|6 (variable.name .ref|8) '()) (calls-set! .r|6 (variable.name .ref|8) '())))) (set! .new-reference-info|7 (lambda (.augmented-entry|10) (make-r-entry (let ((.x|11|14 .augmented-entry|10)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14))) (r-entry.references (let ((.x|16|19 (let ((.x|20|23 .augmented-entry|10)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))))) (begin (.check! (pair? .x|16|19) 0 .x|16|19) (car:pair .x|16|19)))) '() '()))) (set! .cellify!|7 (lambda (.augmented-entry|24) (let ((.newname|27 (let ((.x|90|93 .augmented-entry|24)) (begin (.check! (pair? .x|90|93) 0 .x|90|93) (car:pair .x|90|93)))) (.entry|27 (let ((.x|95|98 (let ((.x|99|102 .augmented-entry|24)) (begin (.check! (pair? .x|99|102) 1 .x|99|102) (cdr:pair .x|99|102))))) (begin (.check! (pair? .x|95|98) 0 .x|95|98) (car:pair .x|95|98))))) (begin (let () (let ((.loop|29|31|34 (unspecified))) (begin (set! .loop|29|31|34 (lambda (.refs|35) (if (null? .refs|35) (if #f #f (unspecified)) (begin (begin #t (let* ((.reference|40 (let ((.x|51|54 .refs|35)) (begin (.check! (pair? .x|51|54) 0 .x|51|54) (car:pair .x|51|54)))) (.newref|43 (make-variable .newname|27))) (let () (begin (set-car! .reference|40 (make-variable name:cell-ref)) (set-car! (let ((.x|47|50 .reference|40)) (begin (.check! (pair? .x|47|50) 1 .x|47|50) (cdr:pair .x|47|50))) .newref|43) (set-car! .refs|35 .newref|43))))) (.loop|29|31|34 (let ((.x|55|58 .refs|35)) (begin (.check! (pair? .x|55|58) 1 .x|55|58) (cdr:pair .x|55|58)))))))) (.loop|29|31|34 (r-entry.references .entry|27))))) (let () (let ((.loop|60|62|65 (unspecified))) (begin (set! .loop|60|62|65 (lambda (.assigns|66) (if (null? .assigns|66) (if #f #f (unspecified)) (begin (begin #t (let* ((.assignment|71 (let ((.x|82|85 .assigns|66)) (begin (.check! (pair? .x|82|85) 0 .x|82|85) (car:pair .x|82|85)))) (.newref|74 (make-variable .newname|27))) (let () (begin (set-car! .assignment|71 (make-variable name:cell-set!)) (set-car! (let ((.x|78|81 .assignment|71)) (begin (.check! (pair? .x|78|81) 1 .x|78|81) (cdr:pair .x|78|81))) .newref|74) (r-entry.references-set! .entry|27 (cons .newref|74 (r-entry.references .entry|27))))))) (.loop|60|62|65 (let ((.x|86|89 .assigns|66)) (begin (.check! (pair? .x|86|89) 1 .x|86|89) (cdr:pair .x|86|89)))))))) (.loop|60|62|65 (r-entry.assignments .entry|27))))) (r-entry.assignments-set! .entry|27 '()))))) (set! .generate-new-name|7 (lambda (.name|103) (string->symbol (string-append cell-prefix (symbol->string .name|103))))) (set! .eliminate|7 (lambda (.assigned|104) (let* ((.oldnames|107 (let () (let ((.loop|554|557|560 (unspecified))) (begin (set! .loop|554|557|560 (lambda (.y1|549|550|561 .results|549|553|561) (if (null? .y1|549|550|561) (reverse .results|549|553|561) (begin #t (.loop|554|557|560 (let ((.x|565|568 .y1|549|550|561)) (begin (.check! (pair? .x|565|568) 1 .x|565|568) (cdr:pair .x|565|568))) (cons (r-entry.name (let ((.x|569|572 .y1|549|550|561)) (begin (.check! (pair? .x|569|572) 0 .x|569|572) (car:pair .x|569|572)))) .results|549|553|561)))))) (.loop|554|557|560 .assigned|104 '()))))) (.newnames|110 (let () (let ((.loop|530|533|536 (unspecified))) (begin (set! .loop|530|533|536 (lambda (.y1|525|526|537 .results|525|529|537) (if (null? .y1|525|526|537) (reverse .results|525|529|537) (begin #t (.loop|530|533|536 (let ((.x|541|544 .y1|525|526|537)) (begin (.check! (pair? .x|541|544) 1 .x|541|544) (cdr:pair .x|541|544))) (cons (.generate-new-name|7 (let ((.x|545|548 .y1|525|526|537)) (begin (.check! (pair? .x|545|548) 0 .x|545|548) (car:pair .x|545|548)))) .results|525|529|537)))))) (.loop|530|533|536 .oldnames|107 '())))))) (let () (let ((.augmented-entries|116 (let () (let ((.loop|444|448|451 (unspecified))) (begin (set! .loop|444|448|451 (lambda (.y1|438|440|452 .y1|438|439|452 .results|438|443|452) (if (let ((.temp|454|457 (null? .y1|438|440|452))) (if .temp|454|457 .temp|454|457 (null? .y1|438|439|452))) (reverse .results|438|443|452) (begin #t (.loop|444|448|451 (let ((.x|460|463 .y1|438|440|452)) (begin (.check! (pair? .x|460|463) 1 .x|460|463) (cdr:pair .x|460|463))) (let ((.x|464|467 .y1|438|439|452)) (begin (.check! (pair? .x|464|467) 1 .x|464|467) (cdr:pair .x|464|467))) (cons (let* ((.t1|468|471 (let ((.x|483|486 .y1|438|440|452)) (begin (.check! (pair? .x|483|486) 0 .x|483|486) (car:pair .x|483|486)))) (.t2|468|474 (cons (let ((.x|479|482 .y1|438|439|452)) (begin (.check! (pair? .x|479|482) 0 .x|479|482) (car:pair .x|479|482))) '()))) (let () (cons .t1|468|471 .t2|468|474))) .results|438|443|452)))))) (.loop|444|448|451 .newnames|110 .assigned|104 '()))))) (.renaming-alist|116 (let () (let ((.loop|493|497|500 (unspecified))) (begin (set! .loop|493|497|500 (lambda (.y1|487|489|501 .y1|487|488|501 .results|487|492|501) (if (let ((.temp|503|506 (null? .y1|487|489|501))) (if .temp|503|506 .temp|503|506 (null? .y1|487|488|501))) (reverse .results|487|492|501) (begin #t (.loop|493|497|500 (let ((.x|509|512 .y1|487|489|501)) (begin (.check! (pair? .x|509|512) 1 .x|509|512) (cdr:pair .x|509|512))) (let ((.x|513|516 .y1|487|488|501)) (begin (.check! (pair? .x|513|516) 1 .x|513|516) (cdr:pair .x|513|516))) (cons (cons (let ((.x|517|520 .y1|487|489|501)) (begin (.check! (pair? .x|517|520) 0 .x|517|520) (car:pair .x|517|520))) (let ((.x|521|524 .y1|487|488|501)) (begin (.check! (pair? .x|521|524) 0 .x|521|524) (car:pair .x|521|524)))) .results|487|492|501)))))) (.loop|493|497|500 .oldnames|107 .newnames|110 '()))))) (.defs|116 (lambda.defs .l|3))) (begin (let () (let ((.loop|122|124|127 (unspecified))) (begin (set! .loop|122|124|127 (lambda (.y1|117|118|128) (if (null? .y1|117|118|128) (if #f #f (unspecified)) (begin (begin #t (.cellify!|7 (let ((.x|132|135 .y1|117|118|128)) (begin (.check! (pair? .x|132|135) 0 .x|132|135) (car:pair .x|132|135))))) (.loop|122|124|127 (let ((.x|136|139 .y1|117|118|128)) (begin (.check! (pair? .x|136|139) 1 .x|136|139) (cdr:pair .x|136|139)))))))) (.loop|122|124|127 .augmented-entries|116)))) (let () (let ((.loop|145|147|150 (unspecified))) (begin (set! .loop|145|147|150 (lambda (.y1|140|141|151) (if (null? .y1|140|141|151) (if #f #f (unspecified)) (begin (begin #t (let ((.def|155 (let ((.x|181|184 .y1|140|141|151)) (begin (.check! (pair? .x|181|184) 0 .x|181|184) (car:pair .x|181|184))))) (let () (let ((.loop|157|159|162 (unspecified))) (begin (set! .loop|157|159|162 (lambda (.free|163) (if (null? .free|163) (if #f #f (unspecified)) (begin (begin #t (let ((.z|168 (assq (let ((.x|173|176 .free|163)) (begin (.check! (pair? .x|173|176) 0 .x|173|176) (car:pair .x|173|176))) .renaming-alist|116))) (if .z|168 (set-car! .free|163 (let ((.x|169|172 .z|168)) (begin (.check! (pair? .x|169|172) 1 .x|169|172) (cdr:pair .x|169|172)))) (unspecified)))) (.loop|157|159|162 (let ((.x|177|180 .free|163)) (begin (.check! (pair? .x|177|180) 1 .x|177|180) (cdr:pair .x|177|180)))))))) (.loop|157|159|162 (lambda.f (def.rhs .def|155)))))))) (.loop|145|147|150 (let ((.x|185|188 .y1|140|141|151)) (begin (.check! (pair? .x|185|188) 1 .x|185|188) (cdr:pair .x|185|188)))))))) (.loop|145|147|150 .defs|116)))) (let ((.newbody|191 (make-call (make-lambda (let () (let ((.loop|294|297|300 (unspecified))) (begin (set! .loop|294|297|300 (lambda (.y1|289|290|301 .results|289|293|301) (if (null? .y1|289|290|301) (reverse .results|289|293|301) (begin #t (.loop|294|297|300 (let ((.x|305|308 .y1|289|290|301)) (begin (.check! (pair? .x|305|308) 1 .x|305|308) (cdr:pair .x|305|308))) (cons (let ((.x|309|312 (let ((.x|313|316 .y1|289|290|301)) (begin (.check! (pair? .x|313|316) 0 .x|313|316) (car:pair .x|313|316))))) (begin (.check! (pair? .x|309|312) 0 .x|309|312) (car:pair .x|309|312))) .results|289|293|301)))))) (.loop|294|297|300 .augmented-entries|116 '())))) .defs|116 (union (let () (let ((.loop|322|325|328 (unspecified))) (begin (set! .loop|322|325|328 (lambda (.y1|317|318|329 .results|317|321|329) (if (null? .y1|317|318|329) (reverse .results|317|321|329) (begin #t (.loop|322|325|328 (let ((.x|333|336 .y1|317|318|329)) (begin (.check! (pair? .x|333|336) 1 .x|333|336) (cdr:pair .x|333|336))) (cons (let ((.def|337 (let ((.x|338|341 .y1|317|318|329)) (begin (.check! (pair? .x|338|341) 0 .x|338|341) (car:pair .x|338|341))))) (r-entry .r|6 (def.lhs .def|337))) .results|317|321|329)))))) (.loop|322|325|328 .defs|116 '())))) (let () (let ((.loop|347|350|353 (unspecified))) (begin (set! .loop|347|350|353 (lambda (.y1|342|343|354 .results|342|346|354) (if (null? .y1|342|343|354) (reverse .results|342|346|354) (begin #t (.loop|347|350|353 (let ((.x|358|361 .y1|342|343|354)) (begin (.check! (pair? .x|358|361) 1 .x|358|361) (cdr:pair .x|358|361))) (cons (.new-reference-info|7 (let ((.x|362|365 .y1|342|343|354)) (begin (.check! (pair? .x|362|365) 0 .x|362|365) (car:pair .x|362|365)))) .results|342|346|354)))))) (.loop|347|350|353 .augmented-entries|116 '()))))) (union (let* ((.t1|366|369 name:cell-ref) (.t2|366|372 (cons name:cell-set! '()))) (let () (cons .t1|366|369 .t2|366|372))) .newnames|110 (difference (lambda.f .l|3) .oldnames|107)) (union (let* ((.t1|377|380 name:cell-ref) (.t2|377|383 (cons name:cell-set! '()))) (let () (cons .t1|377|380 .t2|377|383))) .newnames|110 (difference (lambda.g .l|3) .oldnames|107)) (lambda.decls .l|3) (lambda.doc .l|3) (lambda.body .l|3)) (let () (let ((.loop|393|396|399 (unspecified))) (begin (set! .loop|393|396|399 (lambda (.y1|388|389|400 .results|388|392|400) (if (null? .y1|388|389|400) (reverse .results|388|392|400) (begin #t (.loop|393|396|399 (let ((.x|404|407 .y1|388|389|400)) (begin (.check! (pair? .x|404|407) 1 .x|404|407) (cdr:pair .x|404|407))) (cons (let ((.name|408 (let ((.x|410|413 .y1|388|389|400)) (begin (.check! (pair? .x|410|413) 0 .x|410|413) (car:pair .x|410|413))))) (make-call (make-variable name:make-cell) (cons (make-variable .name|408) '()))) .results|388|392|400)))))) (.loop|393|396|399 (let () (let ((.loop|419|422|425 (unspecified))) (begin (set! .loop|419|422|425 (lambda (.y1|414|415|426 .results|414|418|426) (if (null? .y1|414|415|426) (reverse .results|414|418|426) (begin #t (.loop|419|422|425 (let ((.x|430|433 .y1|414|415|426)) (begin (.check! (pair? .x|430|433) 1 .x|430|433) (cdr:pair .x|430|433))) (cons (r-entry.name (let ((.x|434|437 .y1|414|415|426)) (begin (.check! (pair? .x|434|437) 0 .x|434|437) (car:pair .x|434|437)))) .results|414|418|426)))))) (.loop|419|422|425 .assigned|104 '())))) '()))))))) (begin (lambda.f-set! .l|3 (union (let* ((.t1|192|195 name:make-cell) (.t2|192|198 (let* ((.t1|202|205 name:cell-ref) (.t2|202|208 (cons name:cell-set! '()))) (let () (cons .t1|202|205 .t2|202|208))))) (let () (cons .t1|192|195 .t2|192|198))) (difference (lambda.f .l|3) (let () (let ((.loop|218|221|224 (unspecified))) (begin (set! .loop|218|221|224 (lambda (.y1|213|214|225 .results|213|217|225) (if (null? .y1|213|214|225) (reverse .results|213|217|225) (begin #t (.loop|218|221|224 (let ((.x|229|232 .y1|213|214|225)) (begin (.check! (pair? .x|229|232) 1 .x|229|232) (cdr:pair .x|229|232))) (cons (def.lhs (let ((.x|233|236 .y1|213|214|225)) (begin (.check! (pair? .x|233|236) 0 .x|233|236) (car:pair .x|233|236)))) .results|213|217|225)))))) (.loop|218|221|224 (lambda.defs .l|3) '()))))))) (lambda.defs-set! .l|3 '()) (let () (let ((.loop|242|244|247 (unspecified))) (begin (set! .loop|242|244|247 (lambda (.y1|237|238|248) (if (null? .y1|237|238|248) (if #f #f (unspecified)) (begin (begin #t (.update-old-reference-info!|7 (let ((.x|252|255 .y1|237|238|248)) (begin (.check! (pair? .x|252|255) 0 .x|252|255) (car:pair .x|252|255))))) (.loop|242|244|247 (let ((.x|256|259 .y1|237|238|248)) (begin (.check! (pair? .x|256|259) 1 .x|256|259) (cdr:pair .x|256|259)))))))) (.loop|242|244|247 (let () (let ((.loop|265|268|271 (unspecified))) (begin (set! .loop|265|268|271 (lambda (.y1|260|261|272 .results|260|264|272) (if (null? .y1|260|261|272) (reverse .results|260|264|272) (begin #t (.loop|265|268|271 (let ((.x|276|279 .y1|260|261|272)) (begin (.check! (pair? .x|276|279) 1 .x|276|279) (cdr:pair .x|276|279))) (cons (let* ((.arg|280 (let ((.x|285|288 .y1|260|261|272)) (begin (.check! (pair? .x|285|288) 0 .x|285|288) (car:pair .x|285|288)))) (.x|281|284 (call.args .arg|280))) (begin (.check! (pair? .x|281|284) 0 .x|281|284) (car:pair .x|281|284))) .results|260|264|272)))))) (.loop|265|268|271 (call.args .newbody|191) '())))))))) (lambda.body-set! .l|3 .newbody|191) (lambda-lifting (call.proc .newbody|191) .l|3))))))))) (set! .loop|7 (lambda (.entries|573 .assigned|573) (if (null? .entries|573) (if (not (null? .assigned|573)) (.eliminate|7 .assigned|573) (unspecified)) (if (not (null? (r-entry.assignments (let ((.x|576|579 .entries|573)) (begin (.check! (pair? .x|576|579) 0 .x|576|579) (car:pair .x|576|579)))))) (.loop|7 (let ((.x|580|583 .entries|573)) (begin (.check! (pair? .x|580|583) 1 .x|580|583) (cdr:pair .x|580|583))) (cons (let ((.x|584|587 .entries|573)) (begin (.check! (pair? .x|584|587) 0 .x|584|587) (car:pair .x|584|587))) .assigned|573)) (if (null? (r-entry.references (let ((.x|589|592 .entries|573)) (begin (.check! (pair? .x|589|592) 0 .x|589|592) (car:pair .x|589|592))))) (begin (flag-as-ignored (r-entry.name (let ((.x|593|596 .entries|573)) (begin (.check! (pair? .x|593|596) 0 .x|593|596) (car:pair .x|593|596)))) .l|3) (.loop|7 (let ((.x|597|600 .entries|573)) (begin (.check! (pair? .x|597|600) 1 .x|597|600) (cdr:pair .x|597|600))) .assigned|573)) (.loop|7 (let ((.x|602|605 .entries|573)) (begin (.check! (pair? .x|602|605) 1 .x|602|605) (cdr:pair .x|602|605))) .assigned|573)))))) (.loop|7 .r|6 '())))))) (.assignment-elimination|2 .l|1))))) 'assignment-elimination))
(let () (begin (set! lambda-lifting (lambda (.l2|1 .l|1) (let ((.lambda-lifting|2 0)) (begin (set! .lambda-lifting|2 (lambda (.l2|3 .l|3) (let ((.lift|4 (unspecified))) (begin (set! .lift|4 (lambda (.l2|5 .l|5 .args-to-add|5) (let ((.formals|8 (make-null-terminated (lambda.args .l2|5)))) (begin (let () (let ((.loop|10|13|16 (unspecified))) (begin (set! .loop|10|13|16 (lambda (.defs|17 .args-to-add|17) (if (null? .defs|17) (if #f #f (unspecified)) (begin (begin #t (let* ((.def|22 (let ((.x|99|102 .defs|17)) (begin (.check! (pair? .x|99|102) 0 .x|99|102) (car:pair .x|99|102)))) (.entry|25 (r-lookup (lambda.r .l2|5) (def.lhs .def|22))) (.calls|28 (r-entry.calls .entry|25)) (.added|31 (twobit-sort (lambda (.x|89 .y|89) (let ((.xx|92 (memq .x|89 .formals|8)) (.yy|92 (memq .y|89 .formals|8))) (if (if .xx|92 .yy|92 #f) (> (length .xx|92) (length .yy|92)) #t))) (let ((.x|95|98 .args-to-add|17)) (begin (.check! (pair? .x|95|98) 0 .x|95|98) (car:pair .x|95|98))))) (.l3|34 (def.rhs .def|22))) (let () (begin (lambda.f-set! .l3|34 (union .added|31 (lambda.f .l3|34))) (lambda.args-set! .l3|34 (append .added|31 (lambda.args .l3|34))) (let () (let ((.loop|43|45|48 (unspecified))) (begin (set! .loop|43|45|48 (lambda (.y1|38|39|49) (if (null? .y1|38|39|49) (if #f #f (unspecified)) (begin (begin #t (let* ((.call|53 (let ((.x|81|84 .y1|38|39|49)) (begin (.check! (pair? .x|81|84) 0 .x|81|84) (car:pair .x|81|84)))) (.newargs|56 (let () (let ((.loop|62|65|68 (unspecified))) (begin (set! .loop|62|65|68 (lambda (.y1|57|58|69 .results|57|61|69) (if (null? .y1|57|58|69) (reverse .results|57|61|69) (begin #t (.loop|62|65|68 (let ((.x|73|76 .y1|57|58|69)) (begin (.check! (pair? .x|73|76) 1 .x|73|76) (cdr:pair .x|73|76))) (cons (make-variable (let ((.x|77|80 .y1|57|58|69)) (begin (.check! (pair? .x|77|80) 0 .x|77|80) (car:pair .x|77|80)))) .results|57|61|69)))))) (.loop|62|65|68 .added|31 '())))))) (call.args-set! .call|53 (append .newargs|56 (call.args .call|53))))) (.loop|43|45|48 (let ((.x|85|88 .y1|38|39|49)) (begin (.check! (pair? .x|85|88) 1 .x|85|88) (cdr:pair .x|85|88)))))))) (.loop|43|45|48 .calls|28)))) (lambda.r-set! .l2|5 (remq .entry|25 (lambda.r .l2|5))) (lambda.r-set! .l|5 (cons .entry|25 (lambda.r .l|5))))))) (.loop|10|13|16 (let ((.x|103|106 .defs|17)) (begin (.check! (pair? .x|103|106) 1 .x|103|106) (cdr:pair .x|103|106))) (let ((.x|107|110 .args-to-add|17)) (begin (.check! (pair? .x|107|110) 1 .x|107|110) (cdr:pair .x|107|110)))))))) (.loop|10|13|16 (lambda.defs .l2|5) .args-to-add|5)))) (if (not (eq? .l2|5 .l|5)) (begin (lambda.defs-set! .l|5 (append (lambda.defs .l2|5) (lambda.defs .l|5))) (lambda.defs-set! .l2|5 '())) (unspecified)))))) (if .l|3 (if (not (null? (lambda.defs .l2|3))) (let ((.args-to-add|113 (compute-added-arguments (lambda.defs .l2|3) (make-null-terminated (lambda.args .l2|3))))) (if (policy:lift? .l2|3 .l|3 .args-to-add|113) (.lift|4 .l2|3 .l|3 .args-to-add|113) (unspecified))) (unspecified)) (unspecified)))))) (.lambda-lifting|2 .l2|1 .l|1))))) 'lambda-lifting))
(let () (begin (set! compute-added-arguments (lambda (.defs|1 .formals|1) (let ((.compute-added-arguments|2 0)) (begin (set! .compute-added-arguments|2 (lambda (.defs|3 .formals|3) (let ((.procs|6 (let () (let ((.loop|159|162|165 (unspecified))) (begin (set! .loop|159|162|165 (lambda (.y1|154|155|166 .results|154|158|166) (if (null? .y1|154|155|166) (reverse .results|154|158|166) (begin #t (.loop|159|162|165 (let ((.x|170|173 .y1|154|155|166)) (begin (.check! (pair? .x|170|173) 1 .x|170|173) (cdr:pair .x|170|173))) (cons (def.lhs (let ((.x|174|177 .y1|154|155|166)) (begin (.check! (pair? .x|174|177) 0 .x|174|177) (car:pair .x|174|177)))) .results|154|158|166)))))) (.loop|159|162|165 .defs|3 '()))))) (.freevars|6 (let () (let ((.loop|183|186|189 (unspecified))) (begin (set! .loop|183|186|189 (lambda (.y1|178|179|190 .results|178|182|190) (if (null? .y1|178|179|190) (reverse .results|178|182|190) (begin #t (.loop|183|186|189 (let ((.x|194|197 .y1|178|179|190)) (begin (.check! (pair? .x|194|197) 1 .x|194|197) (cdr:pair .x|194|197))) (cons (lambda.f (let ((.x|198|201 .y1|178|179|190)) (begin (.check! (pair? .x|198|201) 0 .x|198|201) (car:pair .x|198|201)))) .results|178|182|190)))))) (.loop|183|186|189 (let () (let ((.loop|207|210|213 (unspecified))) (begin (set! .loop|207|210|213 (lambda (.y1|202|203|214 .results|202|206|214) (if (null? .y1|202|203|214) (reverse .results|202|206|214) (begin #t (.loop|207|210|213 (let ((.x|218|221 .y1|202|203|214)) (begin (.check! (pair? .x|218|221) 1 .x|218|221) (cdr:pair .x|218|221))) (cons (def.rhs (let ((.x|222|225 .y1|202|203|214)) (begin (.check! (pair? .x|222|225) 0 .x|222|225) (car:pair .x|222|225)))) .results|202|206|214)))))) (.loop|207|210|213 .defs|3 '())))) '())))))) (let ((.callgraph|9 (let () (let ((.loop|84|87|90 (unspecified))) (begin (set! .loop|84|87|90 (lambda (.y1|79|80|91 .results|79|83|91) (if (null? .y1|79|80|91) (reverse .results|79|83|91) (begin #t (.loop|84|87|90 (let ((.x|95|98 .y1|79|80|91)) (begin (.check! (pair? .x|95|98) 1 .x|95|98) (cdr:pair .x|95|98))) (cons (let ((.names|99 (let ((.x|125|128 .y1|79|80|91)) (begin (.check! (pair? .x|125|128) 0 .x|125|128) (car:pair .x|125|128))))) (let () (let ((.loop|105|108|111 (unspecified))) (begin (set! .loop|105|108|111 (lambda (.y1|100|101|112 .results|100|104|112) (if (null? .y1|100|101|112) (reverse .results|100|104|112) (begin #t (.loop|105|108|111 (let ((.x|116|119 .y1|100|101|112)) (begin (.check! (pair? .x|116|119) 1 .x|116|119) (cdr:pair .x|116|119))) (cons (let ((.name|120 (let ((.x|121|124 .y1|100|101|112)) (begin (.check! (pair? .x|121|124) 0 .x|121|124) (car:pair .x|121|124))))) (position .name|120 .procs|6)) .results|100|104|112)))))) (.loop|105|108|111 (intersection .names|99 .procs|6) '()))))) .results|79|83|91)))))) (.loop|84|87|90 .freevars|6 '()))))) (.added_0|9 (let () (let ((.loop|134|137|140 (unspecified))) (begin (set! .loop|134|137|140 (lambda (.y1|129|130|141 .results|129|133|141) (if (null? .y1|129|130|141) (reverse .results|129|133|141) (begin #t (.loop|134|137|140 (let ((.x|145|148 .y1|129|130|141)) (begin (.check! (pair? .x|145|148) 1 .x|145|148) (cdr:pair .x|145|148))) (cons (let ((.names|149 (let ((.x|150|153 .y1|129|130|141)) (begin (.check! (pair? .x|150|153) 0 .x|150|153) (car:pair .x|150|153))))) (intersection .names|149 .formals|3)) .results|129|133|141)))))) (.loop|134|137|140 .freevars|6 '())))))) (vector->list (compute-fixedpoint (make-vector (length .procs|6) '()) (list->vector (let () (let ((.loop|16|20|23 (unspecified))) (begin (set! .loop|16|20|23 (lambda (.y1|10|12|24 .y1|10|11|24 .results|10|15|24) (if (let ((.temp|26|29 (null? .y1|10|12|24))) (if .temp|26|29 .temp|26|29 (null? .y1|10|11|24))) (reverse .results|10|15|24) (begin #t (.loop|16|20|23 (let ((.x|32|35 .y1|10|12|24)) (begin (.check! (pair? .x|32|35) 1 .x|32|35) (cdr:pair .x|32|35))) (let ((.x|36|39 .y1|10|11|24)) (begin (.check! (pair? .x|36|39) 1 .x|36|39) (cdr:pair .x|36|39))) (cons (let ((.term0|40 (let ((.x|71|74 .y1|10|12|24)) (begin (.check! (pair? .x|71|74) 0 .x|71|74) (car:pair .x|71|74)))) (.indexes|40 (let ((.x|75|78 .y1|10|11|24)) (begin (.check! (pair? .x|75|78) 0 .x|75|78) (car:pair .x|75|78))))) (lambda (.approximations|41) (union .term0|40 (apply union (let () (let ((.loop|47|50|53 (unspecified))) (begin (set! .loop|47|50|53 (lambda (.y1|42|43|54 .results|42|46|54) (if (null? .y1|42|43|54) (reverse .results|42|46|54) (begin #t (.loop|47|50|53 (let ((.x|58|61 .y1|42|43|54)) (begin (.check! (pair? .x|58|61) 1 .x|58|61) (cdr:pair .x|58|61))) (cons (let ((.i|62 (let ((.x|67|70 .y1|42|43|54)) (begin (.check! (pair? .x|67|70) 0 .x|67|70) (car:pair .x|67|70))))) (let ((.v|63|66 .approximations|41) (.i|63|66 .i|62)) (begin (.check! (fixnum? .i|63|66) 40 .v|63|66 .i|63|66) (.check! (vector? .v|63|66) 40 .v|63|66 .i|63|66) (.check! (<:fix:fix .i|63|66 (vector-length:vec .v|63|66)) 40 .v|63|66 .i|63|66) (.check! (>=:fix:fix .i|63|66 0) 40 .v|63|66 .i|63|66) (vector-ref:trusted .v|63|66 .i|63|66)))) .results|42|46|54)))))) (.loop|47|50|53 .indexes|40 '())))))))) .results|10|15|24)))))) (.loop|16|20|23 .added_0|9 .callgraph|9 '()))))) set-equal?)))))) (.compute-added-arguments|2 .defs|1 .formals|1))))) 'compute-added-arguments))
(let () (begin (set! position (lambda (.x|1 .l|1) (let ((.position|2 0)) (begin (set! .position|2 (lambda (.x|3 .l|3) (if (eq? .x|3 (let ((.x|5|8 .l|3)) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8)))) 0 (+ 1 (.position|2 .x|3 (let ((.x|10|13 .l|3)) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13)))))))) (.position|2 .x|1 .l|1))))) 'position))
(let () (begin (set! compute-fixedpoint (lambda (.v|1 .functions|1 .equiv?|1) (let ((.compute-fixedpoint|2 0)) (begin (set! .compute-fixedpoint|2 (lambda (.v|3 .functions|3 .equiv?|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.i|5 .flag|5) (if (< .i|5 0) (if .flag|5 (.loop|4 (- (let ((.v|7|10 .v|3)) (begin (.check! (vector? .v|7|10) 42 .v|7|10) (vector-length:vec .v|7|10))) 1) #f) .v|3) (let ((.next_i|13 ((let ((.v|22|25 .functions|3) (.i|22|25 .i|5)) (begin (.check! (fixnum? .i|22|25) 40 .v|22|25 .i|22|25) (.check! (vector? .v|22|25) 40 .v|22|25 .i|22|25) (.check! (<:fix:fix .i|22|25 (vector-length:vec .v|22|25)) 40 .v|22|25 .i|22|25) (.check! (>=:fix:fix .i|22|25 0) 40 .v|22|25 .i|22|25) (vector-ref:trusted .v|22|25 .i|22|25))) .v|3))) (if (.equiv?|3 .next_i|13 (let ((.v|14|17 .v|3) (.i|14|17 .i|5)) (begin (.check! (fixnum? .i|14|17) 40 .v|14|17 .i|14|17) (.check! (vector? .v|14|17) 40 .v|14|17 .i|14|17) (.check! (<:fix:fix .i|14|17 (vector-length:vec .v|14|17)) 40 .v|14|17 .i|14|17) (.check! (>=:fix:fix .i|14|17 0) 40 .v|14|17 .i|14|17) (vector-ref:trusted .v|14|17 .i|14|17)))) (.loop|4 (- .i|5 1) .flag|5) (begin (let ((.v|18|21 .v|3) (.i|18|21 .i|5) (.x|18|21 .next_i|13)) (begin (.check! (fixnum? .i|18|21) 41 .v|18|21 .i|18|21 .x|18|21) (.check! (vector? .v|18|21) 41 .v|18|21 .i|18|21 .x|18|21) (.check! (<:fix:fix .i|18|21 (vector-length:vec .v|18|21)) 41 .v|18|21 .i|18|21 .x|18|21) (.check! (>=:fix:fix .i|18|21 0) 41 .v|18|21 .i|18|21 .x|18|21) (vector-set!:trusted .v|18|21 .i|18|21 .x|18|21))) (.loop|4 (- .i|5 1) #t))))))) (.loop|4 (- (let ((.v|26|29 .v|3)) (begin (.check! (vector? .v|26|29) 42 .v|26|29) (vector-length:vec .v|26|29))) 1) #f))))) (.compute-fixedpoint|2 .v|1 .functions|1 .equiv?|1))))) 'compute-fixedpoint))
(let () (begin (set! policy:lift? (lambda (.l2|1 .l|1 .args-to-add|1) (let ((.policy:lift?|2 0)) (begin (set! .policy:lift?|2 (lambda (.l2|3 .l|3 .args-to-add|3) (if (lambda-optimizations) (if (not (lambda? (lambda.body .l2|3))) (every? (lambda (.addlist|7) (< (length .addlist|7) 6)) .args-to-add|3) #f) #f))) (.policy:lift?|2 .l2|1 .l|1 .args-to-add|1))))) 'policy:lift?))
(let () (begin (set! simplify-conditional (lambda (.exp|1 .notepad|1) (let ((.simplify-conditional|2 0)) (begin (set! .simplify-conditional|2 (lambda (.exp|3 .notepad|3) (let ((.coercion-to-boolean?|4 (unspecified))) (begin (set! .coercion-to-boolean?|4 (lambda (.exp|5) (if (conditional? .exp|5) (let ((.e1|10 (if.then .exp|5)) (.e2|10 (if.else .exp|5))) (if (constant? .e1|10) (if (eq? #t (constant.value .e1|10)) (if (constant? .e2|10) (eq? #f (constant.value .e2|10)) #f) #f) #f)) #f))) (if (not (control-optimization)) (begin (if.test-set! .exp|3 (simplify (if.test .exp|3) .notepad|3)) (if.then-set! .exp|3 (simplify (if.then .exp|3) .notepad|3)) (if.else-set! .exp|3 (simplify (if.else .exp|3) .notepad|3)) .exp|3) (let ((.test|17 (if.test .exp|3))) (let () (if (if (call? .test|17) (if (lambda? (call.proc .test|17)) (let* ((.l|26 (call.proc .test|17)) (.body|29 (lambda.body .l|26))) (let () (if (conditional? .body|29) (let ((.r|37 (lambda.r .l|26)) (.b0|37 (if.test .body|29)) (.b1|37 (if.then .body|29))) (if (variable? .b0|37) (if (variable? .b1|37) (let ((.x|43 (variable.name .b0|37))) (if (eq? .x|43 (variable.name .b1|37)) (if (local? .r|37 .x|43) (if (= 1 (length .r|37)) (= 1 (length (call.args .test|17))) #f) #f) #f)) #f) #f)) #f))) #f) #f) (let* ((.l|50 (call.proc .test|17)) (.r|53 (lambda.r .l|50)) (.body|56 (lambda.body .l|50)) (.ref|59 (if.then .body|56)) (.x|62 (variable.name .ref|59)) (.entry|65 (r-entry .r|53 .x|62))) (let () (begin (if.then-set! .body|56 (make-constant #t)) (if.else-set! .body|56 (make-conditional (if.else .body|56) (make-constant #t) (make-constant #f))) (r-entry.references-set! .entry|65 (remq .ref|59 (r-entry.references .entry|65))) (.simplify-conditional|2 .exp|3 .notepad|3)))) (let ((.test|71 (simplify (if.test .exp|3) .notepad|3))) (let () (let ((.loop|74 (unspecified))) (begin (set! .loop|74 (lambda (.test|75) (begin (if.test-set! .exp|3 .test|75) (if (constant? .test|75) (simplify (if (constant.value .test|75) (if.then .exp|3) (if.else .exp|3)) .notepad|3) (if (if (conditional? .test|75) (if (constant? (if.then .test|75)) (constant? (if.else .test|75)) #f) #f) (if (if (constant.value (if.then .test|75)) (constant.value (if.else .test|75)) #f) (post-simplify-begin (make-begin (let* ((.t1|84|87 (if.test .test|75)) (.t2|84|90 (cons (simplify (if.then .exp|3) .notepad|3) '()))) (let () (cons .t1|84|87 .t2|84|90)))) .notepad|3) (if (if (not (constant.value (if.then .test|75))) (not (constant.value (if.else .test|75))) #f) (post-simplify-begin (make-begin (let* ((.t1|98|101 (if.test .test|75)) (.t2|98|104 (cons (simplify (if.else .exp|3) .notepad|3) '()))) (let () (cons .t1|98|101 .t2|98|104)))) .notepad|3) (begin (if (not (constant.value (if.then .test|75))) (let ((.temp|112 (if.then .exp|3))) (begin (if.then-set! .exp|3 (if.else .exp|3)) (if.else-set! .exp|3 .temp|112))) (unspecified)) (if.test-set! .exp|3 (if.test .test|75)) (.loop|74 (if.test .exp|3))))) (if (if (conditional? .test|75) (let ((.temp|116|119 (.coercion-to-boolean?|4 (if.then .test|75)))) (if .temp|116|119 .temp|116|119 (.coercion-to-boolean?|4 (if.else .test|75)))) #f) (begin (if (.coercion-to-boolean?|4 (if.then .test|75)) (if.then-set! .test|75 (if.test (if.then .test|75))) (if.else-set! .test|75 (if.test (if.else .test|75)))) (.loop|74 .test|75)) (let ((.temp|121|124 (if (conditional? .test|75) (if (variable? (if.test .test|75)) (let* ((.x|168 (variable.name (if.test .test|75))) (.temp|169|172 (if (variable? (if.then .test|75)) (if (eq? .x|168 (variable.name (if.then .test|75))) 1 #f) #f))) (if .temp|169|172 .temp|169|172 (if (variable? (if.else .test|75)) (if (eq? .x|168 (variable.name (if.else .test|75))) 2 #f) #f))) #f) #f))) (if .temp|121|124 (let ((.n|125 .temp|121|124)) (begin (let ((.temp|126|129 .n|125)) (if (memv .temp|126|129 '(1)) (if.then-set! .test|75 (make-constant #t)) (if (memv .temp|126|129 '(2)) (if.else-set! .test|75 (make-constant #f)) (unspecified)))) (.loop|74 .test|75))) (if (begin? .test|75) (let ((.exprs|135 (reverse (begin.exprs .test|75)))) (begin (if.test-set! .exp|3 (let ((.x|136|139 .exprs|135)) (begin (.check! (pair? .x|136|139) 0 .x|136|139) (car:pair .x|136|139)))) (post-simplify-begin (make-begin (reverse (cons (.loop|74 (let ((.x|140|143 .exprs|135)) (begin (.check! (pair? .x|140|143) 0 .x|140|143) (car:pair .x|140|143)))) (let ((.x|144|147 .exprs|135)) (begin (.check! (pair? .x|144|147) 1 .x|144|147) (cdr:pair .x|144|147)))))) .notepad|3))) (if (if (call? .test|75) (if (variable? (call.proc .test|75)) (if (eq? (variable.name (call.proc .test|75)) name:not) (if (integrable? name:not) (if (integrate-usual-procedures) (= (length (call.args .test|75)) 1) #f) #f) #f) #f) #f) (begin (let ((.temp|157 (if.then .exp|3))) (begin (if.then-set! .exp|3 (if.else .exp|3)) (if.else-set! .exp|3 .temp|157))) (.loop|74 (let ((.x|158|161 (call.args .test|75))) (begin (.check! (pair? .x|158|161) 0 .x|158|161) (car:pair .x|158|161))))) (simplify-case .exp|3 .notepad|3))))))))))) (.loop|74 .test|71))))))))))))) (.simplify-conditional|2 .exp|1 .notepad|1))))) 'simplify-conditional))
(let () (begin (set! simplify-case (lambda (.exp|1 .notepad|1) (let ((.simplify-case|2 0)) (begin (set! .simplify-case|2 (lambda (.exp|3 .notepad|3) (let ((.e0|6 (if.test .exp|3))) (if (if (call? .e0|6) (if (variable? (call.proc .e0|6)) (if (let* ((.name|12 (variable.name (call.proc .e0|6))) (.temp|13|16 (eq? .name|12 name:eq?))) (if .temp|13|16 .temp|13|16 (let ((.temp|17|20 (eq? .name|12 name:eqv?))) (if .temp|17|20 .temp|17|20 (let ((.temp|21|24 (eq? .name|12 name:memq))) (if .temp|21|24 .temp|21|24 (eq? .name|12 name:memv))))))) (if (integrate-usual-procedures) (if (= (length (call.args .e0|6)) 2) (if (variable? (let ((.x|29|32 (call.args .e0|6))) (begin (.check! (pair? .x|29|32) 0 .x|29|32) (car:pair .x|29|32)))) (constant? (let ((.x|35|38 (let ((.x|39|42 (call.args .e0|6))) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 0 .x|35|38) (car:pair .x|35|38)))) #f) #f) #f) #f) #f) #f) (simplify-case-clauses (variable.name (let ((.x|43|46 (call.args .e0|6))) (begin (.check! (pair? .x|43|46) 0 .x|43|46) (car:pair .x|43|46)))) .exp|3 .notepad|3) (begin (if.then-set! .exp|3 (simplify (if.then .exp|3) .notepad|3)) (if.else-set! .exp|3 (simplify (if.else .exp|3) .notepad|3)) .exp|3))))) (.simplify-case|2 .exp|1 .notepad|1))))) 'simplify-case))
(let () (begin (set! simplify-case-clauses (lambda (.var0|1 .e|1 .notepad|1) (let ((.simplify-case-clauses|2 0)) (begin (set! .simplify-case-clauses|2 (lambda (.var0|3 .e|3 .notepad|3) (let ((.analyze|4 (unspecified)) (.finish|4 (unspecified)) (.remove-duplicates|4 (unspecified)) (.collect-clauses|4 (unspecified)) (.notepad2|4 (unspecified))) (begin (set! .analyze|4 (lambda (.default|5 .fix|5 .chr|5 .sym|5 .other|5 .constants|5) (begin (notepad-var-add! .notepad2|4 .var0|3) (let () (let ((.loop|11|13|16 (unspecified))) (begin (set! .loop|11|13|16 (lambda (.y1|6|7|17) (if (null? .y1|6|7|17) (if #f #f (unspecified)) (begin (begin #t (let ((.l|21 (let ((.x|22|25 .y1|6|7|17)) (begin (.check! (pair? .x|22|25) 0 .x|22|25) (car:pair .x|22|25))))) (notepad-lambda-add! .notepad|3 .l|21))) (.loop|11|13|16 (let ((.x|26|29 .y1|6|7|17)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29)))))))) (.loop|11|13|16 (notepad.lambdas .notepad2|4))))) (let () (let ((.loop|35|37|40 (unspecified))) (begin (set! .loop|35|37|40 (lambda (.y1|30|31|41) (if (null? .y1|30|31|41) (if #f #f (unspecified)) (begin (begin #t (let ((.l|45 (let ((.x|46|49 .y1|30|31|41)) (begin (.check! (pair? .x|46|49) 0 .x|46|49) (car:pair .x|46|49))))) (notepad-nonescaping-add! .notepad|3 .l|45))) (.loop|35|37|40 (let ((.x|50|53 .y1|30|31|41)) (begin (.check! (pair? .x|50|53) 1 .x|50|53) (cdr:pair .x|50|53)))))))) (.loop|35|37|40 (notepad.nonescaping .notepad2|4))))) (let () (let ((.loop|59|61|64 (unspecified))) (begin (set! .loop|59|61|64 (lambda (.y1|54|55|65) (if (null? .y1|54|55|65) (if #f #f (unspecified)) (begin (begin #t (let ((.var|69 (let ((.x|70|73 .y1|54|55|65)) (begin (.check! (pair? .x|70|73) 0 .x|70|73) (car:pair .x|70|73))))) (notepad-var-add! .notepad|3 .var|69))) (.loop|59|61|64 (let ((.x|74|77 .y1|54|55|65)) (begin (.check! (pair? .x|74|77) 1 .x|74|77) (cdr:pair .x|74|77)))))))) (.loop|59|61|64 (append (let* ((.t1|78|81 name:fixnum?) (.t2|78|84 (let* ((.t1|88|91 name:char?) (.t2|88|94 (let* ((.t1|98|101 name:symbol?) (.t2|98|104 (let* ((.t1|108|111 name:fx<) (.t2|108|114 (let* ((.t1|118|121 name:fx-) (.t2|118|124 (let* ((.t1|128|131 name:char->integer) (.t2|128|134 (cons name:vector-ref '()))) (let () (cons .t1|128|131 .t2|128|134))))) (let () (cons .t1|118|121 .t2|118|124))))) (let () (cons .t1|108|111 .t2|108|114))))) (let () (cons .t1|98|101 .t2|98|104))))) (let () (cons .t1|88|91 .t2|88|94))))) (let () (cons .t1|78|81 .t2|78|84))) (notepad.vars .notepad2|4)))))) (analyze-clauses (notepad.vars .notepad2|4) .var0|3 .default|5 (reverse .fix|5) (reverse .chr|5) (reverse .sym|5) (reverse .other|5) .constants|5)))) (set! .finish|4 (lambda (.e|139 .fix|139 .chr|139 .sym|139 .other|139 .constants|139) (begin (if.else-set! .e|139 (simplify (if.else .e|139) .notepad2|4)) (.analyze|4 .e|139 .fix|139 .chr|139 .sym|139 .other|139 .constants|139)))) (set! .remove-duplicates|4 (lambda (.data|140 .set|140) (let ((.originals|143 .data|140) (.data|143 '()) (.set|143 .set|140)) (let () (let ((.loop|146 (unspecified))) (begin (set! .loop|146 (lambda (.originals|147 .data|147 .set|147) (if (null? .originals|147) (values .data|147 .set|147) (let ((.x|150 (let ((.x|152|155 .originals|147)) (begin (.check! (pair? .x|152|155) 0 .x|152|155) (car:pair .x|152|155)))) (.originals|150 (let ((.x|156|159 .originals|147)) (begin (.check! (pair? .x|156|159) 1 .x|156|159) (cdr:pair .x|156|159))))) (if (memv .x|150 .set|147) (.loop|146 .originals|150 .data|147 .set|147) (.loop|146 .originals|150 (cons .x|150 .data|147) (cons .x|150 .set|147))))))) (.loop|146 .originals|143 .data|143 .set|143))))))) (set! .collect-clauses|4 (lambda (.e|160 .fix|160 .chr|160 .sym|160 .other|160 .constants|160) (if (not (conditional? .e|160)) (.analyze|4 (simplify .e|160 .notepad2|4) .fix|160 .chr|160 .sym|160 .other|160 .constants|160) (let ((.test|163 (simplify (if.test .e|160) .notepad2|4)) (.code|163 (simplify (if.then .e|160) .notepad2|4))) (begin (if.test-set! .e|160 .test|163) (if.then-set! .e|160 .code|163) (if (not (call? .test|163)) (.finish|4 .e|160 .fix|160 .chr|160 .sym|160 .other|160 .constants|160) (let ((.proc|166 (call.proc .test|163)) (.args|166 (call.args .test|163))) (if (not (if (variable? .proc|166) (if (let* ((.name|171 (variable.name .proc|166)) (.temp|172|175 (eq? .name|171 name:eq?))) (if .temp|172|175 .temp|172|175 (let ((.temp|176|179 (eq? .name|171 name:eqv?))) (if .temp|176|179 .temp|176|179 (let ((.temp|180|183 (eq? .name|171 name:memq))) (if .temp|180|183 .temp|180|183 (eq? .name|171 name:memv))))))) (if (= (length .args|166) 2) (if (variable? (let ((.x|187|190 .args|166)) (begin (.check! (pair? .x|187|190) 0 .x|187|190) (car:pair .x|187|190)))) (if (eq? (variable.name (let ((.x|192|195 .args|166)) (begin (.check! (pair? .x|192|195) 0 .x|192|195) (car:pair .x|192|195)))) .var0|3) (constant? (let ((.x|198|201 (let ((.x|202|205 .args|166)) (begin (.check! (pair? .x|202|205) 1 .x|202|205) (cdr:pair .x|202|205))))) (begin (.check! (pair? .x|198|201) 0 .x|198|201) (car:pair .x|198|201)))) #f) #f) #f) #f) #f)) (.finish|4 .e|160 .fix|160 .chr|160 .sym|160 .other|160 .constants|160) (let ((.pred|208 (variable.name .proc|166)) (.datum|208 (constant.value (let ((.x|257|260 (let ((.x|261|264 .args|166)) (begin (.check! (pair? .x|261|264) 1 .x|261|264) (cdr:pair .x|261|264))))) (begin (.check! (pair? .x|257|260) 0 .x|257|260) (car:pair .x|257|260)))))) (if (let ((.temp|209|212 (if (let ((.temp|224|227 (eq? .pred|208 name:memv))) (if .temp|224|227 .temp|224|227 (eq? .pred|208 name:memq))) (not (list? .datum|208)) #f))) (if .temp|209|212 .temp|209|212 (let ((.temp|213|216 (if (eq? .pred|208 name:eq?) (not (eqv-is-ok? .datum|208)) #f))) (if .temp|213|216 .temp|213|216 (if (eq? .pred|208 name:memq) (not (every? (lambda (.datum|220) (eqv-is-ok? .datum|220)) .datum|208)) #f))))) (.finish|4 .e|160 .fix|160 .chr|160 .sym|160 .other|160 .constants|160) (call-with-values (lambda () (.remove-duplicates|4 (if (let ((.temp|231|234 (eq? .pred|208 name:eqv?))) (if .temp|231|234 .temp|231|234 (eq? .pred|208 name:eq?))) (cons .datum|208 '()) .datum|208) .constants|160)) (lambda (.data|237 .constants|237) (let ((.clause|240 (let* ((.t1|245|248 .data|237) (.t2|245|251 (cons .code|163 '()))) (let () (cons .t1|245|248 .t2|245|251)))) (.e2|240 (if.else .e|160))) (if (every? smallint? .data|237) (.collect-clauses|4 .e2|240 (cons .clause|240 .fix|160) .chr|160 .sym|160 .other|160 .constants|237) (if (every? char? .data|237) (.collect-clauses|4 .e2|240 .fix|160 (cons .clause|240 .chr|160) .sym|160 .other|160 .constants|237) (if (every? symbol? .data|237) (.collect-clauses|4 .e2|240 .fix|160 .chr|160 (cons .clause|240 .sym|160) .other|160 .constants|237) (.collect-clauses|4 .e2|240 .fix|160 .chr|160 .sym|160 (cons .clause|240 .other|160) .constants|237))))))))))))))))) (set! .notepad2|4 (make-notepad (notepad.parent .notepad|3))) (.collect-clauses|4 .e|3 '() '() '() '() '()))))) (.simplify-case-clauses|2 .var0|1 .e|1 .notepad|1))))) 'simplify-case-clauses))
(let () (begin (set! eqv-is-ok? (lambda (.x|1) (let ((.eqv-is-ok?|2 0)) (begin (set! .eqv-is-ok?|2 (lambda (.x|3) (let ((.temp|4|7 (smallint? .x|3))) (if .temp|4|7 .temp|4|7 (let ((.temp|8|11 (char? .x|3))) (if .temp|8|11 .temp|8|11 (let ((.temp|12|15 (symbol? .x|3))) (if .temp|12|15 .temp|12|15 (boolean? .x|3))))))))) (.eqv-is-ok?|2 .x|1))))) 'eqv-is-ok?))
(let () (begin (set! eq-is-ok? (lambda (.x|1) (let ((.eq-is-ok?|2 0)) (begin (set! .eq-is-ok?|2 (lambda (.x|3) (eqv-is-ok? .x|3))) (.eq-is-ok?|2 .x|1))))) 'eq-is-ok?))
(let () (begin (set! analyze-clauses (lambda (.f|1 .var0|1 .default|1 .fix|1 .chr|1 .sym|1 .other|1 .constants|1) (let ((.analyze-clauses|2 0)) (begin (set! .analyze-clauses|2 (lambda (.f|3 .var0|3 .default|3 .fix|3 .chr|3 .sym|3 .other|3 .constants|3) (if (let ((.temp|5|8 (if (null? .fix|3) (null? .chr|3) #f))) (if .temp|5|8 .temp|5|8 (< (length .constants|3) 12))) (implement-clauses-by-sequential-search .var0|3 .default|3 (append .fix|3 .chr|3 .sym|3 .other|3)) (implement-clauses .f|3 .var0|3 .default|3 .fix|3 .chr|3 .sym|3 .other|3 .constants|3)))) (.analyze-clauses|2 .f|1 .var0|1 .default|1 .fix|1 .chr|1 .sym|1 .other|1 .constants|1))))) 'analyze-clauses))
(let () (begin (set! implement-clauses (lambda (.f|1 .var0|1 .default|1 .fix|1 .chr|1 .sym|1 .other|1 .constants|1) (let ((.implement-clauses|2 0)) (begin (set! .implement-clauses|2 (lambda (.f|3 .var0|3 .default|3 .fix|3 .chr|3 .sym|3 .other|3 .constants|3) (let* ((.name:n|6 ((make-rename-procedure) 'n)) (.entry|9 (make-r-entry .name:n|6 '() '() '())) (.f|12 (union (make-set (cons .name:n|6 '())) .f|3)) (.l|15 (make-lambda (cons .name:n|6 '()) '() '() .f|12 '() '() #f (implement-case-dispatch .name:n|6 (cons .default|3 (let () (let ((.loop|138|141|144 (unspecified))) (begin (set! .loop|138|141|144 (lambda (.y1|133|134|145 .results|133|137|145) (if (null? .y1|133|134|145) (reverse .results|133|137|145) (begin #t (.loop|138|141|144 (let ((.x|149|152 .y1|133|134|145)) (begin (.check! (pair? .x|149|152) 1 .x|149|152) (cdr:pair .x|149|152))) (cons (let ((.x|154|157 (let ((.x|158|161 (let ((.x|162|165 .y1|133|134|145)) (begin (.check! (pair? .x|162|165) 0 .x|162|165) (car:pair .x|162|165))))) (begin (.check! (pair? .x|158|161) 1 .x|158|161) (cdr:pair .x|158|161))))) (begin (.check! (pair? .x|154|157) 0 .x|154|157) (car:pair .x|154|157))) .results|133|137|145)))))) (.loop|138|141|144 (append .other|3 .fix|3 .chr|3 .sym|3) '()))))))))) (let () (make-call .l|15 (cons (implement-dispatch 0 .var0|3 (let () (let ((.loop|25|28|31 (unspecified))) (begin (set! .loop|25|28|31 (lambda (.y1|20|21|32 .results|20|24|32) (if (null? .y1|20|21|32) (reverse .results|20|24|32) (begin #t (.loop|25|28|31 (let ((.x|36|39 .y1|20|21|32)) (begin (.check! (pair? .x|36|39) 1 .x|36|39) (cdr:pair .x|36|39))) (cons (let ((.x|40|43 (let ((.x|44|47 .y1|20|21|32)) (begin (.check! (pair? .x|44|47) 0 .x|44|47) (car:pair .x|44|47))))) (begin (.check! (pair? .x|40|43) 0 .x|40|43) (car:pair .x|40|43))) .results|20|24|32)))))) (.loop|25|28|31 .other|3 '())))) (let () (let ((.loop|53|56|59 (unspecified))) (begin (set! .loop|53|56|59 (lambda (.y1|48|49|60 .results|48|52|60) (if (null? .y1|48|49|60) (reverse .results|48|52|60) (begin #t (.loop|53|56|59 (let ((.x|64|67 .y1|48|49|60)) (begin (.check! (pair? .x|64|67) 1 .x|64|67) (cdr:pair .x|64|67))) (cons (let ((.x|68|71 (let ((.x|72|75 .y1|48|49|60)) (begin (.check! (pair? .x|72|75) 0 .x|72|75) (car:pair .x|72|75))))) (begin (.check! (pair? .x|68|71) 0 .x|68|71) (car:pair .x|68|71))) .results|48|52|60)))))) (.loop|53|56|59 .fix|3 '())))) (let () (let ((.loop|81|84|87 (unspecified))) (begin (set! .loop|81|84|87 (lambda (.y1|76|77|88 .results|76|80|88) (if (null? .y1|76|77|88) (reverse .results|76|80|88) (begin #t (.loop|81|84|87 (let ((.x|92|95 .y1|76|77|88)) (begin (.check! (pair? .x|92|95) 1 .x|92|95) (cdr:pair .x|92|95))) (cons (let ((.x|96|99 (let ((.x|100|103 .y1|76|77|88)) (begin (.check! (pair? .x|100|103) 0 .x|100|103) (car:pair .x|100|103))))) (begin (.check! (pair? .x|96|99) 0 .x|96|99) (car:pair .x|96|99))) .results|76|80|88)))))) (.loop|81|84|87 .chr|3 '())))) (let () (let ((.loop|109|112|115 (unspecified))) (begin (set! .loop|109|112|115 (lambda (.y1|104|105|116 .results|104|108|116) (if (null? .y1|104|105|116) (reverse .results|104|108|116) (begin #t (.loop|109|112|115 (let ((.x|120|123 .y1|104|105|116)) (begin (.check! (pair? .x|120|123) 1 .x|120|123) (cdr:pair .x|120|123))) (cons (let ((.x|124|127 (let ((.x|128|131 .y1|104|105|116)) (begin (.check! (pair? .x|128|131) 0 .x|128|131) (car:pair .x|128|131))))) (begin (.check! (pair? .x|124|127) 0 .x|124|127) (car:pair .x|124|127))) .results|104|108|116)))))) (.loop|109|112|115 .sym|3 '()))))) '())))))) (.implement-clauses|2 .f|1 .var0|1 .default|1 .fix|1 .chr|1 .sym|1 .other|1 .constants|1))))) 'implement-clauses))
(let () (begin (set! implement-case-dispatch (lambda (.var0|1 .exprs|1) (let ((.implement-case-dispatch|2 0)) (begin (set! .implement-case-dispatch|2 (lambda (.var0|3 .exprs|3) (implement-intervals .var0|3 (let () (let ((.loop|10|14|17 (unspecified))) (begin (set! .loop|10|14|17 (lambda (.y1|4|6|18 .y1|4|5|18 .results|4|9|18) (if (let ((.temp|20|23 (null? .y1|4|6|18))) (if .temp|20|23 .temp|20|23 (null? .y1|4|5|18))) (reverse .results|4|9|18) (begin #t (.loop|10|14|17 (let ((.x|26|29 .y1|4|6|18)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))) (let ((.x|30|33 .y1|4|5|18)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))) (cons (let ((.n|34 (let ((.x|56|59 .y1|4|6|18)) (begin (.check! (pair? .x|56|59) 0 .x|56|59) (car:pair .x|56|59)))) (.code|34 (let ((.x|60|63 .y1|4|5|18)) (begin (.check! (pair? .x|60|63) 0 .x|60|63) (car:pair .x|60|63))))) (let* ((.t1|35|38 .n|34) (.t2|35|41 (let* ((.t1|45|48 (+ .n|34 1)) (.t2|45|51 (cons .code|34 '()))) (let () (cons .t1|45|48 .t2|45|51))))) (let () (cons .t1|35|38 .t2|35|41)))) .results|4|9|18)))))) (.loop|10|14|17 (iota (length .exprs|3)) .exprs|3 '()))))))) (.implement-case-dispatch|2 .var0|1 .exprs|1))))) 'implement-case-dispatch))
(let () (begin (set! implement-dispatch (lambda (.prior|1 .var0|1 .other|1 .fix|1 .chr|1 .sym|1) (let ((.implement-dispatch|2 0)) (begin (set! .implement-dispatch|2 (lambda (.prior|3 .var0|3 .other|3 .fix|3 .chr|3 .sym|3) (if (not (null? .other|3)) (implement-dispatch-other (.implement-dispatch|2 (+ .prior|3 (length .other|3)) .var0|3 .fix|3 .chr|3 .sym|3 '()) .prior|3 var .other|3) (if (not (null? .fix|3)) (make-conditional (make-call (make-variable name:fixnum?) (cons (make-variable .var0|3) '())) (implement-dispatch-fixnum .prior|3 .var0|3 .fix|3) (.implement-dispatch|2 (+ .prior|3 (length .fix|3)) .var0|3 '() .chr|3 .sym|3 .other|3)) (if (not (null? .chr|3)) (make-conditional (make-call (make-variable name:char?) (cons (make-variable .var0|3) '())) (implement-dispatch-char .prior|3 .var0|3 .chr|3) (.implement-dispatch|2 (+ .prior|3 (length .chr|3)) .var0|3 .fix|3 '() .sym|3 .other|3)) (if (not (null? .sym|3)) (make-conditional (make-call (make-variable name:symbol?) (cons (make-variable .var0|3) '())) (implement-dispatch-symbol .prior|3 .var0|3 .sym|3) (.implement-dispatch|2 (+ .prior|3 (length .sym|3)) .var0|3 .fix|3 .chr|3 '() .other|3)) (make-constant 0))))))) (.implement-dispatch|2 .prior|1 .var0|1 .other|1 .fix|1 .chr|1 .sym|1))))) 'implement-dispatch))
(let () (begin (set! implement-dispatch-fixnum (lambda (.prior|1 .var0|1 .lists|1) (let ((.implement-dispatch-fixnum|2 0)) (begin (set! .implement-dispatch-fixnum|2 (lambda (.prior|3 .var0|3 .lists|3) (let ((.complete-intervals|6 (unspecified)) (.extract-intervals|6 (unspecified)) (.calculate-intervals|6 (unspecified))) (begin (set! .complete-intervals|6 (lambda (.intervals|7) (if (null? .intervals|7) .intervals|7 (if (null? (let ((.x|10|13 .intervals|7)) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13)))) .intervals|7 (let* ((.i1|17 (let ((.x|80|83 .intervals|7)) (begin (.check! (pair? .x|80|83) 0 .x|80|83) (car:pair .x|80|83)))) (.i2|20 (let ((.x|72|75 (let ((.x|76|79 .intervals|7)) (begin (.check! (pair? .x|76|79) 1 .x|76|79) (cdr:pair .x|76|79))))) (begin (.check! (pair? .x|72|75) 0 .x|72|75) (car:pair .x|72|75)))) (.end1|23 (let ((.x|63|66 (let ((.x|67|70 .i1|17)) (begin (.check! (pair? .x|67|70) 1 .x|67|70) (cdr:pair .x|67|70))))) (begin (.check! (pair? .x|63|66) 0 .x|63|66) (car:pair .x|63|66)))) (.start2|26 (let ((.x|58|61 .i2|20)) (begin (.check! (pair? .x|58|61) 0 .x|58|61) (car:pair .x|58|61)))) (.intervals|29 (.complete-intervals|6 (let ((.x|54|57 .intervals|7)) (begin (.check! (pair? .x|54|57) 1 .x|54|57) (cdr:pair .x|54|57)))))) (let () (if (= .end1|23 .start2|26) (cons .i1|17 .intervals|29) (cons .i1|17 (cons (let* ((.t1|33|36 .end1|23) (.t2|33|39 (let* ((.t1|43|46 .start2|26) (.t2|43|49 (cons (make-constant 0) '()))) (let () (cons .t1|43|46 .t2|43|49))))) (let () (cons .t1|33|36 .t2|33|39))) .intervals|29))))))))) (set! .extract-intervals|6 (lambda (.n|84 .constants|84) (if (null? .constants|84) '() (let ((.k0|87 (let ((.x|136|139 .constants|84)) (begin (.check! (pair? .x|136|139) 0 .x|136|139) (car:pair .x|136|139))))) (let () (let ((.loop|88|91|94 (unspecified))) (begin (set! .loop|88|91|94 (lambda (.constants|95 .k1|95) (if (let ((.temp|97|100 (null? .constants|95))) (if .temp|97|100 .temp|97|100 (not (= .k1|95 (let ((.x|102|105 .constants|95)) (begin (.check! (pair? .x|102|105) 0 .x|102|105) (car:pair .x|102|105))))))) (cons (let* ((.t1|106|109 .k0|87) (.t2|106|112 (let* ((.t1|116|119 .k1|95) (.t2|116|122 (cons (make-constant .n|84) '()))) (let () (cons .t1|116|119 .t2|116|122))))) (let () (cons .t1|106|109 .t2|106|112))) (.extract-intervals|6 .n|84 .constants|95)) (begin #t (.loop|88|91|94 (let ((.x|128|131 .constants|95)) (begin (.check! (pair? .x|128|131) 1 .x|128|131) (cdr:pair .x|128|131))) (+ .k1|95 1)))))) (.loop|88|91|94 (let ((.x|132|135 .constants|84)) (begin (.check! (pair? .x|132|135) 1 .x|132|135) (cdr:pair .x|132|135))) (+ .k0|87 1))))))))) (set! .calculate-intervals|6 (lambda (.n|140 .lists|140) (let ((.loop|141 (unspecified))) (begin (set! .loop|141 (lambda (.n|142 .lists|142 .intervals|142) (if (null? .lists|142) (twobit-sort (lambda (.interval1|143 .interval2|143) (< (let ((.x|144|147 .interval1|143)) (begin (.check! (pair? .x|144|147) 0 .x|144|147) (car:pair .x|144|147))) (let ((.x|148|151 .interval2|143)) (begin (.check! (pair? .x|148|151) 0 .x|148|151) (car:pair .x|148|151))))) .intervals|142) (let ((.constants|154 (twobit-sort < (let ((.x|159|162 .lists|142)) (begin (.check! (pair? .x|159|162) 0 .x|159|162) (car:pair .x|159|162)))))) (.loop|141 (+ .n|142 1) (let ((.x|155|158 .lists|142)) (begin (.check! (pair? .x|155|158) 1 .x|155|158) (cdr:pair .x|155|158))) (append (.extract-intervals|6 .n|142 .constants|154) .intervals|142)))))) (.loop|141 .n|140 .lists|140 '()))))) (let* ((.intervals|163 (.complete-intervals|6 (.calculate-intervals|6 (+ .prior|3 1) .lists|3))) (.lo|166 (let ((.x|206|209 (let ((.x|210|213 .intervals|163)) (begin (.check! (pair? .x|210|213) 0 .x|210|213) (car:pair .x|210|213))))) (begin (.check! (pair? .x|206|209) 0 .x|206|209) (car:pair .x|206|209)))) (.hi|169 (let ((.x|198|201 (let ((.x|202|205 (reverse .intervals|163))) (begin (.check! (pair? .x|202|205) 0 .x|202|205) (car:pair .x|202|205))))) (begin (.check! (pair? .x|198|201) 0 .x|198|201) (car:pair .x|198|201)))) (.p|172 (length .intervals|163))) (let () (make-conditional (make-call (make-variable name:fx<) (let* ((.t1|176|179 (make-variable .var0|3)) (.t2|176|182 (cons (make-constant .lo|166) '()))) (let () (cons .t1|176|179 .t2|176|182)))) (make-constant 0) (make-conditional (make-call (make-variable name:fx<) (let* ((.t1|187|190 (make-variable .var0|3)) (.t2|187|193 (cons (make-constant (+ .hi|169 1)) '()))) (let () (cons .t1|187|190 .t2|187|193)))) (if (< (- .hi|169 .lo|166) (* 5 .p|172)) (implement-table-lookup .var0|3 (+ .prior|3 1) .lists|3 .lo|166 .hi|169) (implement-intervals .var0|3 .intervals|163)) (make-constant 0))))))))) (.implement-dispatch-fixnum|2 .prior|1 .var0|1 .lists|1))))) 'implement-dispatch-fixnum))
(let () (begin (set! implement-dispatch-char (lambda (.prior|1 .var0|1 .lists|1) (let ((.implement-dispatch-char|2 0)) (begin (set! .implement-dispatch-char|2 (lambda (.prior|3 .var0|3 .lists|3) (let* ((.lists|6 (let () (let ((.loop|67|70|73 (unspecified))) (begin (set! .loop|67|70|73 (lambda (.y1|62|63|74 .results|62|66|74) (if (null? .y1|62|63|74) (reverse .results|62|66|74) (begin #t (.loop|67|70|73 (let ((.x|78|81 .y1|62|63|74)) (begin (.check! (pair? .x|78|81) 1 .x|78|81) (cdr:pair .x|78|81))) (cons (let ((.constants|82 (let ((.x|107|110 .y1|62|63|74)) (begin (.check! (pair? .x|107|110) 0 .x|107|110) (car:pair .x|107|110))))) (let () (let ((.loop|88|91|94 (unspecified))) (begin (set! .loop|88|91|94 (lambda (.y1|83|84|95 .results|83|87|95) (if (null? .y1|83|84|95) (reverse .results|83|87|95) (begin #t (.loop|88|91|94 (let ((.x|99|102 .y1|83|84|95)) (begin (.check! (pair? .x|99|102) 1 .x|99|102) (cdr:pair .x|99|102))) (cons (compat:char->integer (let ((.x|103|106 .y1|83|84|95)) (begin (.check! (pair? .x|103|106) 0 .x|103|106) (car:pair .x|103|106)))) .results|83|87|95)))))) (.loop|88|91|94 .constants|82 '()))))) .results|62|66|74)))))) (.loop|67|70|73 .lists|3 '()))))) (.name:n|9 ((make-rename-procedure) 'n)) (.f|12 (let* ((.t1|21|24 .name:n|9) (.t2|21|27 (let* ((.t1|31|34 name:eq?) (.t2|31|37 (let* ((.t1|41|44 name:fx<) (.t2|41|47 (let* ((.t1|51|54 name:fx-) (.t2|51|57 (cons name:vector-ref '()))) (let () (cons .t1|51|54 .t2|51|57))))) (let () (cons .t1|41|44 .t2|41|47))))) (let () (cons .t1|31|34 .t2|31|37))))) (let () (cons .t1|21|24 .t2|21|27)))) (.l|15 (make-lambda (cons .name:n|9 '()) '() '() .f|12 '() '() #f (implement-dispatch-fixnum .prior|3 .name:n|9 .lists|6)))) (let () (make-call .l|15 (make-call (make-variable name:char->integer) (cons (make-variable .var0|3) '()))))))) (.implement-dispatch-char|2 .prior|1 .var0|1 .lists|1))))) 'implement-dispatch-char))
(let () (begin (set! implement-dispatch-symbol (lambda (.prior|1 .var0|1 .lists|1) (let ((.implement-dispatch-symbol|2 0)) (begin (set! .implement-dispatch-symbol|2 (lambda (.prior|3 .var0|3 .lists|3) (implement-dispatch-other (make-constant 0) .prior|3 .var0|3 .lists|3))) (.implement-dispatch-symbol|2 .prior|1 .var0|1 .lists|1))))) 'implement-dispatch-symbol))
(let () (begin (set! implement-dispatch-other (lambda (.default|1 .prior|1 .var0|1 .lists|1) (let ((.implement-dispatch-other|2 0)) (begin (set! .implement-dispatch-other|2 (lambda (.default|3 .prior|3 .var0|3 .lists|3) (if (null? .lists|3) .default|3 (let* ((.constants|6 (let ((.x|20|23 .lists|3)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23)))) (.lists|9 (let ((.x|16|19 .lists|3)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19)))) (.n|12 (+ .prior|3 1))) (let () (make-conditional (make-call-to-memv .var0|3 .constants|6) (make-constant .n|12) (.implement-dispatch-other|2 .default|3 .n|12 .var0|3 .lists|9))))))) (.implement-dispatch-other|2 .default|1 .prior|1 .var0|1 .lists|1))))) 'implement-dispatch-other))
(let () (begin (set! make-call-to-memv (lambda (.var0|1 .constants|1) (let ((.make-call-to-memv|2 0)) (begin (set! .make-call-to-memv|2 (lambda (.var0|3 .constants|3) (if (null? .constants|3) (make-constant #f) (if (null? (let ((.x|6|9 .constants|3)) (begin (.check! (pair? .x|6|9) 1 .x|6|9) (cdr:pair .x|6|9)))) (make-call-to-eqv .var0|3 (let ((.x|10|13 .constants|3)) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13)))) (make-conditional (make-call-to-eqv .var0|3 (let ((.x|15|18 .constants|3)) (begin (.check! (pair? .x|15|18) 0 .x|15|18) (car:pair .x|15|18)))) (make-constant #t) (.make-call-to-memv|2 .var0|3 (let ((.x|19|22 .constants|3)) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22))))))))) (.make-call-to-memv|2 .var0|1 .constants|1))))) 'make-call-to-memv))
(let () (begin (set! make-call-to-eqv (lambda (.var0|1 .constant|1) (let ((.make-call-to-eqv|2 0)) (begin (set! .make-call-to-eqv|2 (lambda (.var0|3 .constant|3) (make-call (make-variable (if (eq-is-ok? .constant|3) name:eq? name:eqv?)) (let* ((.t1|4|7 (make-variable .var0|3)) (.t2|4|10 (cons (make-constant .constant|3) '()))) (let () (cons .t1|4|7 .t2|4|10)))))) (.make-call-to-eqv|2 .var0|1 .constant|1))))) 'make-call-to-eqv))
(let () (begin (set! implement-table-lookup (lambda (.var0|1 .index|1 .lists|1 .lo|1 .hi|1) (let ((.implement-table-lookup|2 0)) (begin (set! .implement-table-lookup|2 (lambda (.var0|3 .index|3 .lists|3 .lo|3 .hi|3) (let ((.v|6 (make-vector (+ 1 (- .hi|3 .lo|3)) 0))) (begin (let () (let ((.loop|8|11|14 (unspecified))) (begin (set! .loop|8|11|14 (lambda (.index|15 .lists|15) (if (null? .lists|15) (if #f #f (unspecified)) (begin (begin #t (let () (let ((.loop|23|25|28 (unspecified))) (begin (set! .loop|23|25|28 (lambda (.y1|18|19|29) (if (null? .y1|18|19|29) (if #f #f (unspecified)) (begin (begin #t (let ((.k|33 (let ((.x|38|41 .y1|18|19|29)) (begin (.check! (pair? .x|38|41) 0 .x|38|41) (car:pair .x|38|41))))) (let ((.v|34|37 .v|6) (.i|34|37 (- .k|33 .lo|3)) (.x|34|37 .index|15)) (begin (.check! (fixnum? .i|34|37) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (vector? .v|34|37) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (<:fix:fix .i|34|37 (vector-length:vec .v|34|37)) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (>=:fix:fix .i|34|37 0) 41 .v|34|37 .i|34|37 .x|34|37) (vector-set!:trusted .v|34|37 .i|34|37 .x|34|37))))) (.loop|23|25|28 (let ((.x|42|45 .y1|18|19|29)) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45)))))))) (.loop|23|25|28 (let ((.x|46|49 .lists|15)) (begin (.check! (pair? .x|46|49) 0 .x|46|49) (car:pair .x|46|49)))))))) (.loop|8|11|14 (+ .index|15 1) (let ((.x|50|53 .lists|15)) (begin (.check! (pair? .x|50|53) 1 .x|50|53) (cdr:pair .x|50|53)))))))) (.loop|8|11|14 .index|3 .lists|3)))) (make-call (make-variable name:vector-ref) (let* ((.t1|54|57 (make-constant .v|6)) (.t2|54|60 (cons (make-call (make-variable name:fx-) (let* ((.t1|65|68 (make-variable .var0|3)) (.t2|65|71 (cons (make-constant .lo|3) '()))) (let () (cons .t1|65|68 .t2|65|71)))) '()))) (let () (cons .t1|54|57 .t2|54|60)))))))) (.implement-table-lookup|2 .var0|1 .index|1 .lists|1 .lo|1 .hi|1))))) 'implement-table-lookup))
(let () (begin (set! implement-intervals (lambda (.var0|1 .intervals|1) (let ((.implement-intervals|2 0)) (begin (set! .implement-intervals|2 (lambda (.var0|3 .intervals|3) (if (null? (let ((.x|4|7 .intervals|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7)))) (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|21|24 .intervals|3)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12))) (let ((.n|27 (quotient (length .intervals|3) 2))) (let () (let ((.loop|28|32|35 (unspecified))) (begin (set! .loop|28|32|35 (lambda (.n|36 .intervals1|36 .intervals2|36) (if (zero? .n|36) (let ((.intervals1|40 (reverse .intervals1|36)) (.m|40 (let ((.x|52|55 (let ((.x|56|59 .intervals2|36)) (begin (.check! (pair? .x|56|59) 0 .x|56|59) (car:pair .x|56|59))))) (begin (.check! (pair? .x|52|55) 0 .x|52|55) (car:pair .x|52|55))))) (make-conditional (make-call (make-variable name:fx<) (let* ((.t1|41|44 (make-variable .var0|3)) (.t2|41|47 (cons (make-constant .m|40) '()))) (let () (cons .t1|41|44 .t2|41|47)))) (.implement-intervals|2 .var0|3 .intervals1|40) (.implement-intervals|2 .var0|3 .intervals2|36))) (begin #t (.loop|28|32|35 (- .n|36 1) (cons (let ((.x|61|64 .intervals2|36)) (begin (.check! (pair? .x|61|64) 0 .x|61|64) (car:pair .x|61|64))) .intervals1|36) (let ((.x|65|68 .intervals2|36)) (begin (.check! (pair? .x|65|68) 1 .x|65|68) (cdr:pair .x|65|68)))))))) (.loop|28|32|35 .n|27 '() .intervals|3)))))))) (.implement-intervals|2 .var0|1 .intervals|1))))) 'implement-intervals))
(let () (begin (set! *memq-threshold* 20) '*memq-threshold*))
(let () (begin (set! *memv-threshold* 4) '*memv-threshold*))
(let () (begin (set! implement-clauses-by-sequential-search (lambda (.var0|1 .default|1 .clauses|1) (let ((.implement-clauses-by-sequential-search|2 0)) (begin (set! .implement-clauses-by-sequential-search|2 (lambda (.var0|3 .default|3 .clauses|3) (if (null? .clauses|3) .default|3 (let* ((.case1|6 (let ((.x|36|39 .clauses|3)) (begin (.check! (pair? .x|36|39) 0 .x|36|39) (car:pair .x|36|39)))) (.clauses|9 (let ((.x|32|35 .clauses|3)) (begin (.check! (pair? .x|32|35) 1 .x|32|35) (cdr:pair .x|32|35)))) (.constants1|12 (let ((.x|28|31 .case1|6)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31)))) (.code1|15 (let ((.x|20|23 (let ((.x|24|27 .case1|6)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27))))) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))))) (let () (make-conditional (make-call-to-memv .var0|3 .constants1|12) .code1|15 (.implement-clauses-by-sequential-search|2 .var0|3 .default|3 .clauses|9))))))) (.implement-clauses-by-sequential-search|2 .var0|1 .default|1 .clauses|1))))) 'implement-clauses-by-sequential-search))
(let () (begin (set! callgraphnode.name (lambda (.x|1) (let ((.callgraphnode.name|2 0)) (begin (set! .callgraphnode.name|2 (lambda (.x|3) (let ((.x|4|7 .x|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.callgraphnode.name|2 .x|1))))) 'callgraphnode.name))
(let () (begin (set! callgraphnode.code (lambda (.x|1) (let ((.callgraphnode.code|2 0)) (begin (set! .callgraphnode.code|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 .x|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.callgraphnode.code|2 .x|1))))) 'callgraphnode.code))
(let () (begin (set! callgraphnode.vars (lambda (.x|1) (let ((.callgraphnode.vars|2 0)) (begin (set! .callgraphnode.vars|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .x|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.callgraphnode.vars|2 .x|1))))) 'callgraphnode.vars))
(let () (begin (set! callgraphnode.tailcalls (lambda (.x|1) (let ((.callgraphnode.tailcalls|2 0)) (begin (set! .callgraphnode.tailcalls|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 .x|3)) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.callgraphnode.tailcalls|2 .x|1))))) 'callgraphnode.tailcalls))
(let () (begin (set! callgraphnode.nontailcalls (lambda (.x|1) (let ((.callgraphnode.nontailcalls|2 0)) (begin (set! .callgraphnode.nontailcalls|2 (lambda (.x|3) (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|21|24 .x|3)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.callgraphnode.nontailcalls|2 .x|1))))) 'callgraphnode.nontailcalls))
(let () (begin (set! callgraphnode.size (lambda (.x|1) (let ((.callgraphnode.size|2 0)) (begin (set! .callgraphnode.size|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|14|17 (let ((.x|18|21 (let ((.x|22|25 (let ((.x|26|29 .x|3)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21))))) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.callgraphnode.size|2 .x|1))))) 'callgraphnode.size))
(let () (begin (set! callgraphnode.info (lambda (.x|1) (let ((.callgraphnode.info|2 0)) (begin (set! .callgraphnode.info|2 (lambda (.x|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|18|21 (let ((.x|22|25 (let ((.x|26|29 (let ((.x|30|33 .x|3)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33))))) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.callgraphnode.info|2 .x|1))))) 'callgraphnode.info))
(let () (begin (set! callgraphnode.size! (lambda (.x|1 .v|1) (let ((.callgraphnode.size!|2 0)) (begin (set! .callgraphnode.size!|2 (lambda (.x|3 .v|3) (begin (set-car! (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|21|24 .x|3)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .v|3) #f))) (.callgraphnode.size!|2 .x|1 .v|1))))) 'callgraphnode.size!))
(let () (begin (set! callgraphnode.info! (lambda (.x|1 .v|1) (let ((.callgraphnode.info!|2 0)) (begin (set! .callgraphnode.info!|2 (lambda (.x|3 .v|3) (begin (set-car! (let ((.x|5|8 (let ((.x|9|12 (let ((.x|14|17 (let ((.x|18|21 (let ((.x|22|25 (let ((.x|26|29 .x|3)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21))))) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .v|3) #f))) (.callgraphnode.info!|2 .x|1 .v|1))))) 'callgraphnode.info!))
(let () (begin (set! callgraph (lambda (.exp|1) (let ((.callgraph|2 0)) (begin (set! .callgraph|2 (lambda (.exp|3) (let ((.adjoin|6 (unspecified))) (begin (set! .adjoin|6 (lambda (.x|7 .z|7) (if (memq .x|7 .z|7) .z|7 (cons .x|7 .z|7)))) (let* ((.result|8 '()) (.add-vertex!|9 (unspecified))) (begin (set! .add-vertex!|9 (lambda (.name|10 .l|10 .vars|10 .known|10) (let ((.tailcalls|13 '()) (.nontailcalls|13 '()) (.size|13 0)) (let ((.graph-lambda!|14 (unspecified)) (.graph!|14 (unspecified))) (begin (set! .graph-lambda!|14 (lambda (.l|15 .vars|15 .known|15 .tail?|15) (let* ((.defs|18 (lambda.defs .l|15)) (.newknown|21 (let () (let ((.loop|67|70|73 (unspecified))) (begin (set! .loop|67|70|73 (lambda (.y1|62|63|74 .results|62|66|74) (if (null? .y1|62|63|74) (reverse .results|62|66|74) (begin #t (.loop|67|70|73 (let ((.x|78|81 .y1|62|63|74)) (begin (.check! (pair? .x|78|81) 1 .x|78|81) (cdr:pair .x|78|81))) (cons (def.lhs (let ((.x|82|85 .y1|62|63|74)) (begin (.check! (pair? .x|82|85) 0 .x|82|85) (car:pair .x|82|85)))) .results|62|66|74)))))) (.loop|67|70|73 .defs|18 '()))))) (.vars|24 (append .newknown|21 (make-null-terminated (lambda.args .l|15)) .vars|15)) (.known|27 (append .newknown|21 .known|15))) (let () (begin (let ((.f|31|34|37 (lambda (.def|57) (begin (.add-vertex!|9 (def.lhs .def|57) (def.rhs .def|57) .vars|24 .known|27) (set! .size|13 (+ .size|13 (callgraphnode.size (let ((.x|58|61 .result|8)) (begin (.check! (pair? .x|58|61) 0 .x|58|61) (car:pair .x|58|61)))))))))) (let () (let ((.loop|39|41|44 (unspecified))) (begin (set! .loop|39|41|44 (lambda (.y1|31|32|45) (if (null? .y1|31|32|45) (if #f #f (unspecified)) (begin (begin #t (.f|31|34|37 (let ((.x|49|52 .y1|31|32|45)) (begin (.check! (pair? .x|49|52) 0 .x|49|52) (car:pair .x|49|52))))) (.loop|39|41|44 (let ((.x|53|56 .y1|31|32|45)) (begin (.check! (pair? .x|53|56) 1 .x|53|56) (cdr:pair .x|53|56)))))))) (.loop|39|41|44 .defs|18))))) (.graph!|14 (lambda.body .l|15) .vars|24 .known|27 .tail?|15)))))) (set! .graph!|14 (lambda (.exp|86 .vars|86 .known|86 .tail?|86) (begin (set! .size|13 (+ .size|13 1)) (let ((.temp|87|90 (let ((.x|159|162 .exp|86)) (begin (.check! (pair? .x|159|162) 0 .x|159|162) (car:pair .x|159|162))))) (if (memv .temp|87|90 '(quote)) #f (if (memv .temp|87|90 '(lambda)) (begin (.add-vertex!|9 #f .exp|86 .vars|86 .known|86) (set! .size|13 (+ .size|13 (callgraphnode.size (let ((.x|93|96 .result|8)) (begin (.check! (pair? .x|93|96) 0 .x|93|96) (car:pair .x|93|96))))))) (if (memv .temp|87|90 '(set!)) (.graph!|14 (assignment.rhs .exp|86) .vars|86 .known|86 #f) (if (memv .temp|87|90 '(if)) (begin (.graph!|14 (if.test .exp|86) .vars|86 .known|86 #f) (.graph!|14 (if.then .exp|86) .vars|86 .known|86 .tail?|86) (.graph!|14 (if.else .exp|86) .vars|86 .known|86 .tail?|86)) (if (memv .temp|87|90 '(begin)) (if (not (variable? .exp|86)) (let () (let ((.loop|100|102|105 (unspecified))) (begin (set! .loop|100|102|105 (lambda (.exprs|106) (if (null? (let ((.x|108|111 .exprs|106)) (begin (.check! (pair? .x|108|111) 1 .x|108|111) (cdr:pair .x|108|111)))) (.graph!|14 (let ((.x|112|115 .exprs|106)) (begin (.check! (pair? .x|112|115) 0 .x|112|115) (car:pair .x|112|115))) .vars|86 .known|86 .tail?|86) (begin (begin #t (.graph!|14 (let ((.x|117|120 .exprs|106)) (begin (.check! (pair? .x|117|120) 0 .x|117|120) (car:pair .x|117|120))) .vars|86 .known|86 #f)) (.loop|100|102|105 (let ((.x|121|124 .exprs|106)) (begin (.check! (pair? .x|121|124) 1 .x|121|124) (cdr:pair .x|121|124)))))))) (.loop|100|102|105 (begin.exprs .exp|86))))) (unspecified)) (let ((.proc|128 (call.proc .exp|86))) (begin (if (variable? .proc|128) (let ((.name|132 (variable.name .proc|128))) (if (memq .name|132 .known|86) (if .tail?|86 (set! .tailcalls|13 (.adjoin|6 .name|132 .tailcalls|13)) (set! .nontailcalls|13 (.adjoin|6 .name|132 .nontailcalls|13))) (unspecified))) (if (lambda? .proc|128) (.graph-lambda!|14 .proc|128 .vars|86 .known|86 .tail?|86) (.graph!|14 .proc|128 .vars|86 .known|86 #f))) (let () (let ((.loop|140|142|145 (unspecified))) (begin (set! .loop|140|142|145 (lambda (.y1|135|136|146) (if (null? .y1|135|136|146) (if #f #f (unspecified)) (begin (begin #t (let ((.exp|150 (let ((.x|151|154 .y1|135|136|146)) (begin (.check! (pair? .x|151|154) 0 .x|151|154) (car:pair .x|151|154))))) (.graph!|14 .exp|150 .vars|86 .known|86 #f))) (.loop|140|142|145 (let ((.x|155|158 .y1|135|136|146)) (begin (.check! (pair? .x|155|158) 1 .x|155|158) (cdr:pair .x|155|158)))))))) (.loop|140|142|145 (call.args .exp|86)))))))))))))))) (.graph-lambda!|14 .l|10 .vars|10 .known|10 #t) (set! .result|8 (cons (let* ((.t1|163|166 .name|10) (.t2|163|169 (let* ((.t1|173|176 .l|10) (.t2|173|179 (let* ((.t1|183|186 .vars|10) (.t2|183|189 (let* ((.t1|193|196 .tailcalls|13) (.t2|193|199 (let* ((.t1|203|206 .nontailcalls|13) (.t2|203|209 (let* ((.t1|213|216 .size|13) (.t2|213|219 (cons #f '()))) (let () (cons .t1|213|216 .t2|213|219))))) (let () (cons .t1|203|206 .t2|203|209))))) (let () (cons .t1|193|196 .t2|193|199))))) (let () (cons .t1|183|186 .t2|183|189))))) (let () (cons .t1|173|176 .t2|173|179))))) (let () (cons .t1|163|166 .t2|163|169))) .result|8))))))) (.add-vertex!|9 #t (make-lambda '() '() '() '() '() '() '() .exp|3) '() '()) .result|8)))))) (.callgraph|2 .exp|1))))) 'callgraph))
(let () (begin (set! view-callgraph (lambda (.g|1) (let ((.view-callgraph|2 0)) (begin (set! .view-callgraph|2 (lambda (.g|3) (let () (let ((.loop|9|11|14 (unspecified))) (begin (set! .loop|9|11|14 (lambda (.y1|4|5|15) (if (null? .y1|4|5|15) (if #f #f (unspecified)) (begin (begin #t (let ((.entry|19 (let ((.x|26|29 .y1|4|5|15)) (begin (.check! (pair? .x|26|29) 0 .x|26|29) (car:pair .x|26|29))))) (let ((.name|22 (callgraphnode.name .entry|19)) (.exp|22 (callgraphnode.code .entry|19)) (.vars|22 (callgraphnode.vars .entry|19)) (.tail|22 (callgraphnode.tailcalls .entry|19)) (.nt|22 (callgraphnode.nontailcalls .entry|19)) (.size|22 (callgraphnode.size .entry|19))) (begin (if (symbol? .name|22) (write .name|22) (if .name|22 (display "TOP LEVEL EXPRESSION") (display "ESCAPING LAMBDA EXPRESSION"))) (display ":") (newline) (display "Size: ") (write .size|22) (newline) (display "Tail calls:     ") (write .tail|22) (newline) (display "Non-tail calls: ") (write .nt|22) (newline) (newline))))) (.loop|9|11|14 (let ((.x|30|33 .y1|4|5|15)) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33)))))))) (.loop|9|11|14 .g|3)))))) (.view-callgraph|2 .g|1))))) 'view-callgraph))
(let () (begin (set! *tail-threshold* 10) '*tail-threshold*))
(let () (begin (set! *nontail-threshold* 20) '*nontail-threshold*))
(let () (begin (set! *multiplier* 300) '*multiplier*))
(let () (begin (set! inline-using-callgraph! (lambda (.g|1) (let ((.inline-using-callgraph!|2 0)) (begin (set! .inline-using-callgraph!|2 (lambda (.g|3) (let ((.known|6 (make-hashtable)) (.category2|6 '()) (.category3|6 '())) (begin (let () (let ((.loop|12|14|17 (unspecified))) (begin (set! .loop|12|14|17 (lambda (.y1|7|8|18) (if (null? .y1|7|8|18) (if #f #f (unspecified)) (begin (begin #t (let ((.node|22 (let ((.x|28|31 .y1|7|8|18)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31))))) (let ((.name|25 (callgraphnode.name .node|22)) (.tcalls|25 (callgraphnode.tailcalls .node|22)) (.ncalls|25 (callgraphnode.nontailcalls .node|22))) (begin (if (symbol? .name|25) (hashtable-put! .known|6 .name|25 .node|22) (unspecified)) (if (if (null? .tcalls|25) (null? .ncalls|25) #f) (if (< (callgraphnode.size .node|22) *nontail-threshold*) (callgraphnode.info! .node|22 #t) (unspecified)) (if (symbol? .name|25) (set! .category2|6 (cons .node|22 .category2|6)) (set! .category3|6 (cons .node|22 .category3|6)))))))) (.loop|12|14|17 (let ((.x|32|35 .y1|7|8|18)) (begin (.check! (pair? .x|32|35) 1 .x|32|35) (cdr:pair .x|32|35)))))))) (.loop|12|14|17 .g|3)))) (set! .category2|6 (twobit-sort (lambda (.x|36 .y|36) (< (callgraphnode.size .x|36) (callgraphnode.size .y|36))) .category2|6)) (let () (let ((.loop|42|44|47 (unspecified))) (begin (set! .loop|42|44|47 (lambda (.y1|37|38|48) (if (null? .y1|37|38|48) (if #f #f (unspecified)) (begin (begin #t (let ((.node|52 (let ((.x|53|56 .y1|37|38|48)) (begin (.check! (pair? .x|53|56) 0 .x|53|56) (car:pair .x|53|56))))) (inline-node! .node|52 .known|6))) (.loop|42|44|47 (let ((.x|57|60 .y1|37|38|48)) (begin (.check! (pair? .x|57|60) 1 .x|57|60) (cdr:pair .x|57|60)))))))) (.loop|42|44|47 .category2|6)))) (let () (let ((.loop|66|68|71 (unspecified))) (begin (set! .loop|66|68|71 (lambda (.y1|61|62|72) (if (null? .y1|61|62|72) (if #f #f (unspecified)) (begin (begin #t (let ((.node|76 (let ((.x|77|80 .y1|61|62|72)) (begin (.check! (pair? .x|77|80) 0 .x|77|80) (car:pair .x|77|80))))) (inline-node! .node|76 .known|6))) (.loop|66|68|71 (let ((.x|81|84 .y1|61|62|72)) (begin (.check! (pair? .x|81|84) 1 .x|81|84) (cdr:pair .x|81|84)))))))) (.loop|66|68|71 .category3|6)))) (hashtable-for-each (lambda (.name|85 .node|85) (callgraphnode.info! .node|85 #f)) .known|6))))) (.inline-using-callgraph!|2 .g|1))))) 'inline-using-callgraph!))
(let () (begin (set! inline-node! (lambda (.node|1 .known|1) (let ((.inline-node!|2 0)) (begin (set! .inline-node!|2 (lambda (.node|3 .known|3) (let* ((.debugging?|6 #f) (.name|9 (callgraphnode.name .node|3)) (.exp|12 (callgraphnode.code .node|3)) (.size0|15 (callgraphnode.size .node|3)) (.budget|18 (quotient (* (- *multiplier* 100) .size0|15) 100)) (.tail-threshold|21 *tail-threshold*) (.nontail-threshold|24 *nontail-threshold*)) (let () (let ((.inline|28 (unspecified))) (begin (set! .inline|28 (lambda (.exp|29 .tail?|29 .budget|29) (if (> .budget|29 0) (let ((.temp|31|34 (let ((.x|122|125 .exp|29)) (begin (.check! (pair? .x|122|125) 0 .x|122|125) (car:pair .x|122|125))))) (if (memv .temp|31|34 ''lambda) .budget|29 (if (memv .temp|31|34 '(set!)) (.inline|28 (assignment.rhs .exp|29) #f .budget|29) (if (memv .temp|31|34 '(if)) (let* ((.budget|40 (.inline|28 (if.test .exp|29) #f .budget|29)) (.budget|43 (.inline|28 (if.then .exp|29) .tail?|29 .budget|40)) (.budget|46 (.inline|28 (if.else .exp|29) .tail?|29 .budget|43))) (let () .budget|46)) (if (memv .temp|31|34 '(begin)) (if (variable? .exp|29) .budget|29 (let () (let ((.loop|51|54|57 (unspecified))) (begin (set! .loop|51|54|57 (lambda (.exprs|58 .budget|58) (if (null? (let ((.x|60|63 .exprs|58)) (begin (.check! (pair? .x|60|63) 1 .x|60|63) (cdr:pair .x|60|63)))) (.inline|28 (let ((.x|64|67 .exprs|58)) (begin (.check! (pair? .x|64|67) 0 .x|64|67) (car:pair .x|64|67))) .tail?|29 .budget|58) (begin #t (.loop|51|54|57 (let ((.x|69|72 .exprs|58)) (begin (.check! (pair? .x|69|72) 1 .x|69|72) (cdr:pair .x|69|72))) (.inline|28 (let ((.x|73|76 .exprs|58)) (begin (.check! (pair? .x|73|76) 0 .x|73|76) (car:pair .x|73|76))) #f .budget|58)))))) (.loop|51|54|57 (begin.exprs .exp|29) .budget|29))))) (let* ((.budget|80 (let () (let ((.loop|104|107|110 (unspecified))) (begin (set! .loop|104|107|110 (lambda (.exprs|111 .budget|111) (if (null? .exprs|111) .budget|111 (begin #t (.loop|104|107|110 (let ((.x|114|117 .exprs|111)) (begin (.check! (pair? .x|114|117) 1 .x|114|117) (cdr:pair .x|114|117))) (.inline|28 (let ((.x|118|121 .exprs|111)) (begin (.check! (pair? .x|118|121) 0 .x|118|121) (car:pair .x|118|121))) #f .budget|111)))))) (.loop|104|107|110 (call.args .exp|29) .budget|29))))) (.proc|83 (call.proc .exp|29))) (if (variable? .proc|83) (let* ((.procname|87 (variable.name .proc|83)) (.procnode|90 (hashtable-get .known|3 .procname|87))) (let () (if .procnode|90 (let ((.size|96 (callgraphnode.size .procnode|90)) (.info|96 (callgraphnode.info .procnode|90))) (if (if .info|96 (if (<= .size|96 .budget|80) (<= .size|96 (if .tail?|29 .tail-threshold|21 .nontail-threshold|24)) #f) #f) (begin (if .debugging?|6 (begin (display "    Inlining ") (write (variable.name .proc|83)) (newline)) (unspecified)) (call.proc-set! .exp|29 (copy-exp (callgraphnode.code .procnode|90))) (callgraphnode.size! .node|3 (+ (callgraphnode.size .node|3) .size|96)) (- .budget|80 .size|96)) (begin (if (if #f .debugging?|6 #f) (begin (display "    Declining to inline ") (write (variable.name .proc|83)) (newline)) (unspecified)) .budget|80))) .budget|80))) (if (lambda? .proc|83) (.inline|28 (lambda.body .proc|83) .tail?|29 .budget|80) (.inline|28 .proc|83 #f .budget|80))))))))) -1))) (if (if #f .debugging?|6 #f) (begin (display "Processing ") (write .name|9) (newline)) (unspecified)) (let ((.budget|130 (.inline|28 (if (lambda? .exp|12) (lambda.body .exp|12) .exp|12) #t .budget|18))) (begin (if (if (< .budget|130 0) .debugging?|6 #f) (begin (display "Ran out of inlining budget for ") (write (callgraphnode.name .node|3)) (newline)) (unspecified)) (if (<= (callgraphnode.size .node|3) .nontail-threshold|24) (callgraphnode.info! .node|3 #t) (unspecified)) #f)))))))) (.inline-node!|2 .node|1 .known|1))))) 'inline-node!))
(let () (begin (set! test-inlining (lambda (.test0|1) (let ((.test-inlining|2 0)) (begin (set! .test-inlining|2 (lambda (.test0|3) (let ((.g0|4 (unspecified)) (.exp0|4 (unspecified))) (begin (set! .g0|4 (begin (display "Computing call graph...") (newline) (callgraph .exp0|4))) (set! .exp0|4 (begin (display "Compiling...") (newline) (pass2 (pass1 .test0|3)))) (display "Inlining...") (newline) (inline-using-callgraph! .g0|4) (pretty-print (make-readable (copy-exp .exp0|4))))))) (.test-inlining|2 .test0|1))))) 'test-inlining))
(let () (begin (set! *constant-propagation-limit* 5) '*constant-propagation-limit*))
(let () (begin (set! constant-propagation (lambda (.exp|1) (let ((.constant-propagation|2 0)) (begin (set! .constant-propagation|2 (lambda (.exp|3) (let ((.constant-propagation|4 (unspecified))) (begin (set! .constant-propagation|4 (lambda (.exp|5 .i|5) (if (< .i|5 *constant-propagation-limit*) (let* ((.g|8 (callgraph .exp|5)) (.l|11 (callgraphnode.code (let ((.x|21|24 .g|8)) (begin (.check! (pair? .x|21|24) 0 .x|21|24) (car:pair .x|21|24))))) (.variables|14 (constant-propagation-using-callgraph .g|8)) (.changed?|17 (constant-folding! .l|11 .variables|14))) (let () (if .changed?|17 (.constant-propagation|4 (lambda.body .l|11) (+ .i|5 1)) (lambda.body .l|11)))) (unspecified)))) (.constant-propagation|4 .exp|3 0))))) (.constant-propagation|2 .exp|1))))) 'constant-propagation))
(let () (begin (set! constant-propagation-using-callgraph (lambda (.g|1) (let ((.constant-propagation-using-callgraph|2 0)) (begin (set! .constant-propagation-using-callgraph|2 (lambda (.g|3) (let ((.debugging?|6 #f) (.folding?|6 (integrate-usual-procedures)) (.known|6 (make-hashtable)) (.variables|6 (make-hashtable)) (.counter|6 0)) (let ((.collect!|7 (unspecified)) (.combine-symbolic|7 (unspecified)) (.aeval1-error|7 (unspecified)) (.aeval1|7 (unspecified)) (.aeval|7 (unspecified)) (.join|7 (unspecified))) (begin (set! .collect!|7 (lambda (.exp|8) (let ((.temp|9|12 (let ((.x|148|151 .exp|8)) (begin (.check! (pair? .x|148|151) 0 .x|148|151) (car:pair .x|148|151))))) (if (memv .temp|9|12 '(quote)) (cons .exp|8 '()) (if (memv .temp|9|12 '(lambda)) #t (if (memv .temp|9|12 '(set!)) (begin (.collect!|7 (assignment.rhs .exp|8)) '()) (if (memv .temp|9|12 '(begin)) (if (variable? .exp|8) (cons .exp|8 '()) (let () (let ((.loop|19|21|24 (unspecified))) (begin (set! .loop|19|21|24 (lambda (.exprs|25) (if (null? (let ((.x|27|30 .exprs|25)) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30)))) (.collect!|7 (let ((.x|31|34 .exprs|25)) (begin (.check! (pair? .x|31|34) 0 .x|31|34) (car:pair .x|31|34)))) (begin (begin #t (.collect!|7 (let ((.x|36|39 .exprs|25)) (begin (.check! (pair? .x|36|39) 0 .x|36|39) (car:pair .x|36|39))))) (.loop|19|21|24 (let ((.x|40|43 .exprs|25)) (begin (.check! (pair? .x|40|43) 1 .x|40|43) (cdr:pair .x|40|43)))))))) (.loop|19|21|24 (begin.exprs .exp|8)))))) (if (memv .temp|9|12 '(if)) (begin (.collect!|7 (if.test .exp|8)) (.collect!|7 (if.then .exp|8)) (.collect!|7 (if.else .exp|8)) #t) (let () (let ((.loop|46|49|52 (unspecified))) (begin (set! .loop|46|49|52 (lambda (.exprs|53 .reps|53) (if (null? .exprs|53) (let* ((.proc|57 (call.proc .exp|8)) (.put-args!|59 (unspecified))) (begin (set! .put-args!|59 (lambda (.args|60 .reps|60) (if (pair? .args|60) (let ((.v|64 (let ((.x|73|76 .args|60)) (begin (.check! (pair? .x|73|76) 0 .x|73|76) (car:pair .x|73|76)))) (.rep|64 (let ((.x|77|80 .reps|60)) (begin (.check! (pair? .x|77|80) 0 .x|77|80) (car:pair .x|77|80))))) (begin (hashtable-put! .variables|6 .v|64 .rep|64) (.put-args!|59 (let ((.x|65|68 .args|60)) (begin (.check! (pair? .x|65|68) 1 .x|65|68) (cdr:pair .x|65|68))) (let ((.x|69|72 .reps|60)) (begin (.check! (pair? .x|69|72) 1 .x|69|72) (cdr:pair .x|69|72)))))) (if (symbol? .args|60) (hashtable-put! .variables|6 .args|60 #t) #f)))) (if (variable? .proc|57) (let* ((.procname|85 (variable.name .proc|57)) (.procnode|88 (hashtable-get .known|6 .procname|85)) (.entry|91 (if .folding?|6 (constant-folding-entry .procname|85) #f))) (let () (if .procnode|88 (begin (let () (let ((.loop|102|105|108 (unspecified))) (begin (set! .loop|102|105|108 (lambda (.y1|96|98|109 .y1|96|97|109) (if (let ((.temp|111|114 (null? .y1|96|98|109))) (if .temp|111|114 .temp|111|114 (null? .y1|96|97|109))) (if #f #f (unspecified)) (begin (begin #t (let ((.v|117 (let ((.x|118|121 .y1|96|98|109)) (begin (.check! (pair? .x|118|121) 0 .x|118|121) (car:pair .x|118|121)))) (.rep|117 (let ((.x|122|125 .y1|96|97|109)) (begin (.check! (pair? .x|122|125) 0 .x|122|125) (car:pair .x|122|125))))) (hashtable-put! .variables|6 .v|117 (.combine-symbolic|7 .rep|117 (hashtable-get .variables|6 .v|117))))) (.loop|102|105|108 (let ((.x|126|129 .y1|96|98|109)) (begin (.check! (pair? .x|126|129) 1 .x|126|129) (cdr:pair .x|126|129))) (let ((.x|130|133 .y1|96|97|109)) (begin (.check! (pair? .x|130|133) 1 .x|130|133) (cdr:pair .x|130|133)))))))) (.loop|102|105|108 (lambda.args (callgraphnode.code .procnode|88)) .reps|53)))) (cons (make-variable .procname|85) '())) (if .entry|91 #t #t)))) (if (lambda? .proc|57) (begin (.put-args!|59 (lambda.args .proc|57) .reps|53) (.collect!|7 (lambda.body .proc|57))) (begin (.collect!|7 .proc|57) #t))))) (begin #t (.loop|46|49|52 (let ((.x|140|143 .exprs|53)) (begin (.check! (pair? .x|140|143) 1 .x|140|143) (cdr:pair .x|140|143))) (cons (.collect!|7 (let ((.x|144|147 .exprs|53)) (begin (.check! (pair? .x|144|147) 0 .x|144|147) (car:pair .x|144|147)))) .reps|53)))))) (.loop|46|49|52 (reverse (call.args .exp|8)) '())))))))))))) (set! .combine-symbolic|7 (lambda (.rep1|152 .rep2|152) (if (eq? .rep1|152 #t) #t (if (eq? .rep2|152 #t) #t (append .rep1|152 .rep2|152))))) (set! .aeval1-error|7 (lambda () (error "Compiler bug: constant propagation (aeval1)"))) (set! .aeval1|7 (lambda (.exp|157 .env|157) (let ((.temp|158|161 (let ((.x|238|241 .exp|157)) (begin (.check! (pair? .x|238|241) 0 .x|238|241) (car:pair .x|238|241))))) (if (memv .temp|158|161 '(quote)) .exp|157 (if (memv .temp|158|161 '(lambda)) #t (if (memv .temp|158|161 '(set!)) #f (if (memv .temp|158|161 '(begin)) (if (variable? .exp|157) (let* ((.name|168 (variable.name .exp|157)) (.i|171 (hashtable-get .variables|6 .name|168))) (let () (if .i|171 (let ((.v|175|178 .env|157) (.i|175|178 .i|171)) (begin (.check! (fixnum? .i|175|178) 40 .v|175|178 .i|175|178) (.check! (vector? .v|175|178) 40 .v|175|178 .i|175|178) (.check! (<:fix:fix .i|175|178 (vector-length:vec .v|175|178)) 40 .v|175|178 .i|175|178) (.check! (>=:fix:fix .i|175|178 0) 40 .v|175|178 .i|175|178) (vector-ref:trusted .v|175|178 .i|175|178))) #t))) (.aeval1-error|7)) (if (memv .temp|158|161 '(if)) (let* ((.val0|182 (.aeval1|7 (if.test .exp|157) .env|157)) (.val1|185 (.aeval1|7 (if.then .exp|157) .env|157)) (.val2|188 (.aeval1|7 (if.else .exp|157) .env|157))) (let () (if (eq? .val0|182 #t) (.join|7 .val1|185 .val2|188) (if (pair? .val0|182) (if (constant.value .val0|182) .val1|185 .val2|188) #f)))) (let () (let ((.loop|196|199|202 (unspecified))) (begin (set! .loop|196|199|202 (lambda (.exprs|203 .vals|203) (if (null? .exprs|203) (let ((.proc|207 (call.proc .exp|157))) (if (variable? .proc|207) (let* ((.procname|211 (variable.name .proc|207)) (.procnode|214 (hashtable-get .known|6 .procname|211)) (.entry|217 (if .folding?|6 (constant-folding-entry .procname|211) #f))) (let () (if .procnode|214 (let ((.v|222|225 .env|157) (.i|222|225 (hashtable-get .variables|6 .procname|211))) (begin (.check! (fixnum? .i|222|225) 40 .v|222|225 .i|222|225) (.check! (vector? .v|222|225) 40 .v|222|225 .i|222|225) (.check! (<:fix:fix .i|222|225 (vector-length:vec .v|222|225)) 40 .v|222|225 .i|222|225) (.check! (>=:fix:fix .i|222|225 0) 40 .v|222|225 .i|222|225) (vector-ref:trusted .v|222|225 .i|222|225))) (if .entry|217 #t (.aeval1-error|7))))) (.aeval1-error|7))) (begin #t (.loop|196|199|202 (let ((.x|230|233 .exprs|203)) (begin (.check! (pair? .x|230|233) 1 .x|230|233) (cdr:pair .x|230|233))) (cons (.aeval1|7 (let ((.x|234|237 .exprs|203)) (begin (.check! (pair? .x|234|237) 0 .x|234|237) (car:pair .x|234|237))) .env|157) .vals|203)))))) (.loop|196|199|202 (reverse (call.args .exp|157)) '())))))))))))) (set! .aeval|7 (lambda (.rep|242 .env|242) (if (eq? .rep|242 #t) #t (if (null? .rep|242) #f (if (null? (let ((.x|246|249 .rep|242)) (begin (.check! (pair? .x|246|249) 1 .x|246|249) (cdr:pair .x|246|249)))) (.aeval1|7 (let ((.x|250|253 .rep|242)) (begin (.check! (pair? .x|250|253) 0 .x|250|253) (car:pair .x|250|253))) .env|242) (.join|7 (.aeval1|7 (let ((.x|255|258 .rep|242)) (begin (.check! (pair? .x|255|258) 0 .x|255|258) (car:pair .x|255|258))) .env|242) (.aeval|7 (let ((.x|259|262 .rep|242)) (begin (.check! (pair? .x|259|262) 1 .x|259|262) (cdr:pair .x|259|262))) .env|242))))))) (set! .join|7 (lambda (.x|263 .y|263) (if (boolean? .x|263) (if .x|263 #t .y|263) (if (boolean? .y|263) (.join|7 .y|263 .x|263) (if (equal? .x|263 .y|263) .x|263 #t))))) (let () (let ((.loop|273|275|278 (unspecified))) (begin (set! .loop|273|275|278 (lambda (.y1|268|269|279) (if (null? .y1|268|269|279) (if #f #f (unspecified)) (begin (begin #t (let* ((.node|283 (let ((.x|323|326 .y1|268|269|279)) (begin (.check! (pair? .x|323|326) 0 .x|323|326) (car:pair .x|323|326)))) (.name|286 (callgraphnode.name .node|283)) (.code|289 (callgraphnode.code .node|283)) (.known?|292 (symbol? .name|286)) (.rep|295 (if .known?|292 '() #t))) (let () (begin (if .known?|292 (hashtable-put! .known|6 .name|286 .node|283) (unspecified)) (if (lambda? .code|289) (let () (let ((.loop|304|306|309 (unspecified))) (begin (set! .loop|304|306|309 (lambda (.y1|299|300|310) (if (null? .y1|299|300|310) (if #f #f (unspecified)) (begin (begin #t (let ((.var|314 (let ((.x|315|318 .y1|299|300|310)) (begin (.check! (pair? .x|315|318) 0 .x|315|318) (car:pair .x|315|318))))) (hashtable-put! .variables|6 .var|314 .rep|295))) (.loop|304|306|309 (let ((.x|319|322 .y1|299|300|310)) (begin (.check! (pair? .x|319|322) 1 .x|319|322) (cdr:pair .x|319|322)))))))) (.loop|304|306|309 (make-null-terminated (lambda.args .code|289)))))) (unspecified)))))) (.loop|273|275|278 (let ((.x|327|330 .y1|268|269|279)) (begin (.check! (pair? .x|327|330) 1 .x|327|330) (cdr:pair .x|327|330)))))))) (.loop|273|275|278 .g|3)))) (let () (let ((.loop|336|338|341 (unspecified))) (begin (set! .loop|336|338|341 (lambda (.y1|331|332|342) (if (null? .y1|331|332|342) (if #f #f (unspecified)) (begin (begin #t (let ((.node|346 (let ((.x|352|355 .y1|331|332|342)) (begin (.check! (pair? .x|352|355) 0 .x|352|355) (car:pair .x|352|355))))) (let ((.name|349 (callgraphnode.name .node|346)) (.code|349 (callgraphnode.code .node|346))) (if (symbol? .name|349) (hashtable-put! .variables|6 .name|349 (.collect!|7 (lambda.body .code|349))) (.collect!|7 (lambda.body .code|349)))))) (.loop|336|338|341 (let ((.x|356|359 .y1|331|332|342)) (begin (.check! (pair? .x|356|359) 1 .x|356|359) (cdr:pair .x|356|359)))))))) (.loop|336|338|341 .g|3)))) (if (if #f .debugging?|6 #f) (begin (hashtable-for-each (lambda (.v|362 .rep|362) (begin (write .v|362) (display ": ") (write .rep|362) (newline))) .variables|6) (display "----------------------------------------") (newline)) (unspecified)) (let* ((.n|365 (hashtable-size .variables|6)) (.vars|368 (hashtable-map (lambda (.v|482 .rep|482) .v|482) .variables|6)) (.reps|371 (let () (let ((.loop|462|465|468 (unspecified))) (begin (set! .loop|462|465|468 (lambda (.y1|457|458|469 .results|457|461|469) (if (null? .y1|457|458|469) (reverse .results|457|461|469) (begin #t (.loop|462|465|468 (let ((.x|473|476 .y1|457|458|469)) (begin (.check! (pair? .x|473|476) 1 .x|473|476) (cdr:pair .x|473|476))) (cons (let ((.v|477 (let ((.x|478|481 .y1|457|458|469)) (begin (.check! (pair? .x|478|481) 0 .x|478|481) (car:pair .x|478|481))))) (hashtable-get .variables|6 .v|477)) .results|457|461|469)))))) (.loop|462|465|468 .vars|368 '()))))) (.init|374 (make-vector .n|365 #f)) (.next|377 (make-vector .n|365 '()))) (let () (begin (let () (let ((.loop|382|386|389 (unspecified))) (begin (set! .loop|382|386|389 (lambda (.i|390 .vars|390 .reps|390) (if (= .i|390 .n|365) (if #f #f (unspecified)) (begin (begin #t (hashtable-put! .variables|6 (let ((.x|393|396 .vars|390)) (begin (.check! (pair? .x|393|396) 0 .x|393|396) (car:pair .x|393|396))) .i|390) (let ((.v|397|400 .next|377) (.i|397|400 .i|390) (.x|397|400 (let ((.rep|403 (let ((.x|405|408 .reps|390)) (begin (.check! (pair? .x|405|408) 0 .x|405|408) (car:pair .x|405|408))))) (lambda (.env|404) (.aeval|7 .rep|403 .env|404))))) (begin (.check! (fixnum? .i|397|400) 41 .v|397|400 .i|397|400 .x|397|400) (.check! (vector? .v|397|400) 41 .v|397|400 .i|397|400 .x|397|400) (.check! (<:fix:fix .i|397|400 (vector-length:vec .v|397|400)) 41 .v|397|400 .i|397|400 .x|397|400) (.check! (>=:fix:fix .i|397|400 0) 41 .v|397|400 .i|397|400 .x|397|400) (vector-set!:trusted .v|397|400 .i|397|400 .x|397|400)))) (.loop|382|386|389 (+ .i|390 1) (let ((.x|409|412 .vars|390)) (begin (.check! (pair? .x|409|412) 1 .x|409|412) (cdr:pair .x|409|412))) (let ((.x|413|416 .reps|390)) (begin (.check! (pair? .x|413|416) 1 .x|413|416) (cdr:pair .x|413|416)))))))) (.loop|382|386|389 0 .vars|368 .reps|371)))) (compute-fixedpoint .init|374 .next|377 equal?) (let () (let ((.loop|422|424|427 (unspecified))) (begin (set! .loop|422|424|427 (lambda (.y1|417|418|428) (if (null? .y1|417|418|428) (if #f #f (unspecified)) (begin (begin #t (let* ((.v|432 (let ((.x|448|451 .y1|417|418|428)) (begin (.check! (pair? .x|448|451) 0 .x|448|451) (car:pair .x|448|451)))) (.i|435 (hashtable-get .variables|6 .v|432)) (.aval|438 (let ((.v|444|447 .init|374) (.i|444|447 .i|435)) (begin (.check! (fixnum? .i|444|447) 40 .v|444|447 .i|444|447) (.check! (vector? .v|444|447) 40 .v|444|447 .i|444|447) (.check! (<:fix:fix .i|444|447 (vector-length:vec .v|444|447)) 40 .v|444|447 .i|444|447) (.check! (>=:fix:fix .i|444|447 0) 40 .v|444|447 .i|444|447) (vector-ref:trusted .v|444|447 .i|444|447))))) (let () (begin (hashtable-put! .variables|6 .v|432 .aval|438) (if (if .debugging?|6 (not (eq? .aval|438 #t)) #f) (begin (write .v|432) (display ": ") (write .aval|438) (newline)) (unspecified)))))) (.loop|422|424|427 (let ((.x|452|455 .y1|417|418|428)) (begin (.check! (pair? .x|452|455) 1 .x|452|455) (cdr:pair .x|452|455)))))))) (.loop|422|424|427 .vars|368)))) .variables|6)))))))) (.constant-propagation-using-callgraph|2 .g|1))))) 'constant-propagation-using-callgraph))
(let () (begin (set! constant-folding! (lambda (.l|1 .variables|1) (let ((.constant-folding!|2 0)) (begin (set! .constant-folding!|2 (lambda (.l|3 .variables|3) (let ((.debugging?|6 #f) (.msg1|6 "    Propagating constant value for ") (.msg2|6 "    Folding: ") (.msg3|6 " ==> ") (.folding?|6 (integrate-usual-procedures)) (.changed?|6 #f)) (let ((.fold!|7 (unspecified)) (.delete-ignored-args!|7 (unspecified))) (begin (set! .fold!|7 (lambda (.exp|8) (let ((.temp|9|12 (let ((.x|403|406 .exp|8)) (begin (.check! (pair? .x|403|406) 0 .x|403|406) (car:pair .x|403|406))))) (if (memv .temp|9|12 '(quote)) .exp|8 (if (memv .temp|9|12 '(lambda)) (let ((.rinfo|17 (lambda.r .exp|8)) (.known|17 (let () (let ((.loop|166|169|172 (unspecified))) (begin (set! .loop|166|169|172 (lambda (.y1|161|162|173 .results|161|165|173) (if (null? .y1|161|162|173) (reverse .results|161|165|173) (begin #t (.loop|166|169|172 (let ((.x|177|180 .y1|161|162|173)) (begin (.check! (pair? .x|177|180) 1 .x|177|180) (cdr:pair .x|177|180))) (cons (def.lhs (let ((.x|181|184 .y1|161|162|173)) (begin (.check! (pair? .x|181|184) 0 .x|181|184) (car:pair .x|181|184)))) .results|161|165|173)))))) (.loop|166|169|172 (lambda.defs .exp|8) '())))))) (begin (let () (let ((.loop|23|25|28 (unspecified))) (begin (set! .loop|23|25|28 (lambda (.y1|18|19|29) (if (null? .y1|18|19|29) (if #f #f (unspecified)) (begin (begin #t (let* ((.entry|33 (let ((.x|102|105 .y1|18|19|29)) (begin (.check! (pair? .x|102|105) 0 .x|102|105) (car:pair .x|102|105)))) (.v|36 (r-entry.name .entry|33)) (.aval|39 (hashtable-fetch .variables|3 .v|36 #t))) (let () (if (if (pair? .aval|39) (not (memq .v|36 .known|17)) #f) (let ((.x|47 (constant.value .aval|39))) (if (let ((.temp|48|51 (boolean? .x|47))) (if .temp|48|51 .temp|48|51 (let ((.temp|52|55 (null? .x|47))) (if .temp|52|55 .temp|52|55 (let ((.temp|56|59 (symbol? .x|47))) (if .temp|56|59 .temp|56|59 (let ((.temp|60|63 (number? .x|47))) (if .temp|60|63 .temp|60|63 (let ((.temp|64|67 (char? .x|47))) (if .temp|64|67 .temp|64|67 (if (vector? .x|47) (zero? (let ((.v|71|74 .x|47)) (begin (.check! (vector? .v|71|74) 42 .v|71|74) (vector-length:vec .v|71|74)))) #f))))))))))) (let ((.refs|77 (r-entry.references .entry|33))) (begin (let () (let ((.loop|83|85|88 (unspecified))) (begin (set! .loop|83|85|88 (lambda (.y1|78|79|89) (if (null? .y1|78|79|89) (if #f #f (unspecified)) (begin (begin #t (let ((.ref|93 (let ((.x|94|97 .y1|78|79|89)) (begin (.check! (pair? .x|94|97) 0 .x|94|97) (car:pair .x|94|97))))) (variable-set! .ref|93 .aval|39))) (.loop|83|85|88 (let ((.x|98|101 .y1|78|79|89)) (begin (.check! (pair? .x|98|101) 1 .x|98|101) (cdr:pair .x|98|101)))))))) (.loop|83|85|88 .refs|77)))) (lambda.r-set! .exp|8 (remq .entry|33 (lambda.r .exp|8))) (flag-as-ignored .v|36 .exp|8) (if .debugging?|6 (begin (display .msg1|6) (write .v|36) (display ": ") (write .aval|39) (newline)) (unspecified)))) (unspecified))) (unspecified))))) (.loop|23|25|28 (let ((.x|106|109 .y1|18|19|29)) (begin (.check! (pair? .x|106|109) 1 .x|106|109) (cdr:pair .x|106|109)))))))) (.loop|23|25|28 .rinfo|17)))) (let () (let ((.loop|115|117|120 (unspecified))) (begin (set! .loop|115|117|120 (lambda (.y1|110|111|121) (if (null? .y1|110|111|121) (if #f #f (unspecified)) (begin (begin #t (let* ((.def|125 (let ((.x|153|156 .y1|110|111|121)) (begin (.check! (pair? .x|153|156) 0 .x|153|156) (car:pair .x|153|156)))) (.name|128 (def.lhs .def|125)) (.rhs|131 (def.rhs .def|125)) (.entry|134 (r-lookup .rinfo|17 .name|128)) (.calls|137 (r-entry.calls .entry|134))) (let () (if (null? .calls|137) (begin (lambda.defs-set! .exp|8 (remq .def|125 (lambda.defs .exp|8))) (lambda.r-set! .exp|8 (remq .entry|134 (lambda.r .exp|8)))) (let* ((.formals0|143 (append (lambda.args .rhs|131) '())) (.l|146 (.fold!|7 .rhs|131)) (.formals1|149 (lambda.args .l|146))) (let () (if (not (equal? .formals0|143 .formals1|149)) (.delete-ignored-args!|7 .l|146 .formals0|143 .calls|137) (unspecified)))))))) (.loop|115|117|120 (let ((.x|157|160 .y1|110|111|121)) (begin (.check! (pair? .x|157|160) 1 .x|157|160) (cdr:pair .x|157|160)))))))) (.loop|115|117|120 (lambda.defs .exp|8))))) (lambda.body-set! .exp|8 (.fold!|7 (lambda.body .exp|8))) .exp|8)) (if (memv .temp|9|12 '(set!)) (begin (assignment.rhs-set! .exp|8 (.fold!|7 (assignment.rhs .exp|8))) .exp|8) (if (memv .temp|9|12 '(begin)) (if (variable? .exp|8) .exp|8 (post-simplify-begin (make-begin (let () (let ((.loop|192|195|198 (unspecified))) (begin (set! .loop|192|195|198 (lambda (.y1|187|188|199 .results|187|191|199) (if (null? .y1|187|188|199) (reverse .results|187|191|199) (begin #t (.loop|192|195|198 (let ((.x|203|206 .y1|187|188|199)) (begin (.check! (pair? .x|203|206) 1 .x|203|206) (cdr:pair .x|203|206))) (cons (.fold!|7 (let ((.x|207|210 .y1|187|188|199)) (begin (.check! (pair? .x|207|210) 0 .x|207|210) (car:pair .x|207|210)))) .results|187|191|199)))))) (.loop|192|195|198 (begin.exprs .exp|8) '()))))) (make-notepad #f))) (if (memv .temp|9|12 '(if)) (let ((.exp0|214 (.fold!|7 (if.test .exp|8))) (.exp1|214 (.fold!|7 (if.then .exp|8))) (.exp2|214 (.fold!|7 (if.else .exp|8)))) (if (constant? .exp0|214) (let ((.newexp|217 (if (constant.value .exp0|214) .exp1|214 .exp2|214))) (begin (if .debugging?|6 (begin (display .msg2|6) (write (make-readable .exp|8)) (display .msg3|6) (write (make-readable .newexp|217)) (newline)) (unspecified)) (set! .changed?|6 #t) .newexp|217)) (make-conditional .exp0|214 .exp1|214 .exp2|214))) (let ((.args|221 (let () (let ((.loop|384|387|390 (unspecified))) (begin (set! .loop|384|387|390 (lambda (.y1|379|380|391 .results|379|383|391) (if (null? .y1|379|380|391) (reverse .results|379|383|391) (begin #t (.loop|384|387|390 (let ((.x|395|398 .y1|379|380|391)) (begin (.check! (pair? .x|395|398) 1 .x|395|398) (cdr:pair .x|395|398))) (cons (.fold!|7 (let ((.x|399|402 .y1|379|380|391)) (begin (.check! (pair? .x|399|402) 0 .x|399|402) (car:pair .x|399|402)))) .results|379|383|391)))))) (.loop|384|387|390 (call.args .exp|8) '()))))) (.proc|221 (.fold!|7 (call.proc .exp|8)))) (if (if .folding?|6 (if (variable? .proc|221) (if (every? constant? .args|221) (let ((.entry|229 (constant-folding-entry (variable.name .proc|221)))) (if .entry|229 (let ((.preds|234 (constant-folding-predicates .entry|229))) (if (= (length .args|221) (length .preds|234)) (every? (lambda (.x|237) .x|237) (let () (let ((.loop|244|248|251 (unspecified))) (begin (set! .loop|244|248|251 (lambda (.y1|238|240|252 .y1|238|239|252 .results|238|243|252) (if (let ((.temp|254|257 (null? .y1|238|240|252))) (if .temp|254|257 .temp|254|257 (null? .y1|238|239|252))) (reverse .results|238|243|252) (begin #t (.loop|244|248|251 (let ((.x|260|263 .y1|238|240|252)) (begin (.check! (pair? .x|260|263) 1 .x|260|263) (cdr:pair .x|260|263))) (let ((.x|264|267 .y1|238|239|252)) (begin (.check! (pair? .x|264|267) 1 .x|264|267) (cdr:pair .x|264|267))) (cons (let ((.f|268 (let ((.x|269|272 .y1|238|240|252)) (begin (.check! (pair? .x|269|272) 0 .x|269|272) (car:pair .x|269|272)))) (.v|268 (let ((.x|273|276 .y1|238|239|252)) (begin (.check! (pair? .x|273|276) 0 .x|273|276) (car:pair .x|273|276))))) (.f|268 .v|268)) .results|238|243|252)))))) (.loop|244|248|251 (constant-folding-predicates .entry|229) (let () (let ((.loop|282|285|288 (unspecified))) (begin (set! .loop|282|285|288 (lambda (.y1|277|278|289 .results|277|281|289) (if (null? .y1|277|278|289) (reverse .results|277|281|289) (begin #t (.loop|282|285|288 (let ((.x|293|296 .y1|277|278|289)) (begin (.check! (pair? .x|293|296) 1 .x|293|296) (cdr:pair .x|293|296))) (cons (constant.value (let ((.x|297|300 .y1|277|278|289)) (begin (.check! (pair? .x|297|300) 0 .x|297|300) (car:pair .x|297|300)))) .results|277|281|289)))))) (.loop|282|285|288 .args|221 '())))) '()))))) #f)) #f)) #f) #f) #f) (begin (set! .changed?|6 #t) (let ((.result|303 (make-constant (apply (constant-folding-folder (constant-folding-entry (variable.name .proc|221))) (let () (let ((.loop|309|312|315 (unspecified))) (begin (set! .loop|309|312|315 (lambda (.y1|304|305|316 .results|304|308|316) (if (null? .y1|304|305|316) (reverse .results|304|308|316) (begin #t (.loop|309|312|315 (let ((.x|320|323 .y1|304|305|316)) (begin (.check! (pair? .x|320|323) 1 .x|320|323) (cdr:pair .x|320|323))) (cons (constant.value (let ((.x|324|327 .y1|304|305|316)) (begin (.check! (pair? .x|324|327) 0 .x|324|327) (car:pair .x|324|327)))) .results|304|308|316)))))) (.loop|309|312|315 .args|221 '())))))))) (begin (if .debugging?|6 (begin (display .msg2|6) (write (make-readable (make-call .proc|221 .args|221))) (display .msg3|6) (write .result|303) (newline)) (unspecified)) .result|303))) (if (if (lambda? .proc|221) (list? (lambda.args .proc|221)) #f) (let ((.formals|333 (reverse (lambda.args .proc|221))) (.actuals|333 (reverse .args|221)) (.processed-formals|333 '()) (.processed-actuals|333 '()) (.for-effect|333 '())) (let () (let ((.loop|336 (unspecified))) (begin (set! .loop|336 (lambda (.formals|337 .actuals|337 .processed-formals|337 .processed-actuals|337 .for-effect|337) (if (null? .formals|337) (begin (lambda.args-set! .proc|221 .processed-formals|337) (call.args-set! .exp|8 .processed-actuals|337) (let ((.call|341 (if (if (null? .processed-formals|337) (null? (lambda.defs .proc|221)) #f) (lambda.body .proc|221) .exp|8))) (if (null? .for-effect|337) .call|341 (post-simplify-begin (make-begin (reverse (cons .call|341 .for-effect|337))) (make-notepad #f))))) (if (ignored? (let ((.x|345|348 .formals|337)) (begin (.check! (pair? .x|345|348) 0 .x|345|348) (car:pair .x|345|348)))) (.loop|336 (let ((.x|349|352 .formals|337)) (begin (.check! (pair? .x|349|352) 1 .x|349|352) (cdr:pair .x|349|352))) (let ((.x|353|356 .actuals|337)) (begin (.check! (pair? .x|353|356) 1 .x|353|356) (cdr:pair .x|353|356))) .processed-formals|337 .processed-actuals|337 (cons (let ((.x|357|360 .actuals|337)) (begin (.check! (pair? .x|357|360) 0 .x|357|360) (car:pair .x|357|360))) .for-effect|337)) (.loop|336 (let ((.x|362|365 .formals|337)) (begin (.check! (pair? .x|362|365) 1 .x|362|365) (cdr:pair .x|362|365))) (let ((.x|366|369 .actuals|337)) (begin (.check! (pair? .x|366|369) 1 .x|366|369) (cdr:pair .x|366|369))) (cons (let ((.x|370|373 .formals|337)) (begin (.check! (pair? .x|370|373) 0 .x|370|373) (car:pair .x|370|373))) .processed-formals|337) (cons (let ((.x|374|377 .actuals|337)) (begin (.check! (pair? .x|374|377) 0 .x|374|377) (car:pair .x|374|377))) .processed-actuals|337) .for-effect|337))))) (.loop|336 .formals|333 .actuals|333 .processed-formals|333 .processed-actuals|333 .for-effect|333))))) (begin (call.proc-set! .exp|8 .proc|221) (call.args-set! .exp|8 .args|221) .exp|8)))))))))))) (set! .delete-ignored-args!|7 (lambda (.l|407 .formals0|407 .calls|407) (let ((.formals1|410 (lambda.args .l|407))) (begin (let () (let ((.loop|416|418|421 (unspecified))) (begin (set! .loop|416|418|421 (lambda (.y1|411|412|422) (if (null? .y1|411|412|422) (if #f #f (unspecified)) (begin (begin #t (let ((.call|426 (let ((.x|465|468 .y1|411|412|422)) (begin (.check! (pair? .x|465|468) 0 .x|465|468) (car:pair .x|465|468))))) (let () (let ((.loop|427|432|435 (unspecified))) (begin (set! .loop|427|432|435 (lambda (.formals0|436 .formals1|436 .args|436 .newargs|436) (if (null? .formals0|436) (call.args-set! .call|426 (reverse .newargs|436)) (begin #t (.loop|427|432|435 (let ((.x|439|442 .formals0|436)) (begin (.check! (pair? .x|439|442) 1 .x|439|442) (cdr:pair .x|439|442))) (let ((.x|443|446 .formals1|436)) (begin (.check! (pair? .x|443|446) 1 .x|443|446) (cdr:pair .x|443|446))) (let ((.x|447|450 .args|436)) (begin (.check! (pair? .x|447|450) 1 .x|447|450) (cdr:pair .x|447|450))) (if (if (eq? (let ((.x|452|455 .formals1|436)) (begin (.check! (pair? .x|452|455) 0 .x|452|455) (car:pair .x|452|455))) name:ignored) (pair? (hashtable-get .variables|3 (let ((.x|457|460 .formals0|436)) (begin (.check! (pair? .x|457|460) 0 .x|457|460) (car:pair .x|457|460))))) #f) .newargs|436 (cons (let ((.x|461|464 .args|436)) (begin (.check! (pair? .x|461|464) 0 .x|461|464) (car:pair .x|461|464))) .newargs|436))))))) (.loop|427|432|435 .formals0|407 .formals1|410 (call.args .call|426) '())))))) (.loop|416|418|421 (let ((.x|469|472 .y1|411|412|422)) (begin (.check! (pair? .x|469|472) 1 .x|469|472) (cdr:pair .x|469|472)))))))) (.loop|416|418|421 .calls|407)))) (let () (let ((.loop|473|477|480 (unspecified))) (begin (set! .loop|473|477|480 (lambda (.formals0|481 .formals1|481 .formals2|481) (if (null? .formals0|481) (lambda.args-set! .l|407 (reverse .formals2|481)) (begin #t (.loop|473|477|480 (let ((.x|484|487 .formals0|481)) (begin (.check! (pair? .x|484|487) 1 .x|484|487) (cdr:pair .x|484|487))) (let ((.x|488|491 .formals1|481)) (begin (.check! (pair? .x|488|491) 1 .x|488|491) (cdr:pair .x|488|491))) (if (if (not (eq? (let ((.x|493|496 .formals0|481)) (begin (.check! (pair? .x|493|496) 0 .x|493|496) (car:pair .x|493|496))) (let ((.x|497|500 .formals1|481)) (begin (.check! (pair? .x|497|500) 0 .x|497|500) (car:pair .x|497|500))))) (if (eq? (let ((.x|502|505 .formals1|481)) (begin (.check! (pair? .x|502|505) 0 .x|502|505) (car:pair .x|502|505))) name:ignored) (pair? (hashtable-get .variables|3 (let ((.x|507|510 .formals0|481)) (begin (.check! (pair? .x|507|510) 0 .x|507|510) (car:pair .x|507|510))))) #f) #f) .formals2|481 (cons (let ((.x|511|514 .formals1|481)) (begin (.check! (pair? .x|511|514) 0 .x|511|514) (car:pair .x|511|514))) .formals2|481))))))) (.loop|473|477|480 .formals0|407 .formals1|410 '())))))))) (.fold!|7 .l|3) .changed?|6))))) (.constant-folding!|2 .l|1 .variables|1))))) 'constant-folding!))
(let () (begin (set! a-normal-form-declaration (cons 'anf '())) 'a-normal-form-declaration))
(let () (begin (set! a-normal-form (lambda (.e|1 . .rest|1) (let ((.complicated?|2 (unspecified)) (.normalize-let|2 (unspecified)) (.normalize-let-error|2 (unspecified)) (.unpermute|2 (unspecified)) (.permute|2 (unspecified)) (.anf-order-of-evaluation|2 (unspecified)) (.anf-call|2 (unspecified)) (.anf-conditional|2 (unspecified)) (.anf-assignment|2 (unspecified)) (.anf-lambda|2 (unspecified)) (.anf-sequential|2 (unspecified)) (.anf-make-let*|2 (unspecified)) (.anf-result|2 (unspecified)) (.anf-bind|2 (unspecified)) (.anf-bind-name|2 (unspecified)) (.anf-bind-dummy|2 (unspecified)) (.anf|2 (unspecified)) (.newtemp|2 (unspecified)) (.a-normal-form|2 (unspecified)) (.temp-counter|2 (unspecified)) (.anf:dummy|2 (unspecified)) (.temp-prefix|2 (unspecified))) (begin (set! .complicated?|2 (lambda (.exp|3) (let* ((.budget|6 10) (.complicated?|7 (unspecified))) (begin (set! .complicated?|7 (lambda (.exp|8) (begin (set! .budget|6 (- .budget|6 1)) (if (zero? .budget|6) #t (let ((.temp|9|12 (let ((.x|34|37 .exp|8)) (begin (.check! (pair? .x|34|37) 0 .x|34|37) (car:pair .x|34|37))))) (if (memv .temp|9|12 '(quote)) #f (if (memv .temp|9|12 '(lambda)) #f (if (memv .temp|9|12 '(set!)) (.complicated?|7 (assignment.rhs .exp|8)) (if (memv .temp|9|12 '(if)) (let ((.temp|17|20 (.complicated?|7 (if.test .exp|8)))) (if .temp|17|20 .temp|17|20 (let ((.temp|21|24 (.complicated?|7 (if.then .exp|8)))) (if .temp|21|24 .temp|21|24 (.complicated?|7 (if.else .exp|8)))))) (if (memv .temp|9|12 '(begin)) (if (variable? .exp|8) #f (some? .complicated?|7 (begin.exprs .exp|8))) (let ((.proc|30 (call.proc .exp|8))) (if (if (variable? .proc|30) (if (integrate-usual-procedures) (prim-entry (variable.name .proc|30)) #f) #f) (some? .complicated?|7 (call.args .exp|8)) #t)))))))))))) (.complicated?|7 .exp|3))))) (set! .normalize-let|2 (lambda (.exp|38) (let ((.l|41 (call.proc .exp|38))) (let () (let ((.formals|47 (lambda.args .l|41)) (.args|47 (call.args .exp|38)) (.newformals|47 '()) (.newargs|47 '())) (let () (let ((.loop|50 (unspecified))) (begin (set! .loop|50 (lambda (.formals|51 .args|51 .newformals|51 .newargs|51) (if (null? .formals|51) (if (null? .args|51) (begin (lambda.args-set! .l|41 (reverse .newformals|51)) (call.args-set! .exp|38 (reverse .newargs|51))) (begin (.normalize-let-error|2 .exp|38) (.loop|50 (cons (.newtemp|2) '()) .args|51 .newformals|51 .newargs|51))) (if (pair? .formals|51) (if (pair? .args|51) (.loop|50 (let ((.x|55|58 .formals|51)) (begin (.check! (pair? .x|55|58) 1 .x|55|58) (cdr:pair .x|55|58))) (let ((.x|59|62 .args|51)) (begin (.check! (pair? .x|59|62) 1 .x|59|62) (cdr:pair .x|59|62))) (cons (let ((.x|63|66 .formals|51)) (begin (.check! (pair? .x|63|66) 0 .x|63|66) (car:pair .x|63|66))) .newformals|51) (cons (let ((.x|67|70 .args|51)) (begin (.check! (pair? .x|67|70) 0 .x|67|70) (car:pair .x|67|70))) .newargs|51)) (begin (.normalize-let-error|2 .exp|38) (.loop|50 .formals|51 (cons (make-constant 0) .args|51) .newformals|51 .newargs|51))) (.loop|50 (cons .formals|51 '()) (cons (make-call-to-list .args|51) '()) .newformals|51 .newargs|51))))) (.loop|50 .formals|47 .args|47 .newformals|47 .newargs|47))))))))) (set! .normalize-let-error|2 (lambda (.exp|74) (if (issue-warnings) (begin (display "WARNING from compiler: ") (display "Wrong number of arguments ") (display "to lambda expression") (newline) (pretty-print (make-readable .exp|74) #t) (newline)) (unspecified)))) (set! .unpermute|2 (lambda (.things|75 .pi|75) (let* ((.v0|78 (list->vector .things|75)) (.v1|81 (make-vector (let ((.v|112|115 .v0|78)) (begin (.check! (vector? .v|112|115) 42 .v|112|115) (vector-length:vec .v|112|115))) '()))) (let () (let () (let ((.loop|85|88|91 (unspecified))) (begin (set! .loop|85|88|91 (lambda (.pi|92 .k|92) (if (null? .pi|92) (vector->list .v1|81) (begin (begin #t (let ((.v|95|98 .v1|81) (.i|95|98 (let ((.x|99|102 .pi|92)) (begin (.check! (pair? .x|99|102) 0 .x|99|102) (car:pair .x|99|102)))) (.x|95|98 (let ((.v|103|106 .v0|78) (.i|103|106 .k|92)) (begin (.check! (fixnum? .i|103|106) 40 .v|103|106 .i|103|106) (.check! (vector? .v|103|106) 40 .v|103|106 .i|103|106) (.check! (<:fix:fix .i|103|106 (vector-length:vec .v|103|106)) 40 .v|103|106 .i|103|106) (.check! (>=:fix:fix .i|103|106 0) 40 .v|103|106 .i|103|106) (vector-ref:trusted .v|103|106 .i|103|106))))) (begin (.check! (fixnum? .i|95|98) 41 .v|95|98 .i|95|98 .x|95|98) (.check! (vector? .v|95|98) 41 .v|95|98 .i|95|98 .x|95|98) (.check! (<:fix:fix .i|95|98 (vector-length:vec .v|95|98)) 41 .v|95|98 .i|95|98 .x|95|98) (.check! (>=:fix:fix .i|95|98 0) 41 .v|95|98 .i|95|98 .x|95|98) (vector-set!:trusted .v|95|98 .i|95|98 .x|95|98)))) (.loop|85|88|91 (let ((.x|107|110 .pi|92)) (begin (.check! (pair? .x|107|110) 1 .x|107|110) (cdr:pair .x|107|110))) (+ .k|92 1)))))) (.loop|85|88|91 .pi|75 0)))))))) (set! .permute|2 (lambda (.things|116 .pi|116) (let ((.v|119 (list->vector .things|116))) (let () (let ((.loop|125|128|131 (unspecified))) (begin (set! .loop|125|128|131 (lambda (.y1|120|121|132 .results|120|124|132) (if (null? .y1|120|121|132) (reverse .results|120|124|132) (begin #t (.loop|125|128|131 (let ((.x|136|139 .y1|120|121|132)) (begin (.check! (pair? .x|136|139) 1 .x|136|139) (cdr:pair .x|136|139))) (cons (let ((.i|140 (let ((.x|145|148 .y1|120|121|132)) (begin (.check! (pair? .x|145|148) 0 .x|145|148) (car:pair .x|145|148))))) (let ((.v|141|144 .v|119) (.i|141|144 .i|140)) (begin (.check! (fixnum? .i|141|144) 40 .v|141|144 .i|141|144) (.check! (vector? .v|141|144) 40 .v|141|144 .i|141|144) (.check! (<:fix:fix .i|141|144 (vector-length:vec .v|141|144)) 40 .v|141|144 .i|141|144) (.check! (>=:fix:fix .i|141|144 0) 40 .v|141|144 .i|141|144) (vector-ref:trusted .v|141|144 .i|141|144)))) .results|120|124|132)))))) (.loop|125|128|131 .pi|116 '()))))))) (set! .anf-order-of-evaluation|2 (lambda (.exprs|149 .regvars|149 .for-primop?|149) (let ((.ordering|150 (unspecified))) (begin (set! .ordering|150 (lambda (.targets|151 .exprs|151 .alist|151) (let* ((.para|154 (parallel-assignment .targets|151 .alist|151 .exprs|151)) (.temp|155|158 .para|154)) (if .temp|155|158 .temp|155|158 (cons (let ((.x|160|163 .targets|151)) (begin (.check! (pair? .x|160|163) 0 .x|160|163) (car:pair .x|160|163))) (.ordering|150 (let ((.x|164|167 .targets|151)) (begin (.check! (pair? .x|164|167) 1 .x|164|167) (cdr:pair .x|164|167))) (let ((.x|168|171 .exprs|151)) (begin (.check! (pair? .x|168|171) 1 .x|168|171) (cdr:pair .x|168|171))) .alist|151)))))) (if (parallel-assignment-optimization) (if (null? .exprs|149) '() (if (null? (let ((.x|174|177 .exprs|149)) (begin (.check! (pair? .x|174|177) 1 .x|174|177) (cdr:pair .x|174|177)))) '(0) (let* ((.contains-call?|181 #f) (.vexprs|184 (list->vector .exprs|149)) (.vindexes|187 (list->vector (iota (let ((.v|264|267 .vexprs|184)) (begin (.check! (vector? .v|264|267) 42 .v|264|267) (vector-length:vec .v|264|267)))))) (.contains-call?|190 #f) (.categories|193 (list->vector (let () (let ((.loop|240|243|246 (unspecified))) (begin (set! .loop|240|243|246 (lambda (.y1|235|236|247 .results|235|239|247) (if (null? .y1|235|236|247) (reverse .results|235|239|247) (begin #t (.loop|240|243|246 (let ((.x|251|254 .y1|235|236|247)) (begin (.check! (pair? .x|251|254) 1 .x|251|254) (cdr:pair .x|251|254))) (cons (let ((.e|255 (let ((.x|260|263 .y1|235|236|247)) (begin (.check! (pair? .x|260|263) 0 .x|260|263) (car:pair .x|260|263))))) (if (constant? .e|255) 2 (if (variable? .e|255) 2 (if (.complicated?|2 .e|255) (begin (set! .contains-call?|190 #t) 1) 0)))) .results|235|239|247)))))) (.loop|240|243|246 .exprs|149 '()))))))) (let () (if .contains-call?|190 (twobit-sort (lambda (.i|198 .j|198) (< (let ((.v|199|202 .categories|193) (.i|199|202 .i|198)) (begin (.check! (fixnum? .i|199|202) 40 .v|199|202 .i|199|202) (.check! (vector? .v|199|202) 40 .v|199|202 .i|199|202) (.check! (<:fix:fix .i|199|202 (vector-length:vec .v|199|202)) 40 .v|199|202 .i|199|202) (.check! (>=:fix:fix .i|199|202 0) 40 .v|199|202 .i|199|202) (vector-ref:trusted .v|199|202 .i|199|202))) (let ((.v|203|206 .categories|193) (.i|203|206 .j|198)) (begin (.check! (fixnum? .i|203|206) 40 .v|203|206 .i|203|206) (.check! (vector? .v|203|206) 40 .v|203|206 .i|203|206) (.check! (<:fix:fix .i|203|206 (vector-length:vec .v|203|206)) 40 .v|203|206 .i|203|206) (.check! (>=:fix:fix .i|203|206 0) 40 .v|203|206 .i|203|206) (vector-ref:trusted .v|203|206 .i|203|206))))) (iota (length .exprs|149))) (if .for-primop?|149 (reverse (iota (length .exprs|149))) (let* ((.targets|211 (iota (length .exprs|149))) (.pairup|212 (unspecified))) (begin (set! .pairup|212 (lambda (.regvars|213 .targets|213) (if (let ((.temp|214|217 (null? .targets|213))) (if .temp|214|217 .temp|214|217 (null? .regvars|213))) '() (cons (cons (let ((.x|219|222 .regvars|213)) (begin (.check! (pair? .x|219|222) 0 .x|219|222) (car:pair .x|219|222))) (let ((.x|223|226 .targets|213)) (begin (.check! (pair? .x|223|226) 0 .x|223|226) (car:pair .x|223|226)))) (.pairup|212 (let ((.x|227|230 .regvars|213)) (begin (.check! (pair? .x|227|230) 1 .x|227|230) (cdr:pair .x|227|230))) (let ((.x|231|234 .targets|213)) (begin (.check! (pair? .x|231|234) 1 .x|231|234) (cdr:pair .x|231|234)))))))) (.ordering|150 .targets|211 .exprs|149 (.pairup|212 .regvars|149 .targets|211)))))))))) (iota (length .exprs|149))))))) (set! .anf-call|2 (lambda (.e|268 .bindings|268 .regvars|268) (let* ((.proc|271 (call.proc .e|268)) (.args|274 (call.args .e|268))) (let () (let ((.let-loop|279 (unspecified)) (.loop|279 (unspecified))) (begin (set! .let-loop|279 (lambda (.exprs|280 .bindings|280 .regvars|280 .vars|280) (if (null? .exprs|280) (if (null? (lambda.defs .proc|271)) (.anf|2 (lambda.body .proc|271) .bindings|280 .regvars|280) (let ((.bindings|283 (.anf-bind|2 (make-lambda '() (lambda.defs .proc|271) '() '() '() (cons a-normal-form-declaration (lambda.decls .proc|271)) (lambda.doc .proc|271) (lambda.body .proc|271)) .bindings|280 '()))) (.anf-bind-dummy|2 (make-call (.anf-result|2 .bindings|283) '()) .bindings|283))) (.let-loop|279 (let ((.x|284|287 .exprs|280)) (begin (.check! (pair? .x|284|287) 1 .x|284|287) (cdr:pair .x|284|287))) (.anf-bind-name|2 (let ((.x|288|291 .vars|280)) (begin (.check! (pair? .x|288|291) 0 .x|288|291) (car:pair .x|288|291))) (let ((.x|292|295 .exprs|280)) (begin (.check! (pair? .x|292|295) 0 .x|292|295) (car:pair .x|292|295))) .bindings|280 .regvars|280) .regvars|280 (let ((.x|296|299 .vars|280)) (begin (.check! (pair? .x|296|299) 1 .x|296|299) (cdr:pair .x|296|299))))))) (set! .loop|279 (lambda (.exprs|300 .bindings|300 .names|300 .rename-always?|300) (if (null? .exprs|300) (values .bindings|300 (reverse .names|300)) (let ((.e|303 (let ((.x|332|335 .exprs|300)) (begin (.check! (pair? .x|332|335) 0 .x|332|335) (car:pair .x|332|335))))) (if (let ((.temp|304|307 .rename-always?|300)) (if .temp|304|307 .temp|304|307 (not (let ((.temp|309|312 (constant? .e|303))) (if .temp|309|312 .temp|309|312 (variable? .e|303)))))) (let ((.bindings|316 (.anf-bind|2 (let ((.x|324|327 .exprs|300)) (begin (.check! (pair? .x|324|327) 0 .x|324|327) (car:pair .x|324|327))) .bindings|300 .regvars|268))) (let () (.loop|279 (let ((.x|320|323 .exprs|300)) (begin (.check! (pair? .x|320|323) 1 .x|320|323) (cdr:pair .x|320|323))) .bindings|316 (cons (.anf-result|2 .bindings|316) .names|300) .rename-always?|300))) (.loop|279 (let ((.x|328|331 .exprs|300)) (begin (.check! (pair? .x|328|331) 1 .x|328|331) (cdr:pair .x|328|331))) .bindings|300 (cons .e|303 .names|300) .rename-always?|300)))))) (if (lambda? .proc|271) (let ((.formals|338 (lambda.args .proc|271))) (if (list? .formals|338) (let* ((.pi|341 (.anf-order-of-evaluation|2 .args|274 .regvars|268 #f)) (.exprs|344 (.permute|2 .args|274 .pi|341)) (.names|347 (.permute|2 (lambda.args .proc|271) .pi|341))) (let () (.let-loop|279 (reverse .exprs|344) .bindings|268 .regvars|268 (reverse .names|347)))) (.anf-call|2 (.normalize-let|2 .e|268) .bindings|268 .regvars|268))) (if (not (variable? .proc|271)) (let ((.pi|354 (.anf-order-of-evaluation|2 .args|274 .regvars|268 #f))) (call-with-values (lambda () (.loop|279 (.permute|2 .args|274 .pi|354) .bindings|268 '() #t)) (lambda (.bindings|356 .names|356) (let ((.bindings|359 (.anf-bind|2 .proc|271 .bindings|356 .regvars|268))) (.anf-bind-dummy|2 (make-call (.anf-result|2 .bindings|359) (.unpermute|2 .names|356 .pi|354)) .bindings|359))))) (if (if (integrate-usual-procedures) (prim-entry (variable.name .proc|271)) #f) (let ((.pi|365 (.anf-order-of-evaluation|2 .args|274 .regvars|268 #t))) (call-with-values (lambda () (.loop|279 (.permute|2 .args|274 .pi|365) .bindings|268 '() #t)) (lambda (.bindings|367 .names|367) (.anf-bind-dummy|2 (make-call .proc|271 (.unpermute|2 .names|367 .pi|365)) .bindings|367)))) (if (memq (variable.name .proc|271) .regvars|268) (let* ((.exprs|371 (cons .proc|271 .args|274)) (.pi|374 (.anf-order-of-evaluation|2 .exprs|371 (cons name:ignored .regvars|268) #f))) (let () (call-with-values (lambda () (.loop|279 (.permute|2 .exprs|371 .pi|374) .bindings|268 '() #t)) (lambda (.bindings|379 .names|379) (let ((.names|382 (.unpermute|2 .names|379 .pi|374))) (.anf-bind-dummy|2 (make-call (let ((.x|383|386 .names|382)) (begin (.check! (pair? .x|383|386) 0 .x|383|386) (car:pair .x|383|386))) (let ((.x|387|390 .names|382)) (begin (.check! (pair? .x|387|390) 1 .x|387|390) (cdr:pair .x|387|390)))) .bindings|379)))))) (let ((.pi|394 (.anf-order-of-evaluation|2 .args|274 .regvars|268 #f))) (call-with-values (lambda () (.loop|279 (.permute|2 .args|274 .pi|394) .bindings|268 '() #t)) (lambda (.bindings|396 .names|396) (.anf-bind-dummy|2 (make-call .proc|271 (.unpermute|2 .names|396 .pi|394)) .bindings|396)))))))))))))) (set! .anf-conditional|2 (lambda (.e|397 .bindings|397 .regvars|397) (let ((.e0|400 (if.test .e|397)) (.e1|400 (if.then .e|397)) (.e2|400 (if.else .e|397))) (if (variable? .e0|400) (let ((.e1|403 (.anf-make-let*|2 (.anf|2 .e1|400 '() .regvars|397))) (.e2|403 (.anf-make-let*|2 (.anf|2 .e2|400 '() .regvars|397)))) (.anf-bind-dummy|2 (make-conditional .e0|400 .e1|403 .e2|403) .bindings|397)) (let* ((.bindings|406 (.anf-bind|2 .e0|400 .bindings|397 .regvars|397)) (.e1|409 (.anf-make-let*|2 (.anf|2 .e1|400 '() .regvars|397))) (.e2|412 (.anf-make-let*|2 (.anf|2 .e2|400 '() .regvars|397)))) (let () (.anf-bind-dummy|2 (make-conditional (.anf-result|2 .bindings|406) .e1|409 .e2|412) .bindings|406))))))) (set! .anf-assignment|2 (lambda (.e|416 .bindings|416 .regvars|416) (let ((.i|419 (assignment.lhs .e|416)) (.e1|419 (assignment.rhs .e|416))) (if (variable? .e1|419) (.anf-bind-dummy|2 .e|416 .bindings|416) (let* ((.bindings|422 (.anf-bind|2 .e1|419 .bindings|416 .regvars|416)) (.t1|425 (.anf-result|2 .bindings|422))) (let () (.anf-bind-dummy|2 (make-assignment .i|419 .t1|425) .bindings|422))))))) (set! .anf-lambda|2 (lambda (.l|429 .bindings|429 .regvars|429) (.anf-bind-dummy|2 (make-lambda (lambda.args .l|429) (let () (let ((.loop|435|438|441 (unspecified))) (begin (set! .loop|435|438|441 (lambda (.y1|430|431|442 .results|430|434|442) (if (null? .y1|430|431|442) (reverse .results|430|434|442) (begin #t (.loop|435|438|441 (let ((.x|446|449 .y1|430|431|442)) (begin (.check! (pair? .x|446|449) 1 .x|446|449) (cdr:pair .x|446|449))) (cons (let ((.def|450 (let ((.x|451|454 .y1|430|431|442)) (begin (.check! (pair? .x|451|454) 0 .x|451|454) (car:pair .x|451|454))))) (make-definition (def.lhs .def|450) (.a-normal-form|2 (def.rhs .def|450)))) .results|430|434|442)))))) (.loop|435|438|441 (lambda.defs .l|429) '())))) '() '() '() (cons a-normal-form-declaration (lambda.decls .l|429)) (lambda.doc .l|429) (.anf-make-let*|2 (.anf|2 (lambda.body .l|429) '() (make-null-terminated (lambda.args .l|429))))) .bindings|429))) (set! .anf-sequential|2 (lambda (.e|455 .bindings|455 .regvars|455) (let () (let ((.loop|456|459|462 (unspecified))) (begin (set! .loop|456|459|462 (lambda (.bindings|463 .exprs|463) (if (null? (let ((.x|465|468 .exprs|463)) (begin (.check! (pair? .x|465|468) 1 .x|465|468) (cdr:pair .x|465|468)))) (.anf|2 (let ((.x|469|472 .exprs|463)) (begin (.check! (pair? .x|469|472) 0 .x|469|472) (car:pair .x|469|472))) .bindings|463 .regvars|455) (begin #t (.loop|456|459|462 (.anf-bind|2 (let ((.x|474|477 .exprs|463)) (begin (.check! (pair? .x|474|477) 0 .x|474|477) (car:pair .x|474|477))) .bindings|463 .regvars|455) (let ((.x|478|481 .exprs|463)) (begin (.check! (pair? .x|478|481) 1 .x|478|481) (cdr:pair .x|478|481)))))))) (.loop|456|459|462 .bindings|455 (begin.exprs .e|455))))))) (set! .anf-make-let*|2 (lambda (.bindings|482) (let ((.loop|483 (unspecified))) (begin (set! .loop|483 (lambda (.bindings|484 .body|484) (if (null? .bindings|484) .body|484 (let ((.t1|487 (let ((.x|495|498 (let ((.x|499|502 .bindings|484)) (begin (.check! (pair? .x|499|502) 0 .x|499|502) (car:pair .x|499|502))))) (begin (.check! (pair? .x|495|498) 0 .x|495|498) (car:pair .x|495|498)))) (.e1|487 (let ((.x|504|507 (let ((.x|508|511 (let ((.x|512|515 .bindings|484)) (begin (.check! (pair? .x|512|515) 0 .x|512|515) (car:pair .x|512|515))))) (begin (.check! (pair? .x|508|511) 1 .x|508|511) (cdr:pair .x|508|511))))) (begin (.check! (pair? .x|504|507) 0 .x|504|507) (car:pair .x|504|507))))) (.loop|483 (let ((.x|488|491 .bindings|484)) (begin (.check! (pair? .x|488|491) 1 .x|488|491) (cdr:pair .x|488|491))) (make-call (make-lambda (cons .t1|487 '()) '() '() '() '() (cons a-normal-form-declaration '()) '() .body|484) (cons .e1|487 '()))))))) (.loop|483 (let ((.x|516|519 .bindings|482)) (begin (.check! (pair? .x|516|519) 1 .x|516|519) (cdr:pair .x|516|519))) (let ((.x|521|524 (let ((.x|525|528 (let ((.x|529|532 .bindings|482)) (begin (.check! (pair? .x|529|532) 0 .x|529|532) (car:pair .x|529|532))))) (begin (.check! (pair? .x|525|528) 1 .x|525|528) (cdr:pair .x|525|528))))) (begin (.check! (pair? .x|521|524) 0 .x|521|524) (car:pair .x|521|524)))))))) (set! .anf-result|2 (lambda (.bindings|533) (make-variable (let ((.x|534|537 (let ((.x|538|541 .bindings|533)) (begin (.check! (pair? .x|538|541) 0 .x|538|541) (car:pair .x|538|541))))) (begin (.check! (pair? .x|534|537) 0 .x|534|537) (car:pair .x|534|537)))))) (set! .anf-bind|2 (lambda (.e|542 .bindings|542 .regvars|542) (let ((.bindings|545 (.anf|2 .e|542 .bindings|542 .regvars|542))) (cons (let* ((.t1|546|549 (.newtemp|2)) (.t2|546|552 (cons (let ((.x|558|561 (let ((.x|562|565 (let ((.x|566|569 .bindings|545)) (begin (.check! (pair? .x|566|569) 0 .x|566|569) (car:pair .x|566|569))))) (begin (.check! (pair? .x|562|565) 1 .x|562|565) (cdr:pair .x|562|565))))) (begin (.check! (pair? .x|558|561) 0 .x|558|561) (car:pair .x|558|561))) '()))) (let () (cons .t1|546|549 .t2|546|552))) (let ((.x|570|573 .bindings|545)) (begin (.check! (pair? .x|570|573) 1 .x|570|573) (cdr:pair .x|570|573))))))) (set! .anf-bind-name|2 (lambda (.name|574 .e|574 .bindings|574 .regvars|574) (let ((.bindings|577 (.anf|2 .e|574 .bindings|574 .regvars|574))) (cons (let* ((.t1|578|581 .name|574) (.t2|578|584 (cons (let ((.x|590|593 (let ((.x|594|597 (let ((.x|598|601 .bindings|577)) (begin (.check! (pair? .x|598|601) 0 .x|598|601) (car:pair .x|598|601))))) (begin (.check! (pair? .x|594|597) 1 .x|594|597) (cdr:pair .x|594|597))))) (begin (.check! (pair? .x|590|593) 0 .x|590|593) (car:pair .x|590|593))) '()))) (let () (cons .t1|578|581 .t2|578|584))) (let ((.x|602|605 .bindings|577)) (begin (.check! (pair? .x|602|605) 1 .x|602|605) (cdr:pair .x|602|605))))))) (set! .anf-bind-dummy|2 (lambda (.e|606 .bindings|606) (cons (let* ((.t1|607|610 .anf:dummy|2) (.t2|607|613 (cons .e|606 '()))) (let () (cons .t1|607|610 .t2|607|613))) .bindings|606))) (set! .anf|2 (lambda (.e|618 .bindings|618 .regvars|618) (let ((.temp|619|622 (let ((.x|629|632 .e|618)) (begin (.check! (pair? .x|629|632) 0 .x|629|632) (car:pair .x|629|632))))) (if (memv .temp|619|622 '(quote)) (.anf-bind-dummy|2 .e|618 .bindings|618) (if (memv .temp|619|622 '(begin)) (if (variable? .e|618) (.anf-bind-dummy|2 .e|618 .bindings|618) (.anf-sequential|2 .e|618 .bindings|618 .regvars|618)) (if (memv .temp|619|622 '(lambda)) (.anf-lambda|2 .e|618 .bindings|618 .regvars|618) (if (memv .temp|619|622 '(set!)) (.anf-assignment|2 .e|618 .bindings|618 .regvars|618) (if (memv .temp|619|622 '(if)) (.anf-conditional|2 .e|618 .bindings|618 .regvars|618) (.anf-call|2 .e|618 .bindings|618 .regvars|618))))))))) (set! .newtemp|2 (lambda () (begin (set! .temp-counter|2 (+ .temp-counter|2 1)) (string->symbol (string-append .temp-prefix|2 (number->string .temp-counter|2)))))) (set! .a-normal-form|2 (lambda (.e|634) (.anf-make-let*|2 (.anf|2 .e|634 '() '())))) (set! .temp-counter|2 0) (set! .anf:dummy|2 (string->symbol "RESULT")) (set! .temp-prefix|2 (if (let ((.temp|635|638 (null? .rest|1))) (if .temp|635|638 .temp|635|638 (not (string? (let ((.x|640|643 .rest|1)) (begin (.check! (pair? .x|640|643) 0 .x|640|643) (car:pair .x|640|643))))))) (string-append renaming-prefix "T") (let ((.x|644|647 .rest|1)) (begin (.check! (pair? .x|644|647) 0 .x|644|647) (car:pair .x|644|647))))) (.a-normal-form|2 .e|1))))) 'a-normal-form))
(let () (begin (set! post-simplify-anf (lambda (.l0|1 .t1|1 .e0|1 .e1|1 .free|1 .regbindings|1 .l2|1) (let ((.post-simplify-anf|2 0)) (begin (set! .post-simplify-anf|2 (lambda (.l0|3 .t1|3 .e0|3 .e1|3 .free|3 .regbindings|3 .l2|3) (let ((.return-normally|4 (unspecified))) (begin (set! .return-normally|4 (lambda () (values (make-call .l0|3 (cons .e1|3 '())) .free|3 .regbindings|3))) (.return-normally|4))))) (.post-simplify-anf|2 .l0|1 .t1|1 .e0|1 .e1|1 .free|1 .regbindings|1 .l2|1))))) 'post-simplify-anf))
(let () (begin (set! argument-registers (let () (let ((.loop|1|4|7 (unspecified))) (begin (set! .loop|1|4|7 (lambda (.n|8 .regs|8) (if (zero? .n|8) .regs|8 (begin #t (.loop|1|4|7 (- .n|8 1) (cons (string->symbol (string-append ".REG" (number->string .n|8))) .regs|8)))))) (.loop|1|4|7 (- *nregs* 2) '()))))) 'argument-registers))
(let () (begin (set! intraprocedural-commoning (lambda (.e|1 . .flags|1) (let ((.debugging?|2 (unspecified)) (.commoning?|2 (unspecified)) (.target-registers?|2 (unspecified))) (begin (set! .debugging?|2 #f) (set! .commoning?|2 (let ((.temp|3|6 (null? .flags|1))) (if .temp|3|6 .temp|3|6 (memq 'commoning .flags|1)))) (set! .target-registers?|2 (let ((.temp|8|11 (null? .flags|1))) (if .temp|8|11 .temp|8|11 (memq 'target-registers .flags|1)))) (call-with-current-continuation (lambda (.return|13) (let ((.scan-body|14 (unspecified)) (.error|14 (unspecified))) (begin (set! .scan-body|14 (lambda (.e|15 .env|15 .available|15 .regvars|15) (let ((.scan-rhs|16 (unspecified)) (.scan-defs|16 (unspecified)) (.scan-let0|16 (unspecified)) (.scan-binding-phase3|16 (unspecified)) (.scan-binding-phase2|16 (unspecified)) (.scan-binding|16 (unspecified)) (.scan|16 (unspecified)) (.available-add!|16 (unspecified)) (.global?|16 (unspecified)) (.environment-lookup|16 (unspecified)) (.environment-extend*|16 (unspecified)) (.environment-extend|16 (unspecified)) (.make-empty-environment|16 (unspecified)) (.abandon-expression!|16 (unspecified)) (.used-variable!|16 (unspecified)) (.closed-over-local-variable!|16 (unspecified)) (.adjust-local-variable!|16 (unspecified)) (.used-local-variable!|16 (unspecified)) (.record-local-variable!|16 (unspecified)) (.local-variable-used-once?|16 (unspecified)) (.local-variable-not-used?|16 (unspecified)) (.local-variable?|16 (unspecified)) (.local-variables|16 (unspecified))) (begin (set! .scan-rhs|16 (lambda (.e|17 .env|17 .available|17) (if (constant? .e|17) (values .e|17 (empty-set) '()) (if (variable? .e|17) (let* ((.name|22 (variable.name .e|17)) (.enew|25 (if .commoning?|2 (if (.global?|16 .name|22) (let ((.t|34 (available-expression .available|17 .e|17))) (if .t|34 (make-variable .t|34) #f)) (available-variable .available|17 .name|22)) #f))) (let () (if .enew|25 (.scan-rhs|16 .enew|25 .env|17 .available|17) (begin (.used-variable!|16 .name|22) (values .e|17 (cons .name|22 '()) '()))))) (if (lambda? .e|17) (let* ((.formals|38 (make-null-terminated (lambda.args .e|17))) (.env|41 (.environment-extend*|16 (.environment-extend*|16 .env|17 .formals|38) (let () (let ((.loop|87|90|93 (unspecified))) (begin (set! .loop|87|90|93 (lambda (.y1|82|83|94 .results|82|86|94) (if (null? .y1|82|83|94) (reverse .results|82|86|94) (begin #t (.loop|87|90|93 (let ((.x|98|101 .y1|82|83|94)) (begin (.check! (pair? .x|98|101) 1 .x|98|101) (cdr:pair .x|98|101))) (cons (def.lhs (let ((.x|102|105 .y1|82|83|94)) (begin (.check! (pair? .x|102|105) 0 .x|102|105) (car:pair .x|102|105)))) .results|82|86|94)))))) (.loop|87|90|93 (lambda.defs .e|17) '())))))) (.fdefs|44 (.scan-defs|16 .e|17 .env|41 .available|17))) (let () (call-with-values (lambda () (let ((.available|51 (copy-available-table .available|17))) (begin (available-kill! .available|51 available:killer:all) (.scan-body|14 (lambda.body .e|17) .env|41 .available|51 .formals|38)))) (lambda (.e0|52 .f0|52 .regbindings0|52) (call-with-values (lambda () (wrap-with-register-bindings .regbindings0|52 .e0|52 .f0|52)) (lambda (.e0|54 .f0|54) (begin (lambda.body-set! .e|17 .e0|54) (let ((.f|57 (union .fdefs|44 .f0|54))) (begin (let () (let ((.loop|63|65|68 (unspecified))) (begin (set! .loop|63|65|68 (lambda (.y1|58|59|69) (if (null? .y1|58|59|69) (if #f #f (unspecified)) (begin (begin #t (let ((.x|73 (let ((.x|74|77 .y1|58|59|69)) (begin (.check! (pair? .x|74|77) 0 .x|74|77) (car:pair .x|74|77))))) (.closed-over-local-variable!|16 .x|73))) (.loop|63|65|68 (let ((.x|78|81 .y1|58|59|69)) (begin (.check! (pair? .x|78|81) 1 .x|78|81) (cdr:pair .x|78|81)))))))) (.loop|63|65|68 .f|57)))) (lambda.f-set! .e|17 .f|57) (lambda.g-set! .e|17 .f|57) (values .e|17 (difference .f|57 (make-null-terminated (lambda.args .e|17))) '())))))))))) (if (conditional? .e|17) (let ((.e0|109 (if.test .e|17)) (.e1|109 (if.then .e|17)) (.e2|109 (if.else .e|17))) (if (constant? .e0|109) (let ((.e1|112 (if (constant.value .e0|109) .e1|109 .e2|109))) (call-with-values (lambda () (.scan|16 .e1|112 .env|17 .available|17)) (lambda (.e1|114 .f1|114 .regbindings1|114) (if (let ((.temp|116|119 (not (call? .e1|114)))) (if .temp|116|119 .temp|116|119 (not (lambda? (call.proc .e1|114))))) (values .e1|114 .f1|114 .regbindings1|114) (values (make-conditional (make-constant #t) .e1|114 (make-constant 0)) .f1|114 .regbindings1|114))))) (call-with-values (lambda () (.scan|16 .e0|109 .env|17 .available|17)) (lambda (.e0|123 .f0|123 .regbindings0|123) (begin (if (not (null? .regbindings0|123)) (.error|14 'scan-rhs 'if) (unspecified)) (if (not (eq? .e0|123 (if.test .e|17))) (.scan-rhs|16 (make-conditional .e0|123 .e1|109 .e2|109) .env|17 .available|17) (let ((.available1|126 (copy-available-table .available|17)) (.available2|126 (copy-available-table .available|17))) (begin (if (variable? .e0|123) (let ((.t0|129 (variable.name .e0|123))) (.available-add!|16 .available2|126 .t0|129 (make-constant #f))) (.error|14 (make-readable .e|17 #t))) (call-with-values (lambda () (.scan|16 .e1|109 .env|17 .available1|126)) (lambda (.e1|131 .f1|131 .regbindings1|131) (call-with-values (lambda () (wrap-with-register-bindings .regbindings1|131 .e1|131 .f1|131)) (lambda (.e1|133 .f1|133) (call-with-values (lambda () (.scan|16 .e2|109 .env|17 .available2|126)) (lambda (.e2|135 .f2|135 .regbindings2|135) (call-with-values (lambda () (wrap-with-register-bindings .regbindings2|135 .e2|135 .f2|135)) (lambda (.e2|137 .f2|137) (let ((.e|140 (make-conditional .e0|123 .e1|133 .e2|137)) (.f|140 (union .f0|123 .f1|133 .f2|137))) (begin (available-intersect! .available|17 .available1|126 .available2|126) (values .e|140 .f|140 '()))))))))))))))))))) (if (assignment? .e|17) (call-with-values (lambda () (.scan-rhs|16 (assignment.rhs .e|17) .env|17 .available|17)) (lambda (.e1|143 .f1|143 .regbindings1|143) (begin (if (not (null? .regbindings1|143)) (.error|14 'scan-rhs 'set!) (unspecified)) (available-kill! .available|17 available:killer:globals) (values (make-assignment (assignment.lhs .e|17) .e1|143) (union (cons (assignment.lhs .e|17) '()) .f1|143) '())))) (if (begin? .e|17) (.error|14 'scan-rhs 'begin) (if (real-call? .e|17) (let* ((.e0|149 (call.proc .e|17)) (.args|152 (call.args .e|17)) (.regcontents|155 (append .regvars|15 (let () (let ((.loop|308|311|314 (unspecified))) (begin (set! .loop|308|311|314 (lambda (.y1|303|304|315 .results|303|307|315) (if (null? .y1|303|304|315) (reverse .results|303|307|315) (begin #t (.loop|308|311|314 (let ((.x|319|322 .y1|303|304|315)) (begin (.check! (pair? .x|319|322) 1 .x|319|322) (cdr:pair .x|319|322))) (cons (let ((.x|323 (let ((.x|324|327 .y1|303|304|315)) (begin (.check! (pair? .x|324|327) 0 .x|324|327) (car:pair .x|324|327))))) #f) .results|303|307|315)))))) (.loop|308|311|314 .args|152 '()))))))) (let () (let ((.args|161 .args|152) (.regs|161 argument-registers) (.regcontents|161 .regcontents|155) (.newargs|161 '()) (.regbindings|161 '()) (.f|161 (if (variable? .e0|149) (let ((.f|301 (variable.name .e0|149))) (begin (.used-variable!|16 .f|301) (cons .f|301 '()))) (empty-set)))) (let () (let ((.loop|164 (unspecified))) (begin (set! .loop|164 (lambda (.args|165 .regs|165 .regcontents|165 .newargs|165 .regbindings|165 .f|165) (if (null? .args|165) (begin (available-kill! .available|17 available:killer:all) (values (make-call .e0|149 (reverse .newargs|165)) .f|165 .regbindings|165)) (if (null? .regs|165) (let ((.arg|170 (let ((.x|183|186 .args|165)) (begin (.check! (pair? .x|183|186) 0 .x|183|186) (car:pair .x|183|186))))) (.loop|164 (let ((.x|171|174 .args|165)) (begin (.check! (pair? .x|171|174) 1 .x|171|174) (cdr:pair .x|171|174))) '() (let ((.x|175|178 .regcontents|165)) (begin (.check! (pair? .x|175|178) 1 .x|175|178) (cdr:pair .x|175|178))) (cons .arg|170 .newargs|165) .regbindings|165 (if (variable? .arg|170) (let ((.name|181 (variable.name .arg|170))) (begin (.used-variable!|16 .name|181) (union (cons .name|181 '()) .f|165))) .f|165))) (if (if .commoning?|2 (if (variable? (let ((.x|190|193 .args|165)) (begin (.check! (pair? .x|190|193) 0 .x|190|193) (car:pair .x|190|193)))) (available-variable .available|17 (variable.name (let ((.x|195|198 .args|165)) (begin (.check! (pair? .x|195|198) 0 .x|195|198) (car:pair .x|195|198))))) #f) #f) (let* ((.name|201 (variable.name (let ((.x|212|215 .args|165)) (begin (.check! (pair? .x|212|215) 0 .x|212|215) (car:pair .x|212|215))))) (.enew|204 (available-variable .available|17 .name|201))) (let () (.loop|164 (cons .enew|204 (let ((.x|208|211 .args|165)) (begin (.check! (pair? .x|208|211) 1 .x|208|211) (cdr:pair .x|208|211)))) .regs|165 .regcontents|165 .newargs|165 .regbindings|165 .f|165))) (if (if .target-registers?|2 (if (variable? (let ((.x|219|222 .args|165)) (begin (.check! (pair? .x|219|222) 0 .x|219|222) (car:pair .x|219|222)))) (let* ((.x|226 (variable.name (let ((.x|238|241 .args|165)) (begin (.check! (pair? .x|238|241) 0 .x|238|241) (car:pair .x|238|241))))) (.temp|227|230 (.local-variable-not-used?|16 .x|226))) (if .temp|227|230 .temp|227|230 (if (memq .x|226 .regvars|15) (not (eq? .x|226 (let ((.x|234|237 .regcontents|165)) (begin (.check! (pair? .x|234|237) 0 .x|234|237) (car:pair .x|234|237))))) #f))) #f) #f) (let* ((.x|244 (variable.name (let ((.x|271|274 .args|165)) (begin (.check! (pair? .x|271|274) 0 .x|271|274) (car:pair .x|271|274))))) (.r|247 (let ((.x|267|270 .regs|165)) (begin (.check! (pair? .x|267|270) 0 .x|267|270) (car:pair .x|267|270)))) (.newarg|250 (make-variable .r|247))) (let () (begin (.used-variable!|16 .x|244) (.loop|164 (let ((.x|254|257 .args|165)) (begin (.check! (pair? .x|254|257) 1 .x|254|257) (cdr:pair .x|254|257))) (let ((.x|258|261 .regs|165)) (begin (.check! (pair? .x|258|261) 1 .x|258|261) (cdr:pair .x|258|261))) (let ((.x|262|265 .regcontents|165)) (begin (.check! (pair? .x|262|265) 1 .x|262|265) (cdr:pair .x|262|265))) (cons .newarg|250 .newargs|165) (cons (make-regbinding .r|247 .x|244 .newarg|250) .regbindings|165) (union (cons .r|247 '()) .f|165))))) (let ((.e1|278 (let ((.x|295|298 .args|165)) (begin (.check! (pair? .x|295|298) 0 .x|295|298) (car:pair .x|295|298))))) (.loop|164 (let ((.x|279|282 .args|165)) (begin (.check! (pair? .x|279|282) 1 .x|279|282) (cdr:pair .x|279|282))) (let ((.x|283|286 .regs|165)) (begin (.check! (pair? .x|283|286) 1 .x|283|286) (cdr:pair .x|283|286))) (let ((.x|287|290 .regcontents|165)) (begin (.check! (pair? .x|287|290) 1 .x|287|290) (cdr:pair .x|287|290))) (cons .e1|278 .newargs|165) .regbindings|165 (if (variable? .e1|278) (let ((.name|293 (variable.name .e1|278))) (begin (.used-variable!|16 .name|293) (union (cons .name|293 '()) .f|165))) .f|165))))))))) (.loop|164 .args|161 .regs|161 .regcontents|161 .newargs|161 .regbindings|161 .f|161))))))) (if (call? .e|17) (let* ((.e0|331 (call.proc .e|17)) (.f0|334 (variable.name .e0|331))) (let () (let ((.args|340 (call.args .e|17)) (.newargs|340 '()) (.f|340 (cons .f0|334 '()))) (let () (let ((.loop|343 (unspecified))) (begin (set! .loop|343 (lambda (.args|344 .newargs|344 .f|344) (if (null? .args|344) (let* ((.e|348 (make-call .e0|331 (reverse .newargs|344))) (.t|351 (if .commoning?|2 (available-expression .available|17 .e|348) #f))) (let () (if .t|351 (begin (.abandon-expression!|16 .e|348) (.scan-rhs|16 (make-variable .t|351) .env|17 .available|17)) (begin (available-kill! .available|17 (prim-kills (prim-entry .f0|334))) (if (eq? .f0|334 name:check!) (let ((.x|358 (let ((.x|363|366 (call.args .e|348))) (begin (.check! (pair? .x|363|366) 0 .x|363|366) (car:pair .x|363|366))))) (if (not (runtime-safety-checking)) (begin (.abandon-expression!|16 .e|348) (.scan-rhs|16 .x|358 .env|17 .available|17)) (if (variable? .x|358) (begin (.available-add!|16 .available|17 (variable.name .x|358) (make-constant #t)) (values .e|348 .f|344 '())) (if (constant.value .x|358) (begin (.abandon-expression!|16 .e|348) (values .x|358 '() '())) (begin (declaration-error .e|348) (values .e|348 .f|344 '())))))) (values .e|348 .f|344 '())))))) (if (variable? (let ((.x|371|374 .args|344)) (begin (.check! (pair? .x|371|374) 0 .x|371|374) (car:pair .x|371|374)))) (let* ((.e1|377 (let ((.x|402|405 .args|344)) (begin (.check! (pair? .x|402|405) 0 .x|402|405) (car:pair .x|402|405)))) (.x|380 (variable.name .e1|377)) (.enew|383 (if .commoning?|2 (available-variable .available|17 .x|380) #f))) (let () (if .enew|383 (.loop|343 (cons .enew|383 (let ((.x|387|390 .args|344)) (begin (.check! (pair? .x|387|390) 1 .x|387|390) (cdr:pair .x|387|390)))) .newargs|344 (remq .x|380 .f|344)) (begin (.used-variable!|16 .x|380) (.loop|343 (let ((.x|391|394 .args|344)) (begin (.check! (pair? .x|391|394) 1 .x|391|394) (cdr:pair .x|391|394))) (cons (let ((.x|395|398 .args|344)) (begin (.check! (pair? .x|395|398) 0 .x|395|398) (car:pair .x|395|398))) .newargs|344) (union (cons .x|380 '()) .f|344)))))) (.loop|343 (let ((.x|407|410 .args|344)) (begin (.check! (pair? .x|407|410) 1 .x|407|410) (cdr:pair .x|407|410))) (cons (let ((.x|411|414 .args|344)) (begin (.check! (pair? .x|411|414) 0 .x|411|414) (car:pair .x|411|414))) .newargs|344) .f|344))))) (.loop|343 .args|340 .newargs|340 .f|340))))))) (.error|14 'scan-rhs (make-readable .e|17)))))))))))) (set! .scan-defs|16 (lambda (.l|417 .env|417 .available|417) (let ((.defs|420 (lambda.defs .l|417)) (.newdefs|420 '()) (.fdefs|420 '())) (let () (let ((.loop|423 (unspecified))) (begin (set! .loop|423 (lambda (.defs|424 .newdefs|424 .fdefs|424) (if (null? .defs|424) (begin (lambda.defs-set! .l|417 (reverse .newdefs|424)) .fdefs|424) (let ((.def|427 (let ((.x|470|473 .defs|424)) (begin (.check! (pair? .x|470|473) 0 .x|470|473) (car:pair .x|470|473))))) (call-with-values (lambda () (let* ((.ldef|431 (def.rhs .def|427)) (.lformals|434 (make-null-terminated (lambda.args .ldef|431))) (.lenv|437 (.environment-extend*|16 (.environment-extend*|16 .env|417 .lformals|434) (let () (let ((.loop|446|449|452 (unspecified))) (begin (set! .loop|446|449|452 (lambda (.y1|441|442|453 .results|441|445|453) (if (null? .y1|441|442|453) (reverse .results|441|445|453) (begin #t (.loop|446|449|452 (let ((.x|457|460 .y1|441|442|453)) (begin (.check! (pair? .x|457|460) 1 .x|457|460) (cdr:pair .x|457|460))) (cons (def.lhs (let ((.x|461|464 .y1|441|442|453)) (begin (.check! (pair? .x|461|464) 0 .x|461|464) (car:pair .x|461|464)))) .results|441|445|453)))))) (.loop|446|449|452 (lambda.defs .ldef|431) '()))))))) (let () (.scan|16 .ldef|431 .lenv|437 .available|417)))) (lambda (.rhs|465 .frhs|465 .empty|465) (begin (if (not (null? .empty|465)) (.error|14 'scan-binding 'def) (unspecified)) (.loop|423 (let ((.x|466|469 .defs|424)) (begin (.check! (pair? .x|466|469) 1 .x|466|469) (cdr:pair .x|466|469))) (cons (make-definition (def.lhs .def|427) .rhs|465) .newdefs|424) (union .frhs|465 .fdefs|424))))))))) (.loop|423 .defs|420 .newdefs|420 .fdefs|420))))))) (set! .scan-let0|16 (lambda (.e|474 .env|474 .available|474) (let ((.l|477 (call.proc .e|474))) (if (simple-lambda? .l|477) (.scan|16 (lambda.body .l|477) .env|474 .available|474) (let ((.t1|480 (make-variable name:ignored))) (begin (lambda.args-set! .l|477 (cons .t1|480 '())) (call-with-values (lambda () (.scan|16 (make-call .l|477 (cons (make-constant 0) '())) .env|474 .available|474)) (lambda (.e|484 .f|484 .regbindings|484) (begin (lambda.args-set! .l|477 '()) (values (make-call .l|477 '()) .f|484 .regbindings|484)))))))))) (set! .scan-binding-phase3|16 (lambda (.l|485 .e0|485 .e1|485 .f|485 .f1|485 .regbindings0|485 .regbindings1|485) (let* ((.args|488 (lambda.args .l|485)) (.t1|491 (let ((.x|517|520 .args|488)) (begin (.check! (pair? .x|517|520) 0 .x|517|520) (car:pair .x|517|520)))) (.free|494 (union .f1|485 (difference .f|485 .args|488))) (.simple-let?|497 (simple-lambda? .l|485)) (.regbindings|500 (if (null? .regbindings0|485) .regbindings1|485 (if (null? .regbindings1|485) .regbindings0|485 (.error|14 'scan-binding 'regbindings))))) (let () (begin (lambda.body-set! .l|485 .e0|485) (lambda.f-set! .l|485 .f|485) (lambda.g-set! .l|485 .f|485) (if (if .simple-let?|497 (if (not (memq .t1|491 .f|485)) (no-side-effects? .e1|485) #f) #f) (begin (.abandon-expression!|16 .e1|485) (values .e0|485 .f|485 .regbindings0|485)) (if (if .target-registers?|2 (if .simple-let?|497 (.local-variable-used-once?|16 .t1|491) #f) #f) (post-simplify-anf .l|485 .t1|491 .e0|485 .e1|485 .free|494 .regbindings|500 #f) (values (make-call .l|485 (cons .e1|485 '())) .free|494 .regbindings|500)))))))) (set! .scan-binding-phase2|16 (lambda (.l|521 .t1|521 .e0|521 .e1|521 .f0|521 .f1|521 .fdefs|521 .regbindings0|521 .regbindings1|521) (let ((.phase2e|522 (unspecified)) (.phase2d|522 (unspecified)) (.phase2c|522 (unspecified)) (.phase2b|522 (unspecified)) (.phase2a|522 (unspecified))) (begin (set! .phase2e|522 (lambda (.towrap|523 .regbindings0|523) (call-with-values (lambda () (wrap-with-register-bindings .towrap|523 .e0|521 .f0|521)) (lambda (.e0|525 .f0|525) (let ((.f|528 (union .fdefs|521 .f0|525))) (.scan-binding-phase3|16 .l|521 .e0|525 .e1|521 .f|528 .f1|521 .regbindings0|523 .regbindings1|521)))))) (set! .phase2d|522 (lambda (.towrap|529 .regbindings-t1|529 .regbindings0|529) (begin (if (not (null? (let ((.x|530|533 .regbindings-t1|529)) (begin (.check! (pair? .x|530|533) 1 .x|530|533) (cdr:pair .x|530|533))))) (.error|14 "incorrect number of uses" .t1|521) (unspecified)) (let* ((.regbinding|536 (let ((.x|544|547 .regbindings-t1|529)) (begin (.check! (pair? .x|544|547) 0 .x|544|547) (car:pair .x|544|547)))) (.r|539 (regbinding.lhs .regbinding|536))) (let () (begin (lambda.args-set! .l|521 (cons .r|539 '())) (.phase2e|522 .towrap|529 .regbindings0|529))))))) (set! .phase2c|522 (lambda (.towrap|548 .rb1|548 .regbindings0|548) (if (if (not (null? .rb1|548)) (.local-variable-used-once?|16 .t1|521) #f) (.phase2d|522 .towrap|548 .rb1|548 .regbindings0|548) (.phase2e|522 (append .rb1|548 .towrap|548) .regbindings0|548)))) (set! .phase2b|522 (lambda (.rb1|553 .rb2|553 .rb3|553) (if (let ((.temp|554|557 (conditional? .e1|521))) (if .temp|554|557 .temp|554|557 (real-call? .e1|521))) (.phase2c|522 (append .rb2|553 .rb3|553) .rb1|553 '()) (.phase2c|522 .rb2|553 .rb1|553 .rb3|553)))) (set! .phase2a|522 (lambda () (let () (let ((.loop|560|564|567 (unspecified))) (begin (set! .loop|560|564|567 (lambda (.rvars|568 .regs|568 .regs1|568) (if (let ((.temp|570|573 (null? .rvars|568))) (if .temp|570|573 .temp|570|573 (null? .regs|568))) (let ((.regbindings|577 .regbindings0|521) (.rb1|577 '()) (.rb2|577 '()) (.rb3|577 '())) (let () (let ((.loop|580 (unspecified))) (begin (set! .loop|580 (lambda (.regbindings|581 .rb1|581 .rb2|581 .rb3|581) (if (null? .regbindings|581) (.phase2b|522 .rb1|581 .rb2|581 .rb3|581) (let* ((.binding|584 (let ((.x|604|607 .regbindings|581)) (begin (.check! (pair? .x|604|607) 0 .x|604|607) (car:pair .x|604|607)))) (.regbindings|587 (let ((.x|600|603 .regbindings|581)) (begin (.check! (pair? .x|600|603) 1 .x|600|603) (cdr:pair .x|600|603)))) (.lhs|590 (regbinding.lhs .binding|584)) (.rhs|593 (regbinding.rhs .binding|584))) (let () (if (eq? .rhs|593 .t1|521) (.loop|580 .regbindings|587 (cons .binding|584 .rb1|581) .rb2|581 .rb3|581) (if (memq .lhs|590 .regs1|568) (.loop|580 .regbindings|587 .rb1|581 (cons .binding|584 .rb2|581) .rb3|581) (.loop|580 .regbindings|587 .rb1|581 .rb2|581 (cons .binding|584 .rb3|581))))))))) (.loop|580 .regbindings|577 .rb1|577 .rb2|577 .rb3|577))))) (begin #t (.loop|560|564|567 (let ((.x|609|612 .rvars|568)) (begin (.check! (pair? .x|609|612) 1 .x|609|612) (cdr:pair .x|609|612))) (let ((.x|613|616 .regs|568)) (begin (.check! (pair? .x|613|616) 1 .x|613|616) (cdr:pair .x|613|616))) (if (memq (let ((.x|617|620 .rvars|568)) (begin (.check! (pair? .x|617|620) 0 .x|617|620) (car:pair .x|617|620))) .f1|521) (cons (let ((.x|621|624 .regs|568)) (begin (.check! (pair? .x|621|624) 0 .x|621|624) (car:pair .x|621|624))) .regs1|568) .regs1|568)))))) (.loop|560|564|567 .regvars|15 argument-registers '())))))) (.phase2a|522))))) (set! .scan-binding|16 (lambda (.e|625 .env|625 .available|625) (let* ((.l|628 (call.proc .e|625)) (.t1|631 (let ((.x|685|688 (lambda.args .l|628))) (begin (.check! (pair? .x|685|688) 0 .x|685|688) (car:pair .x|685|688)))) (.e1|634 (let ((.x|681|684 (call.args .e|625))) (begin (.check! (pair? .x|681|684) 0 .x|681|684) (car:pair .x|681|684)))) (.e0|637 (lambda.body .l|628))) (let () (begin (.record-local-variable!|16 .t1|631) (call-with-values (lambda () (.scan-rhs|16 .e1|634 .env|625 .available|625)) (lambda (.e1|642 .f1|642 .regbindings1|642) (begin (.available-add!|16 .available|625 .t1|631 .e1|642) (let* ((.env|645 (let ((.formals|656 (make-null-terminated (lambda.args .l|628)))) (.environment-extend*|16 (.environment-extend*|16 .env|625 .formals|656) (let () (let ((.loop|662|665|668 (unspecified))) (begin (set! .loop|662|665|668 (lambda (.y1|657|658|669 .results|657|661|669) (if (null? .y1|657|658|669) (reverse .results|657|661|669) (begin #t (.loop|662|665|668 (let ((.x|673|676 .y1|657|658|669)) (begin (.check! (pair? .x|673|676) 1 .x|673|676) (cdr:pair .x|673|676))) (cons (def.lhs (let ((.x|677|680 .y1|657|658|669)) (begin (.check! (pair? .x|677|680) 0 .x|677|680) (car:pair .x|677|680)))) .results|657|661|669)))))) (.loop|662|665|668 (lambda.defs .l|628) '()))))))) (.fdefs|648 (.scan-defs|16 .l|628 .env|645 .available|625))) (let () (call-with-values (lambda () (.scan|16 .e0|637 .env|645 .available|625)) (lambda (.e0|653 .f0|653 .regbindings0|653) (begin (lambda.body-set! .l|628 .e0|653) (if .target-registers?|2 (.scan-binding-phase2|16 .l|628 .t1|631 .e0|653 .e1|642 .f0|653 .f1|642 .fdefs|648 .regbindings0|653 .regbindings1|642) (.scan-binding-phase3|16 .l|628 .e0|653 .e1|642 (union .f0|653 .fdefs|648) .f1|642 .regbindings0|653 .regbindings1|642))))))))))))))) (set! .scan|16 (lambda (.e|689 .env|689 .available|689) (if (not (call? .e|689)) (.scan-rhs|16 .e|689 .env|689 .available|689) (let ((.proc|692 (call.proc .e|689))) (if (not (lambda? .proc|692)) (.scan-rhs|16 .e|689 .env|689 .available|689) (let ((.vars|695 (lambda.args .proc|692))) (if (null? .vars|695) (.scan-let0|16 .e|689 .env|689 .available|689) (if (null? (let ((.x|698|701 .vars|695)) (begin (.check! (pair? .x|698|701) 1 .x|698|701) (cdr:pair .x|698|701)))) (.scan-binding|16 .e|689 .env|689 .available|689) (.error|14 (make-readable .e|689)))))))))) (set! .available-add!|16 (lambda (.available|703 .t|703 .e|703) (if (constant? .e|703) (available-extend! .available|703 .t|703 .e|703 available:killer:immortal) (if (variable? .e|703) (available-extend! .available|703 .t|703 .e|703 (if (.global?|16 (variable.name .e|703)) available:killer:globals available:killer:immortal)) (let ((.entry|709 (prim-call .e|703))) (if .entry|709 (let ((.killer|712 (prim-lives-until .entry|709))) (if (not (eq? .killer|712 available:killer:dead)) (let () (let ((.loop|713|716|719 (unspecified))) (begin (set! .loop|713|716|719 (lambda (.args|720 .k|720) (if (null? .args|720) (available-extend! .available|703 .t|703 .e|703 (logior .killer|712 .k|720)) (begin #t (.loop|713|716|719 (let ((.x|723|726 .args|720)) (begin (.check! (pair? .x|723|726) 1 .x|723|726) (cdr:pair .x|723|726))) (let ((.arg|729 (let ((.x|732|735 .args|720)) (begin (.check! (pair? .x|732|735) 0 .x|732|735) (car:pair .x|732|735))))) (if (if (variable? .arg|729) (.global?|16 (variable.name .arg|729)) #f) available:killer:globals .k|720))))))) (.loop|713|716|719 (call.args .e|703) .killer|712)))) (unspecified))) (unspecified))))))) (set! .global?|16 (lambda (.x|736) (if (.local-variable?|16 .x|736) #f (if (.environment-lookup|16 .env|15 .x|736) #f #t)))) (set! .environment-lookup|16 (lambda (.env|740 .sym|740) (hashtree-get .env|740 .sym|740))) (set! .environment-extend*|16 (lambda (.env|741 .symbols|741) (if (null? .symbols|741) .env|741 (.environment-extend*|16 (hashtree-put .env|741 (let ((.x|742|745 .symbols|741)) (begin (.check! (pair? .x|742|745) 0 .x|742|745) (car:pair .x|742|745))) #t) (let ((.x|746|749 .symbols|741)) (begin (.check! (pair? .x|746|749) 1 .x|746|749) (cdr:pair .x|746|749))))))) (set! .environment-extend|16 (lambda (.env|750 .sym|750) (hashtree-put .env|750 .sym|750 #t))) (set! .make-empty-environment|16 (lambda () (make-hashtree symbol-hash assq))) (set! .abandon-expression!|16 (lambda (.e|752) (if (variable? .e|752) (.adjust-local-variable!|16 (variable.name .e|752) -1) (if (conditional? .e|752) (begin (.abandon-expression!|16 (if.test .e|752)) (.abandon-expression!|16 (if.then .e|752)) (.abandon-expression!|16 (if.else .e|752))) (if (call? .e|752) (let () (let ((.loop|761|763|766 (unspecified))) (begin (set! .loop|761|763|766 (lambda (.y1|756|757|767) (if (null? .y1|756|757|767) (if #f #f (unspecified)) (begin (begin #t (let ((.exp|771 (let ((.x|775|778 .y1|756|757|767)) (begin (.check! (pair? .x|775|778) 0 .x|775|778) (car:pair .x|775|778))))) (if (variable? .exp|771) (let ((.name|774 (variable.name .exp|771))) (if (.local-variable?|16 .name|774) (.adjust-local-variable!|16 .name|774 -1) (unspecified))) (unspecified)))) (.loop|761|763|766 (let ((.x|779|782 .y1|756|757|767)) (begin (.check! (pair? .x|779|782) 1 .x|779|782) (cdr:pair .x|779|782)))))))) (.loop|761|763|766 (cons (call.proc .e|752) (call.args .e|752)))))) (unspecified)))))) (set! .used-variable!|16 (lambda (.sym|783) (.used-local-variable!|16 .sym|783))) (set! .closed-over-local-variable!|16 (lambda (.sym|784) (hashtable-put! .local-variables|16 .sym|784 1000000))) (set! .adjust-local-variable!|16 (lambda (.sym|785 .n|785) (let ((.m|788 (hashtable-get .local-variables|16 .sym|785))) (begin (if .debugging?|2 (if (if .m|788 (> .m|788 0) #f) (begin (write (let* ((.t1|791|794 .sym|785) (.t2|791|797 (cons (+ .m|788 .n|785) '()))) (let () (cons .t1|791|794 .t2|791|797)))) (newline)) (unspecified)) (unspecified)) (if .m|788 (hashtable-put! .local-variables|16 .sym|785 (+ .m|788 .n|785)) (unspecified)))))) (set! .used-local-variable!|16 (lambda (.sym|802) (.adjust-local-variable!|16 .sym|802 1))) (set! .record-local-variable!|16 (lambda (.sym|803) (hashtable-put! .local-variables|16 .sym|803 0))) (set! .local-variable-used-once?|16 (lambda (.sym|804) (= 1 (hashtable-fetch .local-variables|16 .sym|804 0)))) (set! .local-variable-not-used?|16 (lambda (.sym|805) (= 0 (hashtable-fetch .local-variables|16 .sym|805 -1)))) (set! .local-variable?|16 (lambda (.sym|806) (hashtable-get .local-variables|16 .sym|806))) (set! .local-variables|16 (make-hashtable symbol-hash assq)) (call-with-values (lambda () (.scan|16 .e|15 .env|15 .available|15)) (lambda (.e|808 .f|808 .regbindings|808) (call-with-values (lambda () (wrap-with-register-bindings .regbindings|808 .e|808 .f|808)) (lambda (.e|810 .f|810) (values .e|810 .f|810 '()))))))))) (set! .error|14 (lambda .stuff|811 (begin (display "Bug detected during intraprocedural optimization") (newline) (let ((.f|812|815|818 (lambda (.s|838) (begin (display .s|838) (newline))))) (let () (let ((.loop|820|822|825 (unspecified))) (begin (set! .loop|820|822|825 (lambda (.y1|812|813|826) (if (null? .y1|812|813|826) (if #f #f (unspecified)) (begin (begin #t (.f|812|815|818 (let ((.x|830|833 .y1|812|813|826)) (begin (.check! (pair? .x|830|833) 0 .x|830|833) (car:pair .x|830|833))))) (.loop|820|822|825 (let ((.x|834|837 .y1|812|813|826)) (begin (.check! (pair? .x|834|837) 1 .x|834|837) (cdr:pair .x|834|837)))))))) (.loop|820|822|825 .stuff|811))))) (.return|13 (make-constant #f))))) (call-with-values (lambda () (.scan-body|14 .e|1 (make-hashtree symbol-hash assq) (make-available-table) '())) (lambda (.e|840 .f|840 .regbindings|840) (begin (if (not (null? .regbindings|840)) (.error|14 'scan-body) (unspecified)) .e|840))))))))))) 'intraprocedural-commoning))
(let () (begin (set! representation-analysis (lambda (.exp|1) (let ((.representation-analysis|2 0)) (begin (set! .representation-analysis|2 (lambda (.exp|3) (let* ((.debugging?|6 #f) (.integrate-usual?|9 (integrate-usual-procedures)) (.known|12 (make-hashtable symbol-hash assq)) (.types|15 (make-hashtable symbol-hash assq)) (.g|18 (callgraph .exp|3)) (.schedule|21 (cons (callgraphnode.code (let ((.x|734|737 .g|18)) (begin (.check! (pair? .x|734|737) 0 .x|734|737) (car:pair .x|734|737)))) '())) (.changed?|24 #f) (.mutate?|27 #f)) (let () (let ((.display-all-types|31 (unspecified)) (.display-types|31 (unspecified)) (.analyze-unknown-lambda|31 (unspecified)) (.analyze-known-local-procedure|31 (unspecified)) (.analyze-unknown-call|31 (unspecified)) (.analyze-known-call|31 (unspecified)) (.analyze-primop-call|31 (unspecified)) (.analyze-let1|31 (unspecified)) (.analyze-let0|31 (unspecified)) (.analyze|31 (unspecified)) (.lookup-node|31 (unspecified)) (.lookup-code|31 (unspecified)) (.update-typevar!|31 (unspecified)) (.known-procedure-is-callable?|31 (unspecified)) (.schedule-local-procedures!|31 (unspecified)) (.schedule-callers!|31 (unspecified)) (.schedule-known-procedure!|31 (unspecified)) (.schedule!|31 (unspecified))) (begin (set! .display-all-types|31 (lambda () (let* ((.vars|35 (hashtable-map (lambda (.x|70 .type|70) .x|70) .types|15)) (.vars|38 (twobit-sort (lambda (.var1|69 .var2|69) (string<=? (symbol->string .var1|69) (symbol->string .var2|69))) .vars|35))) (let () (let ((.f|42|45|48 (lambda (.x|68) (begin (write .x|68) (display ": ") (write (rep->symbol (hashtable-get .types|15 .x|68))) (newline))))) (let () (let ((.loop|50|52|55 (unspecified))) (begin (set! .loop|50|52|55 (lambda (.y1|42|43|56) (if (null? .y1|42|43|56) (if #f #f (unspecified)) (begin (begin #t (.f|42|45|48 (let ((.x|60|63 .y1|42|43|56)) (begin (.check! (pair? .x|60|63) 0 .x|60|63) (car:pair .x|60|63))))) (.loop|50|52|55 (let ((.x|64|67 .y1|42|43|56)) (begin (.check! (pair? .x|64|67) 1 .x|64|67) (cdr:pair .x|64|67)))))))) (.loop|50|52|55 .vars|38))))))))) (set! .display-types|31 (lambda () (hashtable-for-each (lambda (.f|72 .vars|72) (begin (write .f|72) (display " : returns ") (write (rep->symbol (hashtable-get .types|15 .f|72))) (newline) (let ((.f|73|76|79 (lambda (.x|99) (begin (display "  ") (write .x|99) (display ": ") (write (rep->symbol (hashtable-get .types|15 .x|99))) (newline))))) (let () (let ((.loop|81|83|86 (unspecified))) (begin (set! .loop|81|83|86 (lambda (.y1|73|74|87) (if (null? .y1|73|74|87) (if #f #f (unspecified)) (begin (begin #t (.f|73|76|79 (let ((.x|91|94 .y1|73|74|87)) (begin (.check! (pair? .x|91|94) 0 .x|91|94) (car:pair .x|91|94))))) (.loop|81|83|86 (let ((.x|95|98 .y1|73|74|87)) (begin (.check! (pair? .x|95|98) 1 .x|95|98) (cdr:pair .x|95|98)))))))) (.loop|81|83|86 .vars|72))))))) .known|12))) (set! .analyze-unknown-lambda|31 (lambda (.l|100) (begin (if .debugging?|6 (begin (display "Analyzing escaping lambda expression") (newline)) (unspecified)) (.schedule-local-procedures!|31 .l|100) (let ((.vars|103 (make-null-terminated (lambda.args .l|100)))) (begin (let () (let ((.loop|109|111|114 (unspecified))) (begin (set! .loop|109|111|114 (lambda (.y1|104|105|115) (if (null? .y1|104|105|115) (if #f #f (unspecified)) (begin (begin #t (let ((.var|119 (let ((.x|120|123 .y1|104|105|115)) (begin (.check! (pair? .x|120|123) 0 .x|120|123) (car:pair .x|120|123))))) (hashtable-put! .types|15 .var|119 rep:object))) (.loop|109|111|114 (let ((.x|124|127 .y1|104|105|115)) (begin (.check! (pair? .x|124|127) 1 .x|124|127) (cdr:pair .x|124|127)))))))) (.loop|109|111|114 .vars|103)))) (.analyze|31 (lambda.body .l|100) (make-constraints-table))))))) (set! .analyze-known-local-procedure|31 (lambda (.name|128) (begin (if .debugging?|6 (begin (display "Analyzing ") (display .name|128) (newline)) (unspecified)) (let ((.l|131 (.lookup-code|31 .name|128)) (.constraints|131 (make-constraints-table))) (begin (.schedule-local-procedures!|31 .l|131) (let ((.type|134 (.analyze|31 (lambda.body .l|131) .constraints|131))) (begin (if (.update-typevar!|31 .name|128 .type|134) (.schedule-callers!|31 .name|128) (unspecified)) .type|134))))))) (set! .analyze-unknown-call|31 (lambda (.exp|135 .constraints|135) (begin (.analyze|31 (call.proc .exp|135) .constraints|135) (let () (let ((.loop|141|143|146 (unspecified))) (begin (set! .loop|141|143|146 (lambda (.y1|136|137|147) (if (null? .y1|136|137|147) (if #f #f (unspecified)) (begin (begin #t (let ((.arg|151 (let ((.x|152|155 .y1|136|137|147)) (begin (.check! (pair? .x|152|155) 0 .x|152|155) (car:pair .x|152|155))))) (.analyze|31 .arg|151 .constraints|135))) (.loop|141|143|146 (let ((.x|156|159 .y1|136|137|147)) (begin (.check! (pair? .x|156|159) 1 .x|156|159) (cdr:pair .x|156|159)))))))) (.loop|141|143|146 (call.args .exp|135))))) (constraints-kill! .constraints|135 available:killer:all) rep:object))) (set! .analyze-known-call|31 (lambda (.exp|160 .constraints|160 .vars|160) (let* ((.procname|163 (variable.name (call.proc .exp|160))) (.args|166 (call.args .exp|160)) (.argtypes|169 (let () (let ((.loop|216|219|222 (unspecified))) (begin (set! .loop|216|219|222 (lambda (.y1|211|212|223 .results|211|215|223) (if (null? .y1|211|212|223) (reverse .results|211|215|223) (begin #t (.loop|216|219|222 (let ((.x|227|230 .y1|211|212|223)) (begin (.check! (pair? .x|227|230) 1 .x|227|230) (cdr:pair .x|227|230))) (cons (let ((.arg|231 (let ((.x|232|235 .y1|211|212|223)) (begin (.check! (pair? .x|232|235) 0 .x|232|235) (car:pair .x|232|235))))) (.analyze|31 .arg|231 .constraints|160)) .results|211|215|223)))))) (.loop|216|219|222 .args|166 '())))))) (let () (begin (if (not (.known-procedure-is-callable?|31 .procname|163)) (.schedule-known-procedure!|31 .procname|163) (unspecified)) (let () (let ((.loop|179|182|185 (unspecified))) (begin (set! .loop|179|182|185 (lambda (.y1|173|175|186 .y1|173|174|186) (if (let ((.temp|188|191 (null? .y1|173|175|186))) (if .temp|188|191 .temp|188|191 (null? .y1|173|174|186))) (if #f #f (unspecified)) (begin (begin #t (let ((.var|194 (let ((.x|195|198 .y1|173|175|186)) (begin (.check! (pair? .x|195|198) 0 .x|195|198) (car:pair .x|195|198)))) (.type|194 (let ((.x|199|202 .y1|173|174|186)) (begin (.check! (pair? .x|199|202) 0 .x|199|202) (car:pair .x|199|202))))) (if (.update-typevar!|31 .var|194 .type|194) (.schedule-known-procedure!|31 .procname|163) (unspecified)))) (.loop|179|182|185 (let ((.x|203|206 .y1|173|175|186)) (begin (.check! (pair? .x|203|206) 1 .x|203|206) (cdr:pair .x|203|206))) (let ((.x|207|210 .y1|173|174|186)) (begin (.check! (pair? .x|207|210) 1 .x|207|210) (cdr:pair .x|207|210)))))))) (.loop|179|182|185 .vars|160 .argtypes|169)))) (constraints-kill! .constraints|160 available:killer:all) (hashtable-get .types|15 .procname|163)))))) (set! .analyze-primop-call|31 (lambda (.exp|236 .constraints|236 .entry|236) (let* ((.op|239 (prim-opcodename .entry|236)) (.args|242 (call.args .exp|236)) (.argtypes|245 (let () (let ((.loop|293|296|299 (unspecified))) (begin (set! .loop|293|296|299 (lambda (.y1|288|289|300 .results|288|292|300) (if (null? .y1|288|289|300) (reverse .results|288|292|300) (begin #t (.loop|293|296|299 (let ((.x|304|307 .y1|288|289|300)) (begin (.check! (pair? .x|304|307) 1 .x|304|307) (cdr:pair .x|304|307))) (cons (let ((.arg|308 (let ((.x|309|312 .y1|288|289|300)) (begin (.check! (pair? .x|309|312) 0 .x|309|312) (car:pair .x|309|312))))) (.analyze|31 .arg|308 .constraints|236)) .results|288|292|300)))))) (.loop|293|296|299 .args|242 '()))))) (.type|248 (rep-result? .op|239 .argtypes|245))) (let () (begin (constraints-kill! .constraints|236 (prim-kills .entry|236)) (if (if (eq? .op|239 'check!) (variable? (let ((.x|255|258 .args|242)) (begin (.check! (pair? .x|255|258) 0 .x|255|258) (car:pair .x|255|258)))) #f) (let ((.varname|261 (variable.name (let ((.x|272|275 .args|242)) (begin (.check! (pair? .x|272|275) 0 .x|272|275) (car:pair .x|272|275)))))) (begin (if (if .mutate?|27 (representation-subtype? (let ((.x|264|267 .argtypes|245)) (begin (.check! (pair? .x|264|267) 0 .x|264|267) (car:pair .x|264|267))) rep:true) #f) (call.args-set! .exp|236 (cons (make-constant #t) (let ((.x|268|271 .args|242)) (begin (.check! (pair? .x|268|271) 1 .x|268|271) (cdr:pair .x|268|271))))) (unspecified)) (constraints-add! .types|15 .constraints|236 (make-type-constraint .varname|261 rep:true available:killer:immortal)))) (let ((.temp|276|279 (if .mutate?|27 (rep-specific? .op|239 .argtypes|245) #f))) (if .temp|276|279 (let ((.newop|280 .temp|276|279)) (call.proc-set! .exp|236 (make-variable .newop|280))) (unspecified)))) (let ((.temp|283|286 .type|248)) (if .temp|283|286 .temp|283|286 rep:object))))))) (set! .analyze-let1|31 (lambda (.exp|313 .constraints|313) (let* ((.proc|316 (call.proc .exp|313)) (.vars|319 (lambda.args .proc|316))) (let () (begin (.schedule-local-procedures!|31 .proc|316) (if (if (pair? .vars|319) (null? (let ((.x|325|328 .vars|319)) (begin (.check! (pair? .x|325|328) 1 .x|325|328) (cdr:pair .x|325|328)))) #f) (let* ((.t1|331 (let ((.x|359|362 .vars|319)) (begin (.check! (pair? .x|359|362) 0 .x|359|362) (car:pair .x|359|362)))) (.e1|334 (let ((.x|355|358 (call.args .exp|313))) (begin (.check! (pair? .x|355|358) 0 .x|355|358) (car:pair .x|355|358))))) (let () (begin (if (if .integrate-usual?|9 (call? .e1|334) #f) (let ((.proc|342 (call.proc .e1|334)) (.args|342 (call.args .e1|334))) (if (variable? .proc|342) (let* ((.op|345 (variable.name .proc|342)) (.entry|348 (prim-entry .op|345)) (.k1|351 (if .entry|348 (prim-lives-until .entry|348) available:killer:dead))) (let () (if (not (= .k1|351 available:killer:dead)) (constraints-add! .types|15 .constraints|313 (make-constraint .t1|331 (make-call .proc|342 .args|342) .k1|351)) (unspecified)))) (unspecified))) (unspecified)) (.update-typevar!|31 .t1|331 (.analyze|31 .e1|334 .constraints|313)) (.analyze|31 (lambda.body .proc|316) .constraints|313)))) (.analyze-unknown-call|31 .exp|313 .constraints|313))))))) (set! .analyze-let0|31 (lambda (.exp|363 .constraints|363) (let ((.proc|366 (call.proc .exp|363))) (begin (.schedule-local-procedures!|31 .proc|366) (if (null? (lambda.args .proc|366)) (.analyze|31 (lambda.body .exp|363) .constraints|363) (.analyze-unknown-call|31 .exp|363 .constraints|363)))))) (set! .analyze|31 (lambda (.exp|367 .constraints|367) (begin (if (if #f .debugging?|6 #f) (begin (display "Analyzing: ") (newline) (pretty-print (make-readable .exp|367 #t)) (newline)) (unspecified)) (let ((.temp|370|373 (let ((.x|463|466 .exp|367)) (begin (.check! (pair? .x|463|466) 0 .x|463|466) (car:pair .x|463|466))))) (if (memv .temp|370|373 '(quote)) (representation-of-value (constant.value .exp|367)) (if (memv .temp|370|373 '(begin)) (let ((.name|378 (variable.name .exp|367))) (let () (representation-typeof .name|378 .types|15 .constraints|367))) (if (memv .temp|370|373 '(lambda)) (begin (.schedule!|31 .exp|367) rep:procedure) (if (memv .temp|370|373 '(set!)) (begin (.analyze|31 (assignment.rhs .exp|367) .constraints|367) (constraints-kill! .constraints|367 available:killer:globals) rep:object) (if (memv .temp|370|373 '(if)) (let* ((.e0|387 (if.test .exp|367)) (.e1|390 (if.then .exp|367)) (.e2|393 (if.else .exp|367)) (.type0|396 (.analyze|31 .e0|387 .constraints|367))) (let () (begin (if .mutate?|27 (if (representation-subtype? .type0|396 rep:true) (if.test-set! .exp|367 (make-constant #t)) (if (representation-subtype? .type0|396 rep:false) (if.test-set! .exp|367 (make-constant #f)) (unspecified))) (unspecified)) (if (representation-subtype? .type0|396 rep:true) (.analyze|31 .e1|390 .constraints|367) (if (representation-subtype? .type0|396 rep:false) (.analyze|31 .e2|393 .constraints|367) (if (variable? .e0|387) (let* ((.t0|407 (variable.name .e0|387)) (.ignored|410 (.analyze|31 .e0|387 .constraints|367)) (.constraints1|413 (copy-constraints-table .constraints|367)) (.constraints2|416 (copy-constraints-table .constraints|367))) (let () (begin (constraints-add! .types|15 .constraints1|413 (make-type-constraint .t0|407 rep:true available:killer:immortal)) (constraints-add! .types|15 .constraints2|416 (make-type-constraint .t0|407 rep:false available:killer:immortal)) (let* ((.type1|422 (.analyze|31 .e1|390 .constraints1|413)) (.type2|425 (.analyze|31 .e2|393 .constraints2|416)) (.type|428 (representation-union .type1|422 .type2|425))) (let () (begin (constraints-intersect! .constraints|367 .constraints1|413 .constraints2|416) .type|428)))))) (representation-error "Bad ANF" (make-readable .exp|367 #t)))))))) (let ((.proc|436 (call.proc .exp|367)) (.args|436 (call.args .exp|367))) (if (lambda? .proc|436) (if (null? .args|436) (.analyze-let0|31 .exp|367 .constraints|367) (if (null? (let ((.x|440|443 .args|436)) (begin (.check! (pair? .x|440|443) 1 .x|440|443) (cdr:pair .x|440|443)))) (.analyze-let1|31 .exp|367 .constraints|367) (error "Compiler bug: pass3rep"))) (if (variable? .proc|436) (let ((.procname|448 (variable.name .proc|436))) (let () (let ((.temp|452|455 (hashtable-get .known|12 .procname|448))) (if .temp|452|455 (let ((.vars|456 .temp|452|455)) (.analyze-known-call|31 .exp|367 .constraints|367 .vars|456)) (if .integrate-usual?|9 (let ((.entry|460 (prim-entry .procname|448))) (if .entry|460 (.analyze-primop-call|31 .exp|367 .constraints|367 .entry|460) (.analyze-unknown-call|31 .exp|367 .constraints|367))) (.analyze-unknown-call|31 .exp|367 .constraints|367)))))) (.analyze-unknown-call|31 .exp|367 .constraints|367))))))))))))) (set! .lookup-node|31 (lambda (.l|467) (let ((.g|470 .g|18)) (let () (let ((.loop|473 (unspecified))) (begin (set! .loop|473 (lambda (.g|474) (if (null? .g|474) (error "Unknown lambda expression" (make-readable .l|467 #t)) (if (eq? .l|467 (callgraphnode.code (let ((.x|477|480 .g|474)) (begin (.check! (pair? .x|477|480) 0 .x|477|480) (car:pair .x|477|480))))) (let ((.x|481|484 .g|474)) (begin (.check! (pair? .x|481|484) 0 .x|481|484) (car:pair .x|481|484))) (.loop|473 (let ((.x|486|489 .g|474)) (begin (.check! (pair? .x|486|489) 1 .x|486|489) (cdr:pair .x|486|489)))))))) (.loop|473 .g|470))))))) (set! .lookup-code|31 (lambda (.name|490) (callgraphnode.code (assq .name|490 .g|18)))) (set! .update-typevar!|31 (lambda (.tv|491 .type|491) (let* ((.type0|494 (hashtable-get .types|15 .tv|491)) (.type0|497 (let ((.temp|506|509 .type0|494)) (if .temp|506|509 .temp|506|509 (begin (hashtable-put! .types|15 .tv|491 rep:bottom) rep:bottom)))) (.type1|500 (representation-union .type0|497 .type|491))) (let () (if (eq? .type0|497 .type1|500) #f (begin (hashtable-put! .types|15 .tv|491 .type1|500) (set! .changed?|24 #t) (if (if .debugging?|6 .mutate?|27 #f) (begin (display "******** Changing type of ") (display .tv|491) (display " from ") (display (rep->symbol .type0|497)) (display " to ") (display (rep->symbol .type1|500)) (newline)) (unspecified)) #t)))))) (set! .known-procedure-is-callable?|31 (lambda (.name|511) (callgraphnode.info (assq .name|511 .g|18)))) (set! .schedule-local-procedures!|31 (lambda (.l|512) (let () (let ((.loop|518|520|523 (unspecified))) (begin (set! .loop|518|520|523 (lambda (.y1|513|514|524) (if (null? .y1|513|514|524) (if #f #f (unspecified)) (begin (begin #t (let* ((.def|528 (let ((.x|532|535 .y1|513|514|524)) (begin (.check! (pair? .x|532|535) 0 .x|532|535) (car:pair .x|532|535)))) (.name|531 (def.lhs .def|528))) (if (.known-procedure-is-callable?|31 .name|531) (.schedule!|31 .name|531) (unspecified)))) (.loop|518|520|523 (let ((.x|536|539 .y1|513|514|524)) (begin (.check! (pair? .x|536|539) 1 .x|536|539) (cdr:pair .x|536|539)))))))) (.loop|518|520|523 (lambda.defs .l|512))))))) (set! .schedule-callers!|31 (lambda (.name|540) (let () (let ((.loop|546|548|551 (unspecified))) (begin (set! .loop|546|548|551 (lambda (.y1|541|542|552) (if (null? .y1|541|542|552) (if #f #f (unspecified)) (begin (begin #t (let ((.node|556 (let ((.x|567|570 .y1|541|542|552)) (begin (.check! (pair? .x|567|570) 0 .x|567|570) (car:pair .x|567|570))))) (if (if (callgraphnode.info .node|556) (let ((.temp|559|562 (memq .name|540 (callgraphnode.tailcalls .node|556)))) (if .temp|559|562 .temp|559|562 (memq .name|540 (callgraphnode.nontailcalls .node|556)))) #f) (let ((.caller|566 (callgraphnode.name .node|556))) (if .caller|566 (.schedule!|31 .caller|566) (.schedule!|31 (callgraphnode.code .node|556)))) (unspecified)))) (.loop|546|548|551 (let ((.x|571|574 .y1|541|542|552)) (begin (.check! (pair? .x|571|574) 1 .x|571|574) (cdr:pair .x|571|574)))))))) (.loop|546|548|551 .g|18)))))) (set! .schedule-known-procedure!|31 (lambda (.name|575) (begin (callgraphnode.info! (assq .name|575 .g|18) #t) (.schedule!|31 .name|575)))) (set! .schedule!|31 (lambda (.job|576) (if (not (memq .job|576 .schedule|21)) (begin (set! .schedule|21 (cons .job|576 .schedule|21)) (if (not (symbol? .job|576)) (callgraphnode.info! (.lookup-node|31 .job|576) #t) (unspecified))) (unspecified)))) '(if debugging? (begin (pretty-print (make-readable (car schedule) #t)) (newline))) (if .debugging?|6 (view-callgraph .g|18) (unspecified)) (let () (let ((.loop|582|584|587 (unspecified))) (begin (set! .loop|582|584|587 (lambda (.y1|577|578|588) (if (null? .y1|577|578|588) (if #f #f (unspecified)) (begin (begin #t (let* ((.node|592 (let ((.x|635|638 .y1|577|578|588)) (begin (.check! (pair? .x|635|638) 0 .x|635|638) (car:pair .x|635|638)))) (.name|595 (callgraphnode.name .node|592)) (.code|598 (callgraphnode.code .node|592)) (.vars|601 (make-null-terminated (lambda.args .code|598))) (.known?|604 (symbol? .name|595)) (.rep|607 (if .known?|604 rep:bottom rep:object))) (let () (begin (callgraphnode.info! .node|592 #f) (if .known?|604 (begin (hashtable-put! .known|12 .name|595 .vars|601) (hashtable-put! .types|15 .name|595 .rep|607)) (unspecified)) (let () (let ((.loop|616|618|621 (unspecified))) (begin (set! .loop|616|618|621 (lambda (.y1|611|612|622) (if (null? .y1|611|612|622) (if #f #f (unspecified)) (begin (begin #t (let ((.var|626 (let ((.x|627|630 .y1|611|612|622)) (begin (.check! (pair? .x|627|630) 0 .x|627|630) (car:pair .x|627|630))))) (hashtable-put! .types|15 .var|626 .rep|607))) (.loop|616|618|621 (let ((.x|631|634 .y1|611|612|622)) (begin (.check! (pair? .x|631|634) 1 .x|631|634) (cdr:pair .x|631|634)))))))) (.loop|616|618|621 .vars|601)))))))) (.loop|582|584|587 (let ((.x|639|642 .y1|577|578|588)) (begin (.check! (pair? .x|639|642) 1 .x|639|642) (cdr:pair .x|639|642)))))))) (.loop|582|584|587 .g|18)))) (let () (let () (let ((.loop|648 (unspecified))) (begin (set! .loop|648 (lambda () (if (not (null? .schedule|21)) (let ((.job|653 (let ((.x|658|661 .schedule|21)) (begin (.check! (pair? .x|658|661) 0 .x|658|661) (car:pair .x|658|661))))) (begin (set! .schedule|21 (let ((.x|654|657 .schedule|21)) (begin (.check! (pair? .x|654|657) 1 .x|654|657) (cdr:pair .x|654|657)))) (if (symbol? .job|653) (.analyze-known-local-procedure|31 .job|653) (.analyze-unknown-lambda|31 .job|653)) (.loop|648))) (if .changed?|24 (begin (set! .changed?|24 #f) (set! .schedule|21 (cons (callgraphnode.code (let ((.x|664|667 .g|18)) (begin (.check! (pair? .x|664|667) 0 .x|664|667) (car:pair .x|664|667)))) '())) (if .debugging?|6 (begin (.display-all-types|31) (newline)) (unspecified)) (.loop|648)) (unspecified))))) (.loop|648))))) (if .debugging?|6 (.display-types|31) (unspecified)) (set! .mutate?|27 #t) (set! .schedule|21 (cons (callgraphnode.code (let ((.x|668|671 .g|18)) (begin (.check! (pair? .x|668|671) 0 .x|668|671) (car:pair .x|668|671)))) (let () (let ((.loop|677|680|683 (unspecified))) (begin (set! .loop|677|680|683 (lambda (.y1|672|673|684 .results|672|676|684) (if (null? .y1|672|673|684) (reverse .results|672|676|684) (begin #t (.loop|677|680|683 (let ((.x|688|691 .y1|672|673|684)) (begin (.check! (pair? .x|688|691) 1 .x|688|691) (cdr:pair .x|688|691))) (cons (callgraphnode.name (let ((.x|692|695 .y1|672|673|684)) (begin (.check! (pair? .x|692|695) 0 .x|692|695) (car:pair .x|692|695)))) .results|672|676|684)))))) (.loop|677|680|683 (filter (lambda (.node|696) (let* ((.name|699 (callgraphnode.name .node|696)) (.known?|702 (symbol? .name|699)) (.marked?|705 (.known-procedure-is-callable?|31 .name|699))) (let () (begin (callgraphnode.info! .node|696 #f) (if .known?|702 .marked?|705 #f))))) .g|18) '())))))) (let () (let () (let ((.loop|716 (unspecified))) (begin (set! .loop|716 (lambda () (if (not (null? .schedule|21)) (let ((.job|720 (let ((.x|725|728 .schedule|21)) (begin (.check! (pair? .x|725|728) 0 .x|725|728) (car:pair .x|725|728))))) (begin (set! .schedule|21 (let ((.x|721|724 .schedule|21)) (begin (.check! (pair? .x|721|724) 1 .x|721|724) (cdr:pair .x|721|724)))) (if (symbol? .job|720) (.analyze-known-local-procedure|31 .job|720) (.analyze-unknown-lambda|31 .job|720)) (.loop|716))) (unspecified)))) (.loop|716))))) (if .changed?|24 (error "Compiler bug in representation inference") (unspecified)) (if .debugging?|6 (pretty-print (make-readable (callgraphnode.code (let ((.x|729|732 .g|18)) (begin (.check! (pair? .x|729|732) 0 .x|729|732) (car:pair .x|729|732)))) #t)) (unspecified)) .exp|3)))))) (.representation-analysis|2 .exp|1))))) 'representation-analysis))
(let () (begin (set! pass3 (lambda (.exp|1) (let ((.pass3|2 0)) (begin (set! .pass3|2 (lambda (.exp|3) (let ((.verify|4 (unspecified)) (.finish|4 (unspecified)) (.phase4|4 (unspecified)) (.phase3|4 (unspecified)) (.phase2|4 (unspecified)) (.phase1|4 (unspecified))) (begin (set! .verify|4 (lambda (.exp|5) (begin (check-referencing-invariants .exp|5 'free) .exp|5))) (set! .finish|4 (lambda (.exp|6) (if (if (not (interprocedural-constant-propagation)) (not (common-subexpression-elimination)) #f) (begin (compute-free-variables! .exp|6) .exp|6) .exp|6))) (set! .phase4|4 (lambda (.exp|9) (if (representation-inference) (let ((.exp|12 (if (common-subexpression-elimination) .exp|9 (if (interprocedural-constant-propagation) (a-normal-form .exp|9) (a-normal-form (copy-exp .exp|9)))))) (intraprocedural-commoning (representation-analysis .exp|12))) .exp|9))) (set! .phase3|4 (lambda (.exp|16) (if (common-subexpression-elimination) (let* ((.exp|19 (if (interprocedural-constant-propagation) .exp|16 (copy-exp .exp|16))) (.exp|22 (a-normal-form .exp|19))) (let () (if (representation-inference) (intraprocedural-commoning .exp|22 'commoning) (intraprocedural-commoning .exp|22)))) .exp|16))) (set! .phase2|4 (lambda (.exp|26) (if (interprocedural-constant-propagation) (constant-propagation (copy-exp .exp|26)) .exp|26))) (set! .phase1|4 (lambda (.exp|27) (if (interprocedural-inlining) (let ((.g|30 (callgraph .exp|27))) (begin (inline-using-callgraph! .g|30) .exp|27)) .exp|27))) (if (global-optimization) (.verify|4 (.finish|4 (.phase4|4 (.phase3|4 (.phase2|4 (.phase1|4 .exp|3)))))) (begin (compute-free-variables! .exp|3) (.verify|4 .exp|3))))))) (.pass3|2 .exp|1))))) 'pass3))
(let () (begin (set! init-labels (lambda () (let ((.init-labels|2 0)) (begin (set! .init-labels|2 (lambda () (set! cg-label-counter 1000))) (.init-labels|2))))) 'init-labels))
(let () (begin (set! make-label (lambda () (let ((.make-label|2 0)) (begin (set! .make-label|2 (lambda () (begin (set! cg-label-counter (+ cg-label-counter 1)) cg-label-counter))) (.make-label|2))))) 'make-label))
(let () (begin (set! cg-label-counter 1000) 'cg-label-counter))
(let () (begin (set! make-assembly-stream (lambda () (let ((.make-assembly-stream|2 0)) (begin (set! .make-assembly-stream|2 (lambda () (let ((.code|6 (cons (cons 0 '()) '()))) (begin (set-cdr! .code|6 (let ((.x|7|10 .code|6)) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10)))) (let* ((.t1|11|14 .code|6) (.t2|11|17 (cons #f '()))) (let () (cons .t1|11|14 .t2|11|17))))))) (.make-assembly-stream|2))))) 'make-assembly-stream))
(let () (begin (set! assembly-stream-code (lambda (.output|1) (let ((.assembly-stream-code|2 0)) (begin (set! .assembly-stream-code|2 (lambda (.output|3) (if (local-optimizations) (filter-basic-blocks (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .output|3)) (begin (.check! (pair? .x|13|16) 0 .x|13|16) (car:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8)))) (let ((.x|18|21 (let ((.x|22|25 (let ((.x|26|29 .output|3)) (begin (.check! (pair? .x|26|29) 0 .x|26|29) (car:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 0 .x|22|25) (car:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 1 .x|18|21) (cdr:pair .x|18|21)))))) (.assembly-stream-code|2 .output|1))))) 'assembly-stream-code))
(let () (begin (set! assembly-stream-info (lambda (.output|1) (let ((.assembly-stream-info|2 0)) (begin (set! .assembly-stream-info|2 (lambda (.output|3) (let ((.x|5|8 (let ((.x|9|12 .output|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.assembly-stream-info|2 .output|1))))) 'assembly-stream-info))
(let () (begin (set! assembly-stream-info! (lambda (.output|1 .x|1) (let ((.assembly-stream-info!|2 0)) (begin (set! .assembly-stream-info!|2 (lambda (.output|3 .x|3) (begin (set-car! (let ((.x|4|7 .output|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .x|3) #f))) (.assembly-stream-info!|2 .output|1 .x|1))))) 'assembly-stream-info!))
(let () (begin (set! gen-instruction! (lambda (.output|1 .instruction|1) (let ((.gen-instruction!|2 0)) (begin (set! .gen-instruction!|2 (lambda (.output|3 .instruction|3) (let ((.pair|6 (cons .instruction|3 '())) (.code|6 (let ((.x|12|15 .output|3)) (begin (.check! (pair? .x|12|15) 0 .x|12|15) (car:pair .x|12|15))))) (begin (set-cdr! (let ((.x|7|10 .code|6)) (begin (.check! (pair? .x|7|10) 1 .x|7|10) (cdr:pair .x|7|10))) .pair|6) (set-cdr! .code|6 .pair|6) .output|3)))) (.gen-instruction!|2 .output|1 .instruction|1))))) 'gen-instruction!))
(let () (begin (set! gen! (lambda (.output|1 . .instruction|1) (gen-instruction! .output|1 .instruction|1))) 'gen!))
(let () (begin (set! gen-save! (lambda (.output|1 .frame|1 .t0|1) (let ((.gen-save!|2 0)) (begin (set! .gen-save!|2 (lambda (.output|3 .frame|3 .t0|3) (let ((.size|6 (cgframe-size-cell .frame|3))) (begin (gen-instruction! .output|3 (cons $save .size|6)) (gen-store! .output|3 .frame|3 0 .t0|3) (cgframe:stale-set! .frame|3 '()))))) (.gen-save!|2 .output|1 .frame|1 .t0|1))))) 'gen-save!))
(let () (begin (set! gen-restore! (lambda (.output|1 .frame|1) (let ((.gen-restore!|2 0)) (begin (set! .gen-restore!|2 (lambda (.output|3 .frame|3) (let ((.size|6 (cgframe-size-cell .frame|3))) (gen-instruction! .output|3 (cons $restore .size|6))))) (.gen-restore!|2 .output|1 .frame|1))))) 'gen-restore!))
(let () (begin (set! gen-pop! (lambda (.output|1 .frame|1) (let ((.gen-pop!|2 0)) (begin (set! .gen-pop!|2 (lambda (.output|3 .frame|3) (let ((.size|6 (cgframe-size-cell .frame|3))) (gen-instruction! .output|3 (cons $pop .size|6))))) (.gen-pop!|2 .output|1 .frame|1))))) 'gen-pop!))
(let () (begin (set! gen-setstk! (lambda (.output|1 .frame|1 .tempname|1) (let ((.gen-setstk!|2 0)) (begin (set! .gen-setstk!|2 (lambda (.output|3 .frame|3 .tempname|3) (let ((.instruction|6 (let* ((.t1|7|10 $nop) (.t2|7|13 (let* ((.t1|17|20 $setstk) (.t2|17|23 (cons -1 '()))) (let () (cons .t1|17|20 .t2|17|23))))) (let () (cons .t1|7|10 .t2|7|13))))) (begin (cgframe-bind! .frame|3 .tempname|3 .instruction|6) (gen-instruction! .output|3 .instruction|6))))) (.gen-setstk!|2 .output|1 .frame|1 .tempname|1))))) 'gen-setstk!))
(let () (begin (set! gen-store! (lambda (.output|1 .frame|1 .r|1 .tempname|1) (let ((.gen-store!|2 0)) (begin (set! .gen-store!|2 (lambda (.output|3 .frame|3 .r|3 .tempname|3) (let ((.instruction|6 (let* ((.t1|7|10 $nop) (.t2|7|13 (let* ((.t1|17|20 $store) (.t2|17|23 (let* ((.t1|27|30 .r|3) (.t2|27|33 (cons -1 '()))) (let () (cons .t1|27|30 .t2|27|33))))) (let () (cons .t1|17|20 .t2|17|23))))) (let () (cons .t1|7|10 .t2|7|13))))) (begin (cgframe-bind! .frame|3 .tempname|3 .instruction|6) (gen-instruction! .output|3 .instruction|6))))) (.gen-store!|2 .output|1 .frame|1 .r|1 .tempname|1))))) 'gen-store!))
(let () (begin (set! gen-load! (lambda (.output|1 .frame|1 .r|1 .tempname|1) (let ((.gen-load!|2 0)) (begin (set! .gen-load!|2 (lambda (.output|3 .frame|3 .r|3 .tempname|3) (begin (cgframe-touch! .frame|3 .tempname|3) (let ((.n|6 (entry.slotnum (cgframe-lookup .frame|3 .tempname|3)))) (gen! .output|3 $load .r|3 .n|6))))) (.gen-load!|2 .output|1 .frame|1 .r|1 .tempname|1))))) 'gen-load!))
(let () (begin (set! gen-stack! (lambda (.output|1 .frame|1 .tempname|1) (let ((.gen-stack!|2 0)) (begin (set! .gen-stack!|2 (lambda (.output|3 .frame|3 .tempname|3) (begin (cgframe-touch! .frame|3 .tempname|3) (let ((.n|6 (entry.slotnum (cgframe-lookup .frame|3 .tempname|3)))) (gen! .output|3 $stack .n|6))))) (.gen-stack!|2 .output|1 .frame|1 .tempname|1))))) 'gen-stack!))
(let () (begin (set! init-temps (lambda () (let ((.init-temps|2 0)) (begin (set! .init-temps|2 (lambda () (set! newtemp-counter 5000))) (.init-temps|2))))) 'init-temps))
(let () (begin (set! newtemp (lambda () (let ((.newtemp|2 0)) (begin (set! .newtemp|2 (lambda () (begin (set! newtemp-counter (+ newtemp-counter 1)) newtemp-counter))) (.newtemp|2))))) 'newtemp))
(let () (begin (set! newtemp-counter 5000) 'newtemp-counter))
(let () (begin (set! newtemps (lambda (.n|1) (let ((.newtemps|2 0)) (begin (set! .newtemps|2 (lambda (.n|3) (if (zero? .n|3) '() (cons (newtemp) (.newtemps|2 (- .n|3 1)))))) (.newtemps|2 .n|1))))) 'newtemps))
(let () (begin (set! cgreg-makeregs (lambda (.n|1 .v1|1 .v2|1) (let ((.cgreg-makeregs|2 0)) (begin (set! .cgreg-makeregs|2 (lambda (.n|3 .v1|3 .v2|3) (let* ((.t1|4|7 .n|3) (.t2|4|10 (let* ((.t1|14|17 .v1|3) (.t2|14|20 (cons .v2|3 '()))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.cgreg-makeregs|2 .n|1 .v1|1 .v2|1))))) 'cgreg-makeregs))
(let () (begin (set! cgreg-liveregs (lambda (.regs|1) (let ((.cgreg-liveregs|2 0)) (begin (set! .cgreg-liveregs|2 (lambda (.regs|3) (let ((.x|4|7 .regs|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.cgreg-liveregs|2 .regs|1))))) 'cgreg-liveregs))
(let () (begin (set! cgreg-contents (lambda (.regs|1) (let ((.cgreg-contents|2 0)) (begin (set! .cgreg-contents|2 (lambda (.regs|3) (let ((.x|5|8 (let ((.x|9|12 .regs|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.cgreg-contents|2 .regs|1))))) 'cgreg-contents))
(let () (begin (set! cgreg-stale (lambda (.regs|1) (let ((.cgreg-stale|2 0)) (begin (set! .cgreg-stale|2 (lambda (.regs|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .regs|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))))) (.cgreg-stale|2 .regs|1))))) 'cgreg-stale))
(let () (begin (set! cgreg-liveregs-set! (lambda (.regs|1 .n|1) (let ((.cgreg-liveregs-set!|2 0)) (begin (set! .cgreg-liveregs-set!|2 (lambda (.regs|3 .n|3) (begin (set-car! .regs|3 .n|3) .regs|3))) (.cgreg-liveregs-set!|2 .regs|1 .n|1))))) 'cgreg-liveregs-set!))
(let () (begin (set! cgreg-initial (lambda () (let ((.cgreg-initial|2 0)) (begin (set! .cgreg-initial|2 (lambda () (let ((.v1|6 (make-vector *nregs* #f)) (.v2|6 (make-vector *nregs* #f))) (cgreg-makeregs 0 .v1|6 .v2|6)))) (.cgreg-initial|2))))) 'cgreg-initial))
(let () (begin (set! cgreg-copy (lambda (.regs|1) (let ((.cgreg-copy|2 0)) (begin (set! .cgreg-copy|2 (lambda (.regs|3) (let* ((.newregs|6 (cgreg-initial)) (.v1a|9 (cgreg-contents .regs|3)) (.v2a|12 (cgreg-stale .regs|3)) (.v1|15 (cgreg-contents .newregs|6)) (.v2|18 (cgreg-stale .newregs|6)) (.n|21 (let ((.v|50|53 .v1a|9)) (begin (.check! (vector? .v|50|53) 42 .v|50|53) (vector-length:vec .v|50|53))))) (let () (begin (cgreg-liveregs-set! .newregs|6 (cgreg-liveregs .regs|3)) (let () (let ((.loop|25|27|30 (unspecified))) (begin (set! .loop|25|27|30 (lambda (.i|31) (if (= .i|31 .n|21) .newregs|6 (begin (begin #t (let ((.v|34|37 .v1|15) (.i|34|37 .i|31) (.x|34|37 (let ((.v|38|41 .v1a|9) (.i|38|41 .i|31)) (begin (.check! (fixnum? .i|38|41) 40 .v|38|41 .i|38|41) (.check! (vector? .v|38|41) 40 .v|38|41 .i|38|41) (.check! (<:fix:fix .i|38|41 (vector-length:vec .v|38|41)) 40 .v|38|41 .i|38|41) (.check! (>=:fix:fix .i|38|41 0) 40 .v|38|41 .i|38|41) (vector-ref:trusted .v|38|41 .i|38|41))))) (begin (.check! (fixnum? .i|34|37) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (vector? .v|34|37) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (<:fix:fix .i|34|37 (vector-length:vec .v|34|37)) 41 .v|34|37 .i|34|37 .x|34|37) (.check! (>=:fix:fix .i|34|37 0) 41 .v|34|37 .i|34|37 .x|34|37) (vector-set!:trusted .v|34|37 .i|34|37 .x|34|37))) (let ((.v|42|45 .v2|18) (.i|42|45 .i|31) (.x|42|45 (let ((.v|46|49 .v2a|12) (.i|46|49 .i|31)) (begin (.check! (fixnum? .i|46|49) 40 .v|46|49 .i|46|49) (.check! (vector? .v|46|49) 40 .v|46|49 .i|46|49) (.check! (<:fix:fix .i|46|49 (vector-length:vec .v|46|49)) 40 .v|46|49 .i|46|49) (.check! (>=:fix:fix .i|46|49 0) 40 .v|46|49 .i|46|49) (vector-ref:trusted .v|46|49 .i|46|49))))) (begin (.check! (fixnum? .i|42|45) 41 .v|42|45 .i|42|45 .x|42|45) (.check! (vector? .v|42|45) 41 .v|42|45 .i|42|45 .x|42|45) (.check! (<:fix:fix .i|42|45 (vector-length:vec .v|42|45)) 41 .v|42|45 .i|42|45 .x|42|45) (.check! (>=:fix:fix .i|42|45 0) 41 .v|42|45 .i|42|45 .x|42|45) (vector-set!:trusted .v|42|45 .i|42|45 .x|42|45)))) (.loop|25|27|30 (+ .i|31 1)))))) (.loop|25|27|30 0))))))))) (.cgreg-copy|2 .regs|1))))) 'cgreg-copy))
(let () (begin (set! cgreg-tos (lambda (.regs|1) (let ((.cgreg-tos|2 0)) (begin (set! .cgreg-tos|2 (lambda (.regs|3) (- (cgreg-liveregs .regs|3) 1))) (.cgreg-tos|2 .regs|1))))) 'cgreg-tos))
(let () (begin (set! cgreg-live (lambda (.regs|1 .r|1) (let ((.cgreg-live|2 0)) (begin (set! .cgreg-live|2 (lambda (.regs|3 .r|3) (if (eq? .r|3 'result) (cgreg-tos .regs|3) (max .r|3 (cgreg-tos .regs|3))))) (.cgreg-live|2 .regs|1 .r|1))))) 'cgreg-live))
(let () (begin (set! cgreg-vars (lambda (.regs|1) (let ((.cgreg-vars|2 0)) (begin (set! .cgreg-vars|2 (lambda (.regs|3) (let ((.m|6 (cgreg-liveregs .regs|3)) (.v|6 (cgreg-contents .regs|3))) (let () (let ((.loop|7|10|13 (unspecified))) (begin (set! .loop|7|10|13 (lambda (.i|14 .vars|14) (if (< .i|14 0) .vars|14 (begin #t (.loop|7|10|13 (- .i|14 1) (cons (let ((.v|17|20 .v|6) (.i|17|20 .i|14)) (begin (.check! (fixnum? .i|17|20) 40 .v|17|20 .i|17|20) (.check! (vector? .v|17|20) 40 .v|17|20 .i|17|20) (.check! (<:fix:fix .i|17|20 (vector-length:vec .v|17|20)) 40 .v|17|20 .i|17|20) (.check! (>=:fix:fix .i|17|20 0) 40 .v|17|20 .i|17|20) (vector-ref:trusted .v|17|20 .i|17|20))) .vars|14)))))) (.loop|7|10|13 (- .m|6 1) '()))))))) (.cgreg-vars|2 .regs|1))))) 'cgreg-vars))
(let () (begin (set! cgreg-bind! (lambda (.regs|1 .r|1 .t|1) (let ((.cgreg-bind!|2 0)) (begin (set! .cgreg-bind!|2 (lambda (.regs|3 .r|3 .t|3) (let ((.m|6 (cgreg-liveregs .regs|3)) (.v|6 (cgreg-contents .regs|3))) (begin (let ((.v|7|10 .v|6) (.i|7|10 .r|3) (.x|7|10 .t|3)) (begin (.check! (fixnum? .i|7|10) 41 .v|7|10 .i|7|10 .x|7|10) (.check! (vector? .v|7|10) 41 .v|7|10 .i|7|10 .x|7|10) (.check! (<:fix:fix .i|7|10 (vector-length:vec .v|7|10)) 41 .v|7|10 .i|7|10 .x|7|10) (.check! (>=:fix:fix .i|7|10 0) 41 .v|7|10 .i|7|10 .x|7|10) (vector-set!:trusted .v|7|10 .i|7|10 .x|7|10))) (if (>= .r|3 .m|6) (cgreg-liveregs-set! .regs|3 (+ .r|3 1)) (unspecified)))))) (.cgreg-bind!|2 .regs|1 .r|1 .t|1))))) 'cgreg-bind!))
(let () (begin (set! cgreg-bindregs! (lambda (.regs|1 .vars|1) (let ((.cgreg-bindregs!|2 0)) (begin (set! .cgreg-bindregs!|2 (lambda (.regs|3 .vars|3) (let () (let ((.loop|4|8|11 (unspecified))) (begin (set! .loop|4|8|11 (lambda (.m|12 .v|12 .vars|12) (if (null? .vars|12) (begin (cgreg-liveregs-set! .regs|3 .m|12) .regs|3) (begin (begin #t (let ((.v|15|18 .v|12) (.i|15|18 .m|12) (.x|15|18 (let ((.x|19|22 .vars|12)) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22))))) (begin (.check! (fixnum? .i|15|18) 41 .v|15|18 .i|15|18 .x|15|18) (.check! (vector? .v|15|18) 41 .v|15|18 .i|15|18 .x|15|18) (.check! (<:fix:fix .i|15|18 (vector-length:vec .v|15|18)) 41 .v|15|18 .i|15|18 .x|15|18) (.check! (>=:fix:fix .i|15|18 0) 41 .v|15|18 .i|15|18 .x|15|18) (vector-set!:trusted .v|15|18 .i|15|18 .x|15|18)))) (.loop|4|8|11 (+ .m|12 1) .v|12 (let ((.x|23|26 .vars|12)) (begin (.check! (pair? .x|23|26) 1 .x|23|26) (cdr:pair .x|23|26)))))))) (.loop|4|8|11 (cgreg-liveregs .regs|3) (cgreg-contents .regs|3) .vars|3)))))) (.cgreg-bindregs!|2 .regs|1 .vars|1))))) 'cgreg-bindregs!))
(let () (begin (set! cgreg-rename! (lambda (.regs|1 .alist|1) (let ((.cgreg-rename!|2 0)) (begin (set! .cgreg-rename!|2 (lambda (.regs|3 .alist|3) (let () (let ((.loop|5|8|11 (unspecified))) (begin (set! .loop|5|8|11 (lambda (.i|12 .v|12) (if (< .i|12 0) (if #f #f (unspecified)) (begin (begin #t (let ((.var|18 (let ((.v|31|34 .v|12) (.i|31|34 .i|12)) (begin (.check! (fixnum? .i|31|34) 40 .v|31|34 .i|31|34) (.check! (vector? .v|31|34) 40 .v|31|34 .i|31|34) (.check! (<:fix:fix .i|31|34 (vector-length:vec .v|31|34)) 40 .v|31|34 .i|31|34) (.check! (>=:fix:fix .i|31|34 0) 40 .v|31|34 .i|31|34) (vector-ref:trusted .v|31|34 .i|31|34))))) (if .var|18 (let ((.probe|21 (assv .var|18 .alist|3))) (if .probe|21 (let ((.v|22|25 .v|12) (.i|22|25 .i|12) (.x|22|25 (let ((.x|26|29 .probe|21)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (fixnum? .i|22|25) 41 .v|22|25 .i|22|25 .x|22|25) (.check! (vector? .v|22|25) 41 .v|22|25 .i|22|25 .x|22|25) (.check! (<:fix:fix .i|22|25 (vector-length:vec .v|22|25)) 41 .v|22|25 .i|22|25 .x|22|25) (.check! (>=:fix:fix .i|22|25 0) 41 .v|22|25 .i|22|25 .x|22|25) (vector-set!:trusted .v|22|25 .i|22|25 .x|22|25))) (unspecified))) (unspecified)))) (.loop|5|8|11 (- .i|12 1) .v|12))))) (.loop|5|8|11 (- (cgreg-liveregs .regs|3) 1) (cgreg-contents .regs|3))))))) (.cgreg-rename!|2 .regs|1 .alist|1))))) 'cgreg-rename!))
(let () (begin (set! cgreg-release! (lambda (.regs|1 .r|1) (let ((.cgreg-release!|2 0)) (begin (set! .cgreg-release!|2 (lambda (.regs|3 .r|3) (let ((.m|6 (cgreg-liveregs .regs|3)) (.v|6 (cgreg-contents .regs|3))) (begin (let ((.v|7|10 .v|6) (.i|7|10 .r|3) (.x|7|10 #f)) (begin (.check! (fixnum? .i|7|10) 41 .v|7|10 .i|7|10 .x|7|10) (.check! (vector? .v|7|10) 41 .v|7|10 .i|7|10 .x|7|10) (.check! (<:fix:fix .i|7|10 (vector-length:vec .v|7|10)) 41 .v|7|10 .i|7|10 .x|7|10) (.check! (>=:fix:fix .i|7|10 0) 41 .v|7|10 .i|7|10 .x|7|10) (vector-set!:trusted .v|7|10 .i|7|10 .x|7|10))) (let ((.v|11|14 (cgreg-stale .regs|3)) (.i|11|14 .r|3) (.x|11|14 #t)) (begin (.check! (fixnum? .i|11|14) 41 .v|11|14 .i|11|14 .x|11|14) (.check! (vector? .v|11|14) 41 .v|11|14 .i|11|14 .x|11|14) (.check! (<:fix:fix .i|11|14 (vector-length:vec .v|11|14)) 41 .v|11|14 .i|11|14 .x|11|14) (.check! (>=:fix:fix .i|11|14 0) 41 .v|11|14 .i|11|14 .x|11|14) (vector-set!:trusted .v|11|14 .i|11|14 .x|11|14))) (if (= .r|3 (- .m|6 1)) (let () (let ((.loop|15|17|20 (unspecified))) (begin (set! .loop|15|17|20 (lambda (.m|21) (if (let ((.temp|23|26 (< .m|21 0))) (if .temp|23|26 .temp|23|26 (let ((.v|28|31 .v|6) (.i|28|31 .m|21)) (begin (.check! (fixnum? .i|28|31) 40 .v|28|31 .i|28|31) (.check! (vector? .v|28|31) 40 .v|28|31 .i|28|31) (.check! (<:fix:fix .i|28|31 (vector-length:vec .v|28|31)) 40 .v|28|31 .i|28|31) (.check! (>=:fix:fix .i|28|31 0) 40 .v|28|31 .i|28|31) (vector-ref:trusted .v|28|31 .i|28|31))))) (cgreg-liveregs-set! .regs|3 (+ .m|21 1)) (begin #t (.loop|15|17|20 (- .m|21 1)))))) (.loop|15|17|20 .r|3)))) (unspecified)))))) (.cgreg-release!|2 .regs|1 .r|1))))) 'cgreg-release!))
(let () (begin (set! cgreg-release-except! (lambda (.regs|1 .vars|1) (let ((.cgreg-release-except!|2 0)) (begin (set! .cgreg-release-except!|2 (lambda (.regs|3 .vars|3) (let () (let ((.loop|5|8|11 (unspecified))) (begin (set! .loop|5|8|11 (lambda (.i|12 .v|12) (if (< .i|12 0) (if #f #f (unspecified)) (begin (begin #t (let ((.var|18 (let ((.v|21|24 .v|12) (.i|21|24 .i|12)) (begin (.check! (fixnum? .i|21|24) 40 .v|21|24 .i|21|24) (.check! (vector? .v|21|24) 40 .v|21|24 .i|21|24) (.check! (<:fix:fix .i|21|24 (vector-length:vec .v|21|24)) 40 .v|21|24 .i|21|24) (.check! (>=:fix:fix .i|21|24 0) 40 .v|21|24 .i|21|24) (vector-ref:trusted .v|21|24 .i|21|24))))) (if (if .var|18 (not (memq .var|18 .vars|3)) #f) (cgreg-release! .regs|3 .i|12) (unspecified)))) (.loop|5|8|11 (- .i|12 1) .v|12))))) (.loop|5|8|11 (- (cgreg-liveregs .regs|3) 1) (cgreg-contents .regs|3))))))) (.cgreg-release-except!|2 .regs|1 .vars|1))))) 'cgreg-release-except!))
(let () (begin (set! cgreg-clear! (lambda (.regs|1) (let ((.cgreg-clear!|2 0)) (begin (set! .cgreg-clear!|2 (lambda (.regs|3) (let ((.m|6 (cgreg-liveregs .regs|3)) (.v1|6 (cgreg-contents .regs|3)) (.v2|6 (cgreg-stale .regs|3))) (let () (let ((.loop|7|9|12 (unspecified))) (begin (set! .loop|7|9|12 (lambda (.r|13) (if (= .r|13 .m|6) (cgreg-liveregs-set! .regs|3 0) (begin (begin #t (let ((.v|16|19 .v1|6) (.i|16|19 .r|13) (.x|16|19 #f)) (begin (.check! (fixnum? .i|16|19) 41 .v|16|19 .i|16|19 .x|16|19) (.check! (vector? .v|16|19) 41 .v|16|19 .i|16|19 .x|16|19) (.check! (<:fix:fix .i|16|19 (vector-length:vec .v|16|19)) 41 .v|16|19 .i|16|19 .x|16|19) (.check! (>=:fix:fix .i|16|19 0) 41 .v|16|19 .i|16|19 .x|16|19) (vector-set!:trusted .v|16|19 .i|16|19 .x|16|19))) (let ((.v|20|23 .v2|6) (.i|20|23 .r|13) (.x|20|23 #t)) (begin (.check! (fixnum? .i|20|23) 41 .v|20|23 .i|20|23 .x|20|23) (.check! (vector? .v|20|23) 41 .v|20|23 .i|20|23 .x|20|23) (.check! (<:fix:fix .i|20|23 (vector-length:vec .v|20|23)) 41 .v|20|23 .i|20|23 .x|20|23) (.check! (>=:fix:fix .i|20|23 0) 41 .v|20|23 .i|20|23 .x|20|23) (vector-set!:trusted .v|20|23 .i|20|23 .x|20|23)))) (.loop|7|9|12 (+ .r|13 1)))))) (.loop|7|9|12 0))))))) (.cgreg-clear!|2 .regs|1))))) 'cgreg-clear!))
(let () (begin (set! cgreg-lookup (lambda (.regs|1 .var|1) (let ((.cgreg-lookup|2 0)) (begin (set! .cgreg-lookup|2 (lambda (.regs|3 .var|3) (let ((.m|6 (cgreg-liveregs .regs|3)) (.v|6 (cgreg-contents .regs|3))) (let ((.loop|7 (unspecified))) (begin (set! .loop|7 (lambda (.i|8) (if (< .i|8 0) #f (if (eq? .var|3 (let ((.v|11|14 .v|6) (.i|11|14 .i|8)) (begin (.check! (fixnum? .i|11|14) 40 .v|11|14 .i|11|14) (.check! (vector? .v|11|14) 40 .v|11|14 .i|11|14) (.check! (<:fix:fix .i|11|14 (vector-length:vec .v|11|14)) 40 .v|11|14 .i|11|14) (.check! (>=:fix:fix .i|11|14 0) 40 .v|11|14 .i|11|14) (vector-ref:trusted .v|11|14 .i|11|14)))) (let* ((.t1|15|18 .var|3) (.t2|15|21 (let* ((.t1|25|28 'register) (.t2|25|31 (let* ((.t1|35|38 .i|8) (.t2|35|41 (cons '(object) '()))) (let () (cons .t1|35|38 .t2|35|41))))) (let () (cons .t1|25|28 .t2|25|31))))) (let () (cons .t1|15|18 .t2|15|21))) (.loop|7 (- .i|8 1)))))) (.loop|7 (- .m|6 1))))))) (.cgreg-lookup|2 .regs|1 .var|1))))) 'cgreg-lookup))
(let () (begin (set! cgreg-lookup-reg (lambda (.regs|1 .r|1) (let ((.cgreg-lookup-reg|2 0)) (begin (set! .cgreg-lookup-reg|2 (lambda (.regs|3 .r|3) (let ((.m|6 (cgreg-liveregs .regs|3)) (.v|6 (cgreg-contents .regs|3))) (if (<= .m|6 .r|3) #f (let ((.v|7|10 .v|6) (.i|7|10 .r|3)) (begin (.check! (fixnum? .i|7|10) 40 .v|7|10 .i|7|10) (.check! (vector? .v|7|10) 40 .v|7|10 .i|7|10) (.check! (<:fix:fix .i|7|10 (vector-length:vec .v|7|10)) 40 .v|7|10 .i|7|10) (.check! (>=:fix:fix .i|7|10 0) 40 .v|7|10 .i|7|10) (vector-ref:trusted .v|7|10 .i|7|10))))))) (.cgreg-lookup-reg|2 .regs|1 .r|1))))) 'cgreg-lookup-reg))
(let () (begin (set! cgreg-join! (lambda (.regs1|1 .regs2|1) (let ((.cgreg-join!|2 0)) (begin (set! .cgreg-join!|2 (lambda (.regs1|3 .regs2|3) (let ((.m1|6 (cgreg-liveregs .regs1|3)) (.m2|6 (cgreg-liveregs .regs2|3)) (.v1|6 (cgreg-contents .regs1|3)) (.v2|6 (cgreg-contents .regs2|3)) (.stale1|6 (cgreg-stale .regs1|3))) (let () (let ((.loop|7|9|12 (unspecified))) (begin (set! .loop|7|9|12 (lambda (.i|13) (if (< .i|13 0) (cgreg-liveregs-set! .regs1|3 (min .m1|6 .m2|6)) (begin (begin #t (let ((.x1|18 (let ((.v|34|37 .v1|6) (.i|34|37 .i|13)) (begin (.check! (fixnum? .i|34|37) 40 .v|34|37 .i|34|37) (.check! (vector? .v|34|37) 40 .v|34|37 .i|34|37) (.check! (<:fix:fix .i|34|37 (vector-length:vec .v|34|37)) 40 .v|34|37 .i|34|37) (.check! (>=:fix:fix .i|34|37 0) 40 .v|34|37 .i|34|37) (vector-ref:trusted .v|34|37 .i|34|37)))) (.x2|18 (let ((.v|38|41 .v2|6) (.i|38|41 .i|13)) (begin (.check! (fixnum? .i|38|41) 40 .v|38|41 .i|38|41) (.check! (vector? .v|38|41) 40 .v|38|41 .i|38|41) (.check! (<:fix:fix .i|38|41 (vector-length:vec .v|38|41)) 40 .v|38|41 .i|38|41) (.check! (>=:fix:fix .i|38|41 0) 40 .v|38|41 .i|38|41) (vector-ref:trusted .v|38|41 .i|38|41))))) (if (eq? .x1|18 .x2|18) #t (if (not .x1|18) (if .x2|18 (let ((.v|21|24 .stale1|6) (.i|21|24 .i|13) (.x|21|24 #t)) (begin (.check! (fixnum? .i|21|24) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (vector? .v|21|24) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (<:fix:fix .i|21|24 (vector-length:vec .v|21|24)) 41 .v|21|24 .i|21|24 .x|21|24) (.check! (>=:fix:fix .i|21|24 0) 41 .v|21|24 .i|21|24 .x|21|24) (vector-set!:trusted .v|21|24 .i|21|24 .x|21|24))) (unspecified)) (begin (let ((.v|26|29 .v1|6) (.i|26|29 .i|13) (.x|26|29 #f)) (begin (.check! (fixnum? .i|26|29) 41 .v|26|29 .i|26|29 .x|26|29) (.check! (vector? .v|26|29) 41 .v|26|29 .i|26|29 .x|26|29) (.check! (<:fix:fix .i|26|29 (vector-length:vec .v|26|29)) 41 .v|26|29 .i|26|29 .x|26|29) (.check! (>=:fix:fix .i|26|29 0) 41 .v|26|29 .i|26|29 .x|26|29) (vector-set!:trusted .v|26|29 .i|26|29 .x|26|29))) (let ((.v|30|33 .stale1|6) (.i|30|33 .i|13) (.x|30|33 #t)) (begin (.check! (fixnum? .i|30|33) 41 .v|30|33 .i|30|33 .x|30|33) (.check! (vector? .v|30|33) 41 .v|30|33 .i|30|33 .x|30|33) (.check! (<:fix:fix .i|30|33 (vector-length:vec .v|30|33)) 41 .v|30|33 .i|30|33 .x|30|33) (.check! (>=:fix:fix .i|30|33 0) 41 .v|30|33 .i|30|33 .x|30|33) (vector-set!:trusted .v|30|33 .i|30|33 .x|30|33)))))))) (.loop|7|9|12 (- .i|13 1)))))) (.loop|7|9|12 (- (max .m1|6 .m2|6) 1)))))))) (.cgreg-join!|2 .regs1|1 .regs2|1))))) 'cgreg-join!))
(let () (begin (set! cgframe:slots car) 'cgframe:slots))
(let () (begin (set! cgframe:stale cadr) 'cgframe:stale))
(let () (begin (set! cgframe:livevars caddr) 'cgframe:livevars))
(let () (begin (set! cgframe:slot.name car) 'cgframe:slot.name))
(let () (begin (set! cgframe:slot.offset cadr) 'cgframe:slot.offset))
(let () (begin (set! cgframe:slot.instruction caddr) 'cgframe:slot.instruction))
(let () (begin (set! cgframe:slot.stale cadddr) 'cgframe:slot.stale))
(let () (begin (set! cgframe:slots-set! set-car!) 'cgframe:slots-set!))
(let () (begin (set! cgframe:stale-set! (lambda (.frame|1 .stale|1) (let ((.cgframe:stale-set!|2 0)) (begin (set! .cgframe:stale-set!|2 (lambda (.frame|3 .stale|3) (set-car! (let ((.x|4|7 .frame|3)) (begin (.check! (pair? .x|4|7) 1 .x|4|7) (cdr:pair .x|4|7))) .stale|3))) (.cgframe:stale-set!|2 .frame|1 .stale|1))))) 'cgframe:stale-set!))
(let () (begin (set! cgframe:livevars-set! (lambda (.frame|1 .vars|1) (let ((.cgframe:livevars-set!|2 0)) (begin (set! .cgframe:livevars-set!|2 (lambda (.frame|3 .vars|3) (set-car! (let ((.x|5|8 (let ((.x|9|12 .frame|3)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))) .vars|3))) (.cgframe:livevars-set!|2 .frame|1 .vars|1))))) 'cgframe:livevars-set!))
(let () (begin (set! cgframe:slot.name-set! set-car!) 'cgframe:slot.name-set!))
(let () (begin (set! cgframe:slot.offset-set! (lambda (.entry|1 .n|1) (let ((.cgframe:slot.offset-set!|2 0)) (begin (set! .cgframe:slot.offset-set!|2 (lambda (.entry|3 .n|3) (let ((.instruction|6 (let ((.x|65|68 (let ((.x|69|72 (let ((.x|73|76 .entry|3)) (begin (.check! (pair? .x|73|76) 1 .x|73|76) (cdr:pair .x|73|76))))) (begin (.check! (pair? .x|69|72) 1 .x|69|72) (cdr:pair .x|69|72))))) (begin (.check! (pair? .x|65|68) 0 .x|65|68) (car:pair .x|65|68))))) (if (let ((.temp|7|10 (not (eq? #f (let ((.x|17|20 (let ((.x|21|24 .entry|3)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 0 .x|17|20) (car:pair .x|17|20))))))) (if .temp|7|10 .temp|7|10 (not (eq? $nop (let ((.x|12|15 .instruction|6)) (begin (.check! (pair? .x|12|15) 0 .x|12|15) (car:pair .x|12|15))))))) (error "Compiler bug: cgframe" .entry|3) (begin (set-car! (let ((.x|25|28 .entry|3)) (begin (.check! (pair? .x|25|28) 1 .x|25|28) (cdr:pair .x|25|28))) .n|3) (set-car! .instruction|6 (let ((.x|30|33 (let ((.x|34|37 .instruction|6)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37))))) (begin (.check! (pair? .x|30|33) 0 .x|30|33) (car:pair .x|30|33)))) (set-cdr! .instruction|6 (let ((.x|39|42 (let ((.x|43|46 .instruction|6)) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46))))) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42)))) (if (eq? $setstk (let ((.x|47|50 .instruction|6)) (begin (.check! (pair? .x|47|50) 0 .x|47|50) (car:pair .x|47|50)))) (set-car! (let ((.x|51|54 .instruction|6)) (begin (.check! (pair? .x|51|54) 1 .x|51|54) (cdr:pair .x|51|54))) .n|3) (set-car! (let ((.x|56|59 (let ((.x|60|63 .instruction|6)) (begin (.check! (pair? .x|60|63) 1 .x|60|63) (cdr:pair .x|60|63))))) (begin (.check! (pair? .x|56|59) 1 .x|56|59) (cdr:pair .x|56|59))) .n|3))))))) (.cgframe:slot.offset-set!|2 .entry|1 .n|1))))) 'cgframe:slot.offset-set!))
(let () (begin (set! cgframe:unused-slot (lambda (.frame|1 .entry|1) (let ((.cgframe:unused-slot|2 0)) (begin (set! .cgframe:unused-slot|2 (lambda (.frame|3 .entry|3) (let* ((.stale|6 (cgframe:slot.stale .entry|3)) (.probe|9 (assq #t .stale|6))) (let () (if .probe|9 (let ((.n|15 (let ((.x|16|19 .probe|9)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19))))) (begin (if (zero? .n|15) (cgframe-used! .frame|3) (unspecified)) (set-car! .probe|9 #f) .n|15)) (let* ((.cell|22 (cgframe-size-cell .frame|3)) (.n|25 (+ 1 (let ((.x|29|32 .cell|22)) (begin (.check! (pair? .x|29|32) 0 .x|29|32) (car:pair .x|29|32)))))) (let () (begin (set-car! .cell|22 .n|25) (if (zero? .n|25) (.cgframe:unused-slot|2 .frame|3 .entry|3) .n|25))))))))) (.cgframe:unused-slot|2 .frame|1 .entry|1))))) 'cgframe:unused-slot))
(let () (begin (set! cgframe-initial (lambda () (let ((.cgframe-initial|2 0)) (begin (set! .cgframe-initial|2 (lambda () (let* ((.t1|4|7 '()) (.t2|4|10 (let* ((.t1|14|17 (cons (cons #t 0) '())) (.t2|14|20 (let* ((.t1|24|27 #f) (.t2|24|30 (cons -1 '()))) (let () (cons .t1|24|27 .t2|24|30))))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))))) (.cgframe-initial|2))))) 'cgframe-initial))
(let () (begin (set! cgframe-livevars cgframe:livevars) 'cgframe-livevars))
(let () (begin (set! cgframe-livevars-set! cgframe:livevars-set!) 'cgframe-livevars-set!))
(let () (begin (set! cgframe-size-cell (lambda (.frame|1) (let ((.cgframe-size-cell|2 0)) (begin (set! .cgframe-size-cell|2 (lambda (.frame|3) (let ((.x|5|8 (let ((.x|9|12 (let ((.x|13|16 .frame|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|5|8) 1 .x|5|8) (cdr:pair .x|5|8))))) (.cgframe-size-cell|2 .frame|1))))) 'cgframe-size-cell))
(let () (begin (set! cgframe-size (lambda (.frame|1) (let ((.cgframe-size|2 0)) (begin (set! .cgframe-size|2 (lambda (.frame|3) (let ((.x|4|7 (cgframe-size-cell .frame|3))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.cgframe-size|2 .frame|1))))) 'cgframe-size))
(let () (begin (set! cgframe-used! (lambda (.frame|1) (let ((.cgframe-used!|2 0)) (begin (set! .cgframe-used!|2 (lambda (.frame|3) (if (< (cgframe-size .frame|3) 0) (set-car! (cgframe-size-cell .frame|3) 0) (unspecified)))) (.cgframe-used!|2 .frame|1))))) 'cgframe-used!))
(let () (begin (set! cgframe-bind! (lambda (.frame|1 .var|1 .instruction|1) (let ((.cgframe-bind!|2 0)) (begin (set! .cgframe-bind!|2 (lambda (.frame|3 .var|3 .instruction|3) (cgframe:slots-set! .frame|3 (cons (let* ((.t1|4|7 .var|3) (.t2|4|10 (let* ((.t1|14|17 #f) (.t2|14|20 (let* ((.t1|24|27 .instruction|3) (.t2|24|30 (cons (cgframe:stale .frame|3) '()))) (let () (cons .t1|24|27 .t2|24|30))))) (let () (cons .t1|14|17 .t2|14|20))))) (let () (cons .t1|4|7 .t2|4|10))) (cgframe:slots .frame|3))))) (.cgframe-bind!|2 .frame|1 .var|1 .instruction|1))))) 'cgframe-bind!))
(let () (begin (set! cgframe-touch! (lambda (.frame|1 .var|1) (let ((.cgframe-touch!|2 0)) (begin (set! .cgframe-touch!|2 (lambda (.frame|3 .var|3) (let ((.entry|6 (assq .var|3 (cgframe:slots .frame|3)))) (if .entry|6 (let ((.n|9 (cgframe:slot.offset .entry|6))) (if (eq? #f .n|9) (let ((.n|12 (cgframe:unused-slot .frame|3 .entry|6))) (cgframe:slot.offset-set! .entry|6 .n|12)) (unspecified))) (error "Compiler bug: cgframe-touch!" .frame|3 .var|3))))) (.cgframe-touch!|2 .frame|1 .var|1))))) 'cgframe-touch!))
(let () (begin (set! cgframe-rename! (lambda (.frame|1 .alist|1) (let ((.cgframe-rename!|2 0)) (begin (set! .cgframe-rename!|2 (lambda (.frame|3 .alist|3) (let () (let ((.loop|9|11|14 (unspecified))) (begin (set! .loop|9|11|14 (lambda (.y1|4|5|15) (if (null? .y1|4|5|15) (if #f #f (unspecified)) (begin (begin #t (let* ((.entry|19 (let ((.x|27|30 .y1|4|5|15)) (begin (.check! (pair? .x|27|30) 0 .x|27|30) (car:pair .x|27|30)))) (.probe|22 (assq (cgframe:slot.name .entry|19) .alist|3))) (if .probe|22 (cgframe:slot.name-set! .entry|19 (let ((.x|23|26 .probe|22)) (begin (.check! (pair? .x|23|26) 1 .x|23|26) (cdr:pair .x|23|26)))) (unspecified)))) (.loop|9|11|14 (let ((.x|31|34 .y1|4|5|15)) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34)))))))) (.loop|9|11|14 (cgframe:slots .frame|3))))))) (.cgframe-rename!|2 .frame|1 .alist|1))))) 'cgframe-rename!))
(let () (begin (set! cgframe-release! (lambda (.frame|1 .var|1) (let ((.cgframe-release!|2 0)) (begin (set! .cgframe-release!|2 (lambda (.frame|3 .var|3) (let* ((.slots|6 (cgframe:slots .frame|3)) (.entry|9 (assq .var|3 .slots|6))) (let () (if .entry|9 (begin (cgframe:slots-set! .frame|3 (remq .entry|9 .slots|6)) (let ((.n|15 (cgframe:slot.offset .entry|9))) (if (if (not (eq? #f .n|15)) (not (zero? .n|15)) #f) (cgframe:stale-set! .frame|3 (cons (cons #t .n|15) (cgframe:stale .frame|3))) (unspecified)))) (unspecified)))))) (.cgframe-release!|2 .frame|1 .var|1))))) 'cgframe-release!))
(let () (begin (set! cgframe-release-except! (lambda (.frame|1 .vars|1) (let ((.cgframe-release-except!|2 0)) (begin (set! .cgframe-release-except!|2 (lambda (.frame|3 .vars|3) (let ((.slots|6 (reverse (cgframe:slots .frame|3))) (.newslots|6 '()) (.stale|6 (cgframe:stale .frame|3))) (let () (let ((.loop|9 (unspecified))) (begin (set! .loop|9 (lambda (.slots|10 .newslots|10 .stale|10) (if (null? .slots|10) (begin (cgframe:slots-set! .frame|3 .newslots|10) (cgframe:stale-set! .frame|3 .stale|10)) (let ((.slot|13 (let ((.x|36|39 .slots|10)) (begin (.check! (pair? .x|36|39) 0 .x|36|39) (car:pair .x|36|39))))) (if (memq (cgframe:slot.name .slot|13) .vars|3) (.loop|9 (let ((.x|14|17 .slots|10)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))) (cons .slot|13 .newslots|10) .stale|10) (let ((.n|20 (cgframe:slot.offset .slot|13))) (if (eq? .n|20 #f) (.loop|9 (let ((.x|22|25 .slots|10)) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))) .newslots|10 .stale|10) (if (zero? .n|20) (.loop|9 (let ((.x|27|30 .slots|10)) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30))) (cons .slot|13 .newslots|10) .stale|10) (.loop|9 (let ((.x|32|35 .slots|10)) (begin (.check! (pair? .x|32|35) 1 .x|32|35) (cdr:pair .x|32|35))) .newslots|10 (cons (cons #t .n|20) .stale|10)))))))))) (.loop|9 .slots|6 .newslots|6 .stale|6))))))) (.cgframe-release-except!|2 .frame|1 .vars|1))))) 'cgframe-release-except!))
(let () (begin (set! cgframe-lookup (lambda (.frame|1 .var|1) (let ((.cgframe-lookup|2 0)) (begin (set! .cgframe-lookup|2 (lambda (.frame|3 .var|3) (let ((.entry|6 (assq .var|3 (cgframe:slots .frame|3)))) (if .entry|6 (let ((.n|9 (cgframe:slot.offset .entry|6))) (begin (if (eq? #f .n|9) (cgframe-touch! .frame|3 .var|3) (unspecified)) (let* ((.t1|10|13 .var|3) (.t2|10|16 (let* ((.t1|20|23 'frame) (.t2|20|26 (let* ((.t1|30|33 (cgframe:slot.offset .entry|6)) (.t2|30|36 (cons '(object) '()))) (let () (cons .t1|30|33 .t2|30|36))))) (let () (cons .t1|20|23 .t2|20|26))))) (let () (cons .t1|10|13 .t2|10|16))))) #f)))) (.cgframe-lookup|2 .frame|1 .var|1))))) 'cgframe-lookup))
(let () (begin (set! cgframe-spilled? (lambda (.frame|1 .var|1) (let ((.cgframe-spilled?|2 0)) (begin (set! .cgframe-spilled?|2 (lambda (.frame|3 .var|3) (let ((.entry|6 (assq .var|3 (cgframe:slots .frame|3)))) (if .entry|6 (let ((.n|9 (cgframe:slot.offset .entry|6))) (not (eq? #f .n|9))) #f)))) (.cgframe-spilled?|2 .frame|1 .var|1))))) 'cgframe-spilled?))
(let () (begin (set! cgframe-copy (lambda (.frame|1) (let ((.cgframe-copy|2 0)) (begin (set! .cgframe-copy|2 (lambda (.frame|3) (cons (let ((.x|4|7 .frame|3)) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))) (cons (let ((.x|9|12 (let ((.x|13|16 .frame|3)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12))) (cons (let ((.x|18|21 (let ((.x|22|25 (let ((.x|26|29 .frame|3)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))) (let ((.x|31|34 (let ((.x|35|38 (let ((.x|39|42 .frame|3)) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 1 .x|35|38) (cdr:pair .x|35|38))))) (begin (.check! (pair? .x|31|34) 1 .x|31|34) (cdr:pair .x|31|34)))))))) (.cgframe-copy|2 .frame|1))))) 'cgframe-copy))
(let () (begin (set! cgframe-update-stale! (lambda (.frame|1) (let ((.cgframe-update-stale!|2 0)) (begin (set! .cgframe-update-stale!|2 (lambda (.frame|3) (let* ((.n|6 (cgframe-size .frame|3)) (.v|9 (make-vector (+ 1 .n|6) #t)) (.stale|12 (cgframe:stale .frame|3))) (let () (begin (let () (let ((.loop|21|23|26 (unspecified))) (begin (set! .loop|21|23|26 (lambda (.y1|16|17|27) (if (null? .y1|16|17|27) (if #f #f (unspecified)) (begin (begin #t (let ((.x|31 (let ((.x|47|50 .y1|16|17|27)) (begin (.check! (pair? .x|47|50) 0 .x|47|50) (car:pair .x|47|50))))) (if (let ((.x|32|35 .x|31)) (begin (.check! (pair? .x|32|35) 0 .x|32|35) (car:pair .x|32|35))) (let ((.i|38 (let ((.x|43|46 .x|31)) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46))))) (if (<= .i|38 .n|6) (let ((.v|39|42 .v|9) (.i|39|42 .i|38) (.x|39|42 #f)) (begin (.check! (fixnum? .i|39|42) 41 .v|39|42 .i|39|42 .x|39|42) (.check! (vector? .v|39|42) 41 .v|39|42 .i|39|42 .x|39|42) (.check! (<:fix:fix .i|39|42 (vector-length:vec .v|39|42)) 41 .v|39|42 .i|39|42 .x|39|42) (.check! (>=:fix:fix .i|39|42 0) 41 .v|39|42 .i|39|42 .x|39|42) (vector-set!:trusted .v|39|42 .i|39|42 .x|39|42))) (unspecified))) (unspecified)))) (.loop|21|23|26 (let ((.x|51|54 .y1|16|17|27)) (begin (.check! (pair? .x|51|54) 1 .x|51|54) (cdr:pair .x|51|54)))))))) (.loop|21|23|26 .stale|12)))) (let () (let ((.loop|60|62|65 (unspecified))) (begin (set! .loop|60|62|65 (lambda (.y1|55|56|66) (if (null? .y1|55|56|66) (if #f #f (unspecified)) (begin (begin #t (let* ((.slot|70 (let ((.x|117|120 .y1|55|56|66)) (begin (.check! (pair? .x|117|120) 0 .x|117|120) (car:pair .x|117|120)))) (.offset|73 (cgframe:slot.offset .slot|70))) (if .offset|73 (let ((.v|74|77 .v|9) (.i|74|77 .offset|73) (.x|74|77 #f)) (begin (.check! (fixnum? .i|74|77) 41 .v|74|77 .i|74|77 .x|74|77) (.check! (vector? .v|74|77) 41 .v|74|77 .i|74|77 .x|74|77) (.check! (<:fix:fix .i|74|77 (vector-length:vec .v|74|77)) 41 .v|74|77 .i|74|77 .x|74|77) (.check! (>=:fix:fix .i|74|77 0) 41 .v|74|77 .i|74|77 .x|74|77) (vector-set!:trusted .v|74|77 .i|74|77 .x|74|77))) (let () (let ((.loop|83|85|88 (unspecified))) (begin (set! .loop|83|85|88 (lambda (.y1|78|79|89) (if (null? .y1|78|79|89) (if #f #f (unspecified)) (begin (begin #t (let ((.stale|93 (let ((.x|109|112 .y1|78|79|89)) (begin (.check! (pair? .x|109|112) 0 .x|109|112) (car:pair .x|109|112))))) (if (let ((.x|94|97 .stale|93)) (begin (.check! (pair? .x|94|97) 0 .x|94|97) (car:pair .x|94|97))) (let ((.i|100 (let ((.x|105|108 .stale|93)) (begin (.check! (pair? .x|105|108) 1 .x|105|108) (cdr:pair .x|105|108))))) (if (< .i|100 .n|6) (let ((.v|101|104 .v|9) (.i|101|104 .i|100) (.x|101|104 #f)) (begin (.check! (fixnum? .i|101|104) 41 .v|101|104 .i|101|104 .x|101|104) (.check! (vector? .v|101|104) 41 .v|101|104 .i|101|104 .x|101|104) (.check! (<:fix:fix .i|101|104 (vector-length:vec .v|101|104)) 41 .v|101|104 .i|101|104 .x|101|104) (.check! (>=:fix:fix .i|101|104 0) 41 .v|101|104 .i|101|104 .x|101|104) (vector-set!:trusted .v|101|104 .i|101|104 .x|101|104))) (unspecified))) (unspecified)))) (.loop|83|85|88 (let ((.x|113|116 .y1|78|79|89)) (begin (.check! (pair? .x|113|116) 1 .x|113|116) (cdr:pair .x|113|116)))))))) (.loop|83|85|88 (cgframe:slot.stale .slot|70)))))))) (.loop|60|62|65 (let ((.x|121|124 .y1|55|56|66)) (begin (.check! (pair? .x|121|124) 1 .x|121|124) (cdr:pair .x|121|124)))))))) (.loop|60|62|65 (cgframe:slots .frame|3))))) (let () (let ((.loop|125|128|131 (unspecified))) (begin (set! .loop|125|128|131 (lambda (.i|132 .stale|132) (if (<= .i|132 0) (cgframe:stale-set! .frame|3 .stale|132) (begin #t (.loop|125|128|131 (- .i|132 1) (if (let ((.v|135|138 .v|9) (.i|135|138 .i|132)) (begin (.check! (fixnum? .i|135|138) 40 .v|135|138 .i|135|138) (.check! (vector? .v|135|138) 40 .v|135|138 .i|135|138) (.check! (<:fix:fix .i|135|138 (vector-length:vec .v|135|138)) 40 .v|135|138 .i|135|138) (.check! (>=:fix:fix .i|135|138 0) 40 .v|135|138 .i|135|138) (vector-ref:trusted .v|135|138 .i|135|138))) (cons (cons #t .i|132) .stale|132) .stale|132)))))) (.loop|125|128|131 .n|6 (filter car .stale|12)))))))))) (.cgframe-update-stale!|2 .frame|1))))) 'cgframe-update-stale!))
(let () (begin (set! cgframe-join! (lambda (.frame1|1 .frame2|1) (let ((.cgframe-join!|2 0)) (begin (set! .cgframe-join!|2 (lambda (.frame1|3 .frame2|3) (let* ((.slots1|6 (cgframe:slots .frame1|3)) (.slots2|9 (cgframe:slots .frame2|3)) (.slots|12 (intersection .slots1|6 .slots2|9)) (.deadslots|15 (append (difference .slots1|6 .slots|12) (difference .slots2|9 .slots|12))) (.deadoffsets|18 (make-set (filter (lambda (.x|59) (not (eq? .x|59 #f))) (let () (let ((.loop|65|68|71 (unspecified))) (begin (set! .loop|65|68|71 (lambda (.y1|60|61|72 .results|60|64|72) (if (null? .y1|60|61|72) (reverse .results|60|64|72) (begin #t (.loop|65|68|71 (let ((.x|76|79 .y1|60|61|72)) (begin (.check! (pair? .x|76|79) 1 .x|76|79) (cdr:pair .x|76|79))) (cons (cgframe:slot.offset (let ((.x|80|83 .y1|60|61|72)) (begin (.check! (pair? .x|80|83) 0 .x|80|83) (car:pair .x|80|83)))) .results|60|64|72)))))) (.loop|65|68|71 .deadslots|15 '()))))))) (.stale1|21 (cgframe:stale .frame1|3)) (.stale2|24 (cgframe:stale .frame2|3)) (.stale|27 (intersection .stale1|21 .stale2|24)) (.stale|30 (append (let () (let ((.loop|39|42|45 (unspecified))) (begin (set! .loop|39|42|45 (lambda (.y1|34|35|46 .results|34|38|46) (if (null? .y1|34|35|46) (reverse .results|34|38|46) (begin #t (.loop|39|42|45 (let ((.x|50|53 .y1|34|35|46)) (begin (.check! (pair? .x|50|53) 1 .x|50|53) (cdr:pair .x|50|53))) (cons (let ((.n|54 (let ((.x|55|58 .y1|34|35|46)) (begin (.check! (pair? .x|55|58) 0 .x|55|58) (car:pair .x|55|58))))) (cons #t .n|54)) .results|34|38|46)))))) (.loop|39|42|45 .deadoffsets|18 '())))) .stale|27))) (let () (begin (cgframe:slots-set! .frame1|3 .slots|12) (cgframe:stale-set! .frame1|3 .stale|30)))))) (.cgframe-join!|2 .frame1|1 .frame2|1))))) 'cgframe-join!))
(let () (begin (set! entry.name car) 'entry.name))
(let () (begin (set! entry.kind cadr) 'entry.kind))
(let () (begin (set! entry.rib caddr) 'entry.rib))
(let () (begin (set! entry.offset cadddr) 'entry.offset))
(let () (begin (set! entry.label cadddr) 'entry.label))
(let () (begin (set! entry.regnum caddr) 'entry.regnum))
(let () (begin (set! entry.slotnum caddr) 'entry.slotnum))
(let () (begin (set! entry.arity caddr) 'entry.arity))
(let () (begin (set! entry.op cadddr) 'entry.op))
(let () (begin (set! entry.imm (lambda (.entry|1) (let ((.entry.imm|2 0)) (begin (set! .entry.imm|2 (lambda (.entry|3) (let ((.x|4|7 (let ((.x|9|12 (let ((.x|13|16 (let ((.x|17|20 (let ((.x|21|24 .entry|3)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))))) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))))) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.entry.imm|2 .entry|1))))) 'entry.imm))
(let () (begin (set! cgenv-initial (lambda (.integrable|1) (let ((.cgenv-initial|2 0)) (begin (set! .cgenv-initial|2 (lambda (.integrable|3) (cons (let () (let ((.loop|10|13|16 (unspecified))) (begin (set! .loop|10|13|16 (lambda (.y1|5|6|17 .results|5|9|17) (if (null? .y1|5|6|17) (reverse .results|5|9|17) (begin #t (.loop|10|13|16 (let ((.x|21|24 .y1|5|6|17)) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24))) (cons (let* ((.x|25 (let ((.x|120|123 .y1|5|6|17)) (begin (.check! (pair? .x|120|123) 0 .x|120|123) (car:pair .x|120|123)))) (.t1|26|29 (let ((.x|116|119 .x|25)) (begin (.check! (pair? .x|116|119) 0 .x|116|119) (car:pair .x|116|119)))) (.t2|26|32 (let* ((.t1|36|39 'integrable) (.t2|36|42 (let* ((.t1|46|49 (let ((.x|108|111 (let ((.x|112|115 .x|25)) (begin (.check! (pair? .x|112|115) 1 .x|112|115) (cdr:pair .x|112|115))))) (begin (.check! (pair? .x|108|111) 0 .x|108|111) (car:pair .x|108|111)))) (.t2|46|52 (let* ((.t1|56|59 (let ((.x|95|98 (let ((.x|99|102 (let ((.x|103|106 .x|25)) (begin (.check! (pair? .x|103|106) 1 .x|103|106) (cdr:pair .x|103|106))))) (begin (.check! (pair? .x|99|102) 1 .x|99|102) (cdr:pair .x|99|102))))) (begin (.check! (pair? .x|95|98) 0 .x|95|98) (car:pair .x|95|98)))) (.t2|56|62 (let* ((.t1|66|69 (let ((.x|78|81 (let ((.x|82|85 (let ((.x|86|89 (let ((.x|90|93 .x|25)) (begin (.check! (pair? .x|90|93) 1 .x|90|93) (cdr:pair .x|90|93))))) (begin (.check! (pair? .x|86|89) 1 .x|86|89) (cdr:pair .x|86|89))))) (begin (.check! (pair? .x|82|85) 1 .x|82|85) (cdr:pair .x|82|85))))) (begin (.check! (pair? .x|78|81) 0 .x|78|81) (car:pair .x|78|81)))) (.t2|66|72 (cons '(object) '()))) (let () (cons .t1|66|69 .t2|66|72))))) (let () (cons .t1|56|59 .t2|56|62))))) (let () (cons .t1|46|49 .t2|46|52))))) (let () (cons .t1|36|39 .t2|36|42))))) (let () (cons .t1|26|29 .t2|26|32))) .results|5|9|17)))))) (.loop|10|13|16 .integrable|3 '())))) '()))) (.cgenv-initial|2 .integrable|1))))) 'cgenv-initial))
(let () (begin (set! cgenv-lookup (lambda (.env|1 .id|1) (let ((.cgenv-lookup|2 0)) (begin (set! .cgenv-lookup|2 (lambda (.env|3 .id|3) (let ((.loop|4 (unspecified))) (begin (set! .loop|4 (lambda (.ribs|5 .m|5) (if (null? .ribs|5) (cons .id|3 '(global (object))) (let ((.x|8 (assq .id|3 (let ((.x|66|69 .ribs|5)) (begin (.check! (pair? .x|66|69) 0 .x|66|69) (car:pair .x|66|69)))))) (if .x|8 (let ((.temp|9|12 (let ((.x|54|57 (let ((.x|58|61 .x|8)) (begin (.check! (pair? .x|58|61) 1 .x|58|61) (cdr:pair .x|58|61))))) (begin (.check! (pair? .x|54|57) 0 .x|54|57) (car:pair .x|54|57))))) (if (memv .temp|9|12 '(lexical)) (cons .id|3 (cons (let ((.x|15|18 (let ((.x|19|22 .x|8)) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22))))) (begin (.check! (pair? .x|15|18) 0 .x|15|18) (car:pair .x|15|18))) (cons .m|5 (let ((.x|24|27 (let ((.x|28|31 .x|8)) (begin (.check! (pair? .x|28|31) 1 .x|28|31) (cdr:pair .x|28|31))))) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27)))))) (if (memv .temp|9|12 '(procedure)) (cons .id|3 (cons (let ((.x|34|37 (let ((.x|38|41 .x|8)) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41))))) (begin (.check! (pair? .x|34|37) 0 .x|34|37) (car:pair .x|34|37))) (cons .m|5 (let ((.x|43|46 (let ((.x|47|50 .x|8)) (begin (.check! (pair? .x|47|50) 1 .x|47|50) (cdr:pair .x|47|50))))) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46)))))) (if (memv .temp|9|12 '(integrable)) (if (integrate-usual-procedures) .x|8 (.loop|4 '() .m|5)) ???)))) (.loop|4 (let ((.x|62|65 .ribs|5)) (begin (.check! (pair? .x|62|65) 1 .x|62|65) (cdr:pair .x|62|65))) (+ .m|5 1))))))) (.loop|4 .env|3 0))))) (.cgenv-lookup|2 .env|1 .id|1))))) 'cgenv-lookup))
(let () (begin (set! cgenv-extend (lambda (.env|1 .vars|1 .procs|1) (let ((.cgenv-extend|2 0)) (begin (set! .cgenv-extend|2 (lambda (.env|3 .vars|3 .procs|3) (cons (let () (let ((.loop|4|8|11 (unspecified))) (begin (set! .loop|4|8|11 (lambda (.n|12 .vars|12 .rib|12) (if (null? .vars|12) .rib|12 (begin #t (.loop|4|8|11 (+ .n|12 1) (let ((.x|15|18 .vars|12)) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))) (cons (let* ((.t1|19|22 (let ((.x|50|53 .vars|12)) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53)))) (.t2|19|25 (let* ((.t1|29|32 'lexical) (.t2|29|35 (let* ((.t1|39|42 .n|12) (.t2|39|45 (cons '(object) '()))) (let () (cons .t1|39|42 .t2|39|45))))) (let () (cons .t1|29|32 .t2|29|35))))) (let () (cons .t1|19|22 .t2|19|25))) .rib|12)))))) (.loop|4|8|11 0 .vars|3 (let () (let ((.loop|59|62|65 (unspecified))) (begin (set! .loop|59|62|65 (lambda (.y1|54|55|66 .results|54|58|66) (if (null? .y1|54|55|66) (reverse .results|54|58|66) (begin #t (.loop|59|62|65 (let ((.x|70|73 .y1|54|55|66)) (begin (.check! (pair? .x|70|73) 1 .x|70|73) (cdr:pair .x|70|73))) (cons (let* ((.id|74 (let ((.x|106|109 .y1|54|55|66)) (begin (.check! (pair? .x|106|109) 0 .x|106|109) (car:pair .x|106|109)))) (.t1|75|78 .id|74) (.t2|75|81 (let* ((.t1|85|88 'procedure) (.t2|85|91 (let* ((.t1|95|98 (make-label)) (.t2|95|101 (cons '(object) '()))) (let () (cons .t1|95|98 .t2|95|101))))) (let () (cons .t1|85|88 .t2|85|91))))) (let () (cons .t1|75|78 .t2|75|81))) .results|54|58|66)))))) (.loop|59|62|65 .procs|3 '())))))))) .env|3))) (.cgenv-extend|2 .env|1 .vars|1 .procs|1))))) 'cgenv-extend))
(let () (begin (set! cgenv-bindprocs (lambda (.env|1 .procs|1) (let ((.cgenv-bindprocs|2 0)) (begin (set! .cgenv-bindprocs|2 (lambda (.env|3 .procs|3) (cons (append (let () (let ((.loop|9|12|15 (unspecified))) (begin (set! .loop|9|12|15 (lambda (.y1|4|5|16 .results|4|8|16) (if (null? .y1|4|5|16) (reverse .results|4|8|16) (begin #t (.loop|9|12|15 (let ((.x|20|23 .y1|4|5|16)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) (cons (let* ((.id|24 (let ((.x|56|59 .y1|4|5|16)) (begin (.check! (pair? .x|56|59) 0 .x|56|59) (car:pair .x|56|59)))) (.t1|25|28 .id|24) (.t2|25|31 (let* ((.t1|35|38 'procedure) (.t2|35|41 (let* ((.t1|45|48 (make-label)) (.t2|45|51 (cons '(object) '()))) (let () (cons .t1|45|48 .t2|45|51))))) (let () (cons .t1|35|38 .t2|35|41))))) (let () (cons .t1|25|28 .t2|25|31))) .results|4|8|16)))))) (.loop|9|12|15 .procs|3 '())))) (let ((.x|60|63 .env|3)) (begin (.check! (pair? .x|60|63) 0 .x|60|63) (car:pair .x|60|63)))) (let ((.x|64|67 .env|3)) (begin (.check! (pair? .x|64|67) 1 .x|64|67) (cdr:pair .x|64|67)))))) (.cgenv-bindprocs|2 .env|1 .procs|1))))) 'cgenv-bindprocs))
(let () (begin (set! var-lookup (lambda (.var|1 .regs|1 .frame|1 .env|1) (let ((.var-lookup|2 0)) (begin (set! .var-lookup|2 (lambda (.var|3 .regs|3 .frame|3 .env|3) (let ((.temp|4|7 (cgreg-lookup .regs|3 .var|3))) (if .temp|4|7 .temp|4|7 (let ((.temp|8|11 (cgframe-lookup .frame|3 .var|3))) (if .temp|8|11 .temp|8|11 (cgenv-lookup .env|3 .var|3))))))) (.var-lookup|2 .var|1 .regs|1 .frame|1 .env|1))))) 'var-lookup))
(let () (begin (set! compile (lambda (.x|1) (pass4 (pass3 (pass2 (pass1 .x|1))) $usual-integrable-procedures$))) 'compile))
(let () (begin (set! compile-block (lambda (.x|1) (pass4 (pass3 (pass2 (pass1-block .x|1))) $usual-integrable-procedures$))) 'compile-block))
(let () (begin (set! foo (lambda (.x|1) (pretty-print (compile .x|1)))) 'foo))
(let () (begin (set! minregs (lambda (.x|1) (let ((.minregs|2 0)) (begin (set! .minregs|2 (lambda (.x|3) (let ((.defregs|4 (unspecified))) (begin (set! .defregs|4 (lambda (.r|5) (begin (set! *nregs* .r|5) (set! *lastreg* (- *nregs* 1)) (set! *fullregs* (quotient *nregs* 2))))) (.defregs|4 32) (let* ((.code|8 (assemble (compile .x|3))) (.binary-search|9 (unspecified))) (begin (set! .binary-search|9 (lambda (.m1|10 .m2|10) (if (= (+ .m1|10 1) .m2|10) .m2|10 (let ((.midpt|13 (quotient (+ .m1|10 .m2|10) 2))) (begin (.defregs|4 .midpt|13) (if (equal? .code|8 (assemble (compile .x|3))) (.binary-search|9 .m1|10 .midpt|13) (.binary-search|9 .midpt|13 .m2|10))))))) (.defregs|4 4) (let ((.newcode|16 (assemble (compile .x|3)))) (if (equal? .code|8 .newcode|16) 4 (.binary-search|9 4 32))))))))) (.minregs|2 .x|1))))) 'minregs))
(let () (begin (set! pass4 (lambda (.exp|1 .integrable|1) (let ((.pass4|2 0)) (begin (set! .pass4|2 (lambda (.exp|3 .integrable|3) (begin (init-labels) (init-temps) (let ((.output|6 (make-assembly-stream)) (.frame|6 (cgframe-initial)) (.regs|6 (cgreg-initial)) (.t0|6 (newtemp))) (begin (assembly-stream-info! .output|6 (make-hashtable equal-hash assoc)) (cgreg-bind! .regs|6 0 .t0|6) (gen-save! .output|6 .frame|6 .t0|6) (cg0 .output|6 .exp|3 'result .regs|6 .frame|6 (cgenv-initial .integrable|3) #t) (pass4-code .output|6)))))) (.pass4|2 .exp|1 .integrable|1))))) 'pass4))
(let () (begin (set! pass4-code (lambda (.output|1) (let ((.pass4-code|2 0)) (begin (set! .pass4-code|2 (lambda (.output|3) (begin (hashtable-for-each (lambda (.situation|4 .label|4) (cg-trap .output|3 .situation|4 .label|4)) (assembly-stream-info .output|3)) (assembly-stream-code .output|3)))) (.pass4-code|2 .output|1))))) 'pass4-code))
(let () (begin (set! cg0 (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg0|2 0)) (begin (set! .cg0|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.temp|4|7 (let ((.x|14|17 .exp|3)) (begin (.check! (pair? .x|14|17) 0 .x|14|17) (car:pair .x|14|17))))) (if (memv .temp|4|7 '(quote)) (begin (gen! .output|3 $const (constant.value .exp|3)) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (cg-move .output|3 .frame|3 .regs|3 'result .target|3))) (if (memv .temp|4|7 '(lambda)) (begin (cg-lambda .output|3 .exp|3 .regs|3 .frame|3 .env|3) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (cg-move .output|3 .frame|3 .regs|3 'result .target|3))) (if (memv .temp|4|7 '(set!)) (begin (.cg0|2 .output|3 (assignment.rhs .exp|3) 'result .regs|3 .frame|3 .env|3 #f) (cg-assignment-result .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)) (if (memv .temp|4|7 '(if)) (cg-if .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (memv .temp|4|7 '(begin)) (if (variable? .exp|3) (cg-variable .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (cg-sequential .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)) (cg-call .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3))))))))) (.cg0|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg0))
(let () (begin (set! cg-lambda (lambda (.output|1 .exp|1 .regs|1 .frame|1 .env|1) (let ((.cg-lambda|2 0)) (begin (set! .cg-lambda|2 (lambda (.output|3 .exp|3 .regs|3 .frame|3 .env|3) (let* ((.args|6 (lambda.args .exp|3)) (.vars|9 (make-null-terminated .args|6)) (.free|12 (difference (lambda.f .exp|3) .vars|9)) (.free|15 (cg-sort-vars .free|12 .regs|3 .frame|3 .env|3)) (.newenv|18 (cgenv-extend .env|3 (cons #t .free|15) '())) (.newoutput|21 (make-assembly-stream))) (let () (begin (assembly-stream-info! .newoutput|21 (make-hashtable equal-hash assoc)) (gen! .newoutput|21 $.proc) (if (list? .args|6) (gen! .newoutput|21 $args= (length .args|6)) (gen! .newoutput|21 $args>= (- (length .vars|9) 1))) (cg-known-lambda .newoutput|21 .exp|3 .newenv|18) (cg-eval-vars .output|3 .free|15 .regs|3 .frame|3 .env|3) '(if (not (ignore-space-leaks)) (begin (gen! output $const #f) (gen! output $setreg 0))) (gen! .output|3 $lambda (pass4-code .newoutput|21) (length .free|15) (lambda.doc .exp|3)) '(if (not (ignore-space-leaks)) (gen-load! output frame 0 (cgreg-lookup-reg regs 0)))))))) (.cg-lambda|2 .output|1 .exp|1 .regs|1 .frame|1 .env|1))))) 'cg-lambda))
(let () (begin (set! cg-sort-vars (lambda (.free|1 .regs|1 .frame|1 .env|1) (let ((.cg-sort-vars|2 0)) (begin (set! .cg-sort-vars|2 (lambda (.free|3 .regs|3 .frame|3 .env|3) (let* ((.free|6 (filter (lambda (.var|74) (let ((.temp|75|78 (entry.kind (var-lookup .var|74 .regs|3 .frame|3 .env|3)))) (if (memv .temp|75|78 '(register frame)) #t (if (memv .temp|75|78 '(lexical)) (not (ignore-space-leaks)) #f)))) .free|3)) (.n|9 (length .free|6)) (.m|12 (min .n|9 (- *nregs* 1))) (.vec|15 (make-vector .m|12 #f))) (let () (let ((.loop2|19 (unspecified)) (.loop1|19 (unspecified))) (begin (set! .loop2|19 (lambda (.i|20 .free|20) (if (null? .free|20) (vector->list .vec|15) (if (= .i|20 .m|12) (append (vector->list .vec|15) .free|20) (if (let ((.v|24|27 .vec|15) (.i|24|27 .i|20)) (begin (.check! (fixnum? .i|24|27) 40 .v|24|27 .i|24|27) (.check! (vector? .v|24|27) 40 .v|24|27 .i|24|27) (.check! (<:fix:fix .i|24|27 (vector-length:vec .v|24|27)) 40 .v|24|27 .i|24|27) (.check! (>=:fix:fix .i|24|27 0) 40 .v|24|27 .i|24|27) (vector-ref:trusted .v|24|27 .i|24|27))) (.loop2|19 (+ .i|20 1) .free|20) (begin (let ((.v|29|32 .vec|15) (.i|29|32 .i|20) (.x|29|32 (let ((.x|33|36 .free|20)) (begin (.check! (pair? .x|33|36) 0 .x|33|36) (car:pair .x|33|36))))) (begin (.check! (fixnum? .i|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (vector? .v|29|32) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (<:fix:fix .i|29|32 (vector-length:vec .v|29|32)) 41 .v|29|32 .i|29|32 .x|29|32) (.check! (>=:fix:fix .i|29|32 0) 41 .v|29|32 .i|29|32 .x|29|32) (vector-set!:trusted .v|29|32 .i|29|32 .x|29|32))) (.loop2|19 (+ .i|20 1) (let ((.x|37|40 .free|20)) (begin (.check! (pair? .x|37|40) 1 .x|37|40) (cdr:pair .x|37|40)))))))))) (set! .loop1|19 (lambda (.free|41 .free-notregister|41) (if (null? .free|41) (.loop2|19 0 .free-notregister|41) (let* ((.var|44 (let ((.x|70|73 .free|41)) (begin (.check! (pair? .x|70|73) 0 .x|70|73) (car:pair .x|70|73)))) (.entry|47 (cgreg-lookup .regs|3 .var|44))) (let () (if .entry|47 (let ((.r|53 (entry.regnum .entry|47))) (if (<= .r|53 .n|9) (begin (let ((.v|54|57 .vec|15) (.i|54|57 (- .r|53 1)) (.x|54|57 .var|44)) (begin (.check! (fixnum? .i|54|57) 41 .v|54|57 .i|54|57 .x|54|57) (.check! (vector? .v|54|57) 41 .v|54|57 .i|54|57 .x|54|57) (.check! (<:fix:fix .i|54|57 (vector-length:vec .v|54|57)) 41 .v|54|57 .i|54|57 .x|54|57) (.check! (>=:fix:fix .i|54|57 0) 41 .v|54|57 .i|54|57 .x|54|57) (vector-set!:trusted .v|54|57 .i|54|57 .x|54|57))) (.loop1|19 (let ((.x|58|61 .free|41)) (begin (.check! (pair? .x|58|61) 1 .x|58|61) (cdr:pair .x|58|61))) .free-notregister|41)) (.loop1|19 (let ((.x|62|65 .free|41)) (begin (.check! (pair? .x|62|65) 1 .x|62|65) (cdr:pair .x|62|65))) (cons .var|44 .free-notregister|41)))) (.loop1|19 (let ((.x|66|69 .free|41)) (begin (.check! (pair? .x|66|69) 1 .x|66|69) (cdr:pair .x|66|69))) (cons .var|44 .free-notregister|41)))))))) (.loop1|19 .free|6 '()))))))) (.cg-sort-vars|2 .free|1 .regs|1 .frame|1 .env|1))))) 'cg-sort-vars))
(let () (begin (set! cg-eval-vars (lambda (.output|1 .free|1 .regs|1 .frame|1 .env|1) (let ((.cg-eval-vars|2 0)) (begin (set! .cg-eval-vars|2 (lambda (.output|3 .free|3 .regs|3 .frame|3 .env|3) (let ((.n|6 (length .free|3)) (.r-1|6 (- *nregs* 1))) (begin (if (>= .n|6 .r-1|6) (begin (gen! .output|3 $const '()) (gen! .output|3 $setreg .r-1|6) (cgreg-release! .regs|3 .r-1|6)) (unspecified)) (let () (let ((.loop|8|11|14 (unspecified))) (begin (set! .loop|8|11|14 (lambda (.r|15 .vars|15) (if (zero? .r|15) (if #f #f (unspecified)) (begin (begin #t (let* ((.v|20 (let ((.x|39|42 .vars|15)) (begin (.check! (pair? .x|39|42) 0 .x|39|42) (car:pair .x|39|42)))) (.entry|23 (var-lookup .v|20 .regs|3 .frame|3 .env|3))) (let () (begin (let ((.temp|27|30 (entry.kind .entry|23))) (if (memv .temp|27|30 '(register)) (let ((.r1|34 (entry.regnum .entry|23))) (if (not (eqv? .r|15 .r1|34)) (if (< .r|15 .r-1|6) (begin (gen! .output|3 $movereg .r1|34 .r|15) (cgreg-bind! .regs|3 .r|15 .v|20)) (gen! .output|3 $reg .r1|34 .v|20)) (unspecified))) (if (memv .temp|27|30 '(frame)) (if (< .r|15 .r-1|6) (begin (gen-load! .output|3 .frame|3 .r|15 .v|20) (cgreg-bind! .regs|3 .r|15 .v|20)) (gen-stack! .output|3 .frame|3 .v|20)) (if (memv .temp|27|30 '(lexical)) (begin (gen! .output|3 $lexical (entry.rib .entry|23) (entry.offset .entry|23) .v|20) (if (< .r|15 .r-1|6) (begin (gen! .output|3 $setreg .r|15) (cgreg-bind! .regs|3 .r|15 .v|20) (gen-store! .output|3 .frame|3 .r|15 .v|20)) (unspecified))) (error "Bug in cg-close-lambda"))))) (if (>= .r|15 .r-1|6) (begin (gen! .output|3 $op2 $cons .r-1|6) (gen! .output|3 $setreg .r-1|6)) (unspecified)))))) (.loop|8|11|14 (- .r|15 1) (let ((.x|43|46 .vars|15)) (begin (.check! (pair? .x|43|46) 1 .x|43|46) (cdr:pair .x|43|46)))))))) (.loop|8|11|14 .n|6 (reverse .free|3))))))))) (.cg-eval-vars|2 .output|1 .free|1 .regs|1 .frame|1 .env|1))))) 'cg-eval-vars))
(let () (begin (set! cg-known-lambda (lambda (.output|1 .exp|1 .env|1) (let ((.cg-known-lambda|2 0)) (begin (set! .cg-known-lambda|2 (lambda (.output|3 .exp|3 .env|3) (let* ((.vars|6 (make-null-terminated (lambda.args .exp|3))) (.regs|9 (cgreg-initial)) (.frame|12 (cgframe-initial)) (.t0|15 (newtemp))) (let () (begin (if (member a-normal-form-declaration (lambda.decls .exp|3)) (cgframe-livevars-set! .frame|12 '()) (unspecified)) (cgreg-bind! .regs|9 0 .t0|15) (gen-save! .output|3 .frame|12 .t0|15) (let () (let ((.loop|19|22|25 (unspecified))) (begin (set! .loop|19|22|25 (lambda (.r|26 .vars|26) (if (let ((.temp|28|31 (null? .vars|26))) (if .temp|28|31 .temp|28|31 (= .r|26 *lastreg*))) (if (not (null? .vars|26)) (begin (gen! .output|3 $movereg *lastreg* 1) (cgreg-release! .regs|9 1) (let () (let ((.loop|34|36|39 (unspecified))) (begin (set! .loop|34|36|39 (lambda (.vars|40) (if (null? .vars|40) (if #f #f (unspecified)) (begin (begin #t (gen! .output|3 $reg 1) (gen! .output|3 $op1 $car:pair) (gen-setstk! .output|3 .frame|12 (let ((.x|43|46 .vars|40)) (begin (.check! (pair? .x|43|46) 0 .x|43|46) (car:pair .x|43|46)))) (gen! .output|3 $reg 1) (gen! .output|3 $op1 $cdr:pair) (gen! .output|3 $setreg 1)) (.loop|34|36|39 (let ((.x|47|50 .vars|40)) (begin (.check! (pair? .x|47|50) 1 .x|47|50) (cdr:pair .x|47|50)))))))) (.loop|34|36|39 .vars|26))))) (unspecified)) (begin (begin #t (cgreg-bind! .regs|9 .r|26 (let ((.x|52|55 .vars|26)) (begin (.check! (pair? .x|52|55) 0 .x|52|55) (car:pair .x|52|55)))) (gen-store! .output|3 .frame|12 .r|26 (let ((.x|56|59 .vars|26)) (begin (.check! (pair? .x|56|59) 0 .x|56|59) (car:pair .x|56|59))))) (.loop|19|22|25 (+ .r|26 1) (let ((.x|60|63 .vars|26)) (begin (.check! (pair? .x|60|63) 1 .x|60|63) (cdr:pair .x|60|63)))))))) (.loop|19|22|25 1 .vars|6)))) (cg-body .output|3 .exp|3 'result .regs|9 .frame|12 .env|3 #t)))))) (.cg-known-lambda|2 .output|1 .exp|1 .env|1))))) 'cg-known-lambda))
(let () (begin (set! cg-body (lambda (.output|1 .l|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-body|2 0)) (begin (set! .cg-body|2 (lambda (.output|3 .l|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.exp|6 (lambda.body .l|3)) (.defs|9 (lambda.defs .l|3)) (.free|12 (apply-union (let () (let ((.loop|153|156|159 (unspecified))) (begin (set! .loop|153|156|159 (lambda (.y1|148|149|160 .results|148|152|160) (if (null? .y1|148|149|160) (reverse .results|148|152|160) (begin #t (.loop|153|156|159 (let ((.x|164|167 .y1|148|149|160)) (begin (.check! (pair? .x|164|167) 1 .x|164|167) (cdr:pair .x|164|167))) (cons (let* ((.def|168 (let ((.x|172|175 .y1|148|149|160)) (begin (.check! (pair? .x|172|175) 0 .x|172|175) (car:pair .x|172|175)))) (.l|171 (def.rhs .def|168))) (difference (lambda.f .l|171) (lambda.args .l|171))) .results|148|152|160)))))) (.loop|153|156|159 .defs|9 '()))))))) (let () (if (let ((.temp|17|20 (null? .defs|9))) (if .temp|17|20 .temp|17|20 (let ((.temp|21|24 (constant? .exp|6))) (if .temp|21|24 .temp|21|24 (variable? .exp|6))))) (cg0 .output|3 .exp|6 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (lambda? .exp|6) (let* ((.free|29 (cg-sort-vars (union .free|12 (difference (lambda.f .exp|6) (make-null-terminated (lambda.args .exp|6)))) .regs|3 .frame|3 .env|3)) (.newenv1|32 (cgenv-extend .env|3 (cons #t .free|29) (let () (let ((.loop|50|53|56 (unspecified))) (begin (set! .loop|50|53|56 (lambda (.y1|45|46|57 .results|45|49|57) (if (null? .y1|45|46|57) (reverse .results|45|49|57) (begin #t (.loop|50|53|56 (let ((.x|61|64 .y1|45|46|57)) (begin (.check! (pair? .x|61|64) 1 .x|61|64) (cdr:pair .x|61|64))) (cons (def.lhs (let ((.x|65|68 .y1|45|46|57)) (begin (.check! (pair? .x|65|68) 0 .x|65|68) (car:pair .x|65|68)))) .results|45|49|57)))))) (.loop|50|53|56 .defs|9 '())))))) (.args|35 (lambda.args .exp|6)) (.vars|38 (make-null-terminated .args|35)) (.newoutput|41 (make-assembly-stream))) (let () (begin (assembly-stream-info! .newoutput|41 (make-hashtable equal-hash assoc)) (gen! .newoutput|41 $.proc) (if (list? .args|35) (gen! .newoutput|41 $args= (length .args|35)) (gen! .newoutput|41 $args>= (- (length .vars|38) 1))) (cg-known-lambda .newoutput|41 .exp|6 .newenv1|32) (cg-defs .newoutput|41 .defs|9 .newenv1|32) (cg-eval-vars .output|3 .free|29 .regs|3 .frame|3 .env|3) (gen! .output|3 $lambda (pass4-code .newoutput|41) (length .free|29) (lambda.doc .exp|6)) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (cg-move .output|3 .frame|3 .regs|3 'result .target|3))))) (if (every? (lambda (.def|70) (every? (lambda (.v|71) (let ((.temp|72|75 (entry.kind (var-lookup .v|71 .regs|3 .frame|3 .env|3)))) (if (memv .temp|72|75 '(register frame)) #f #t))) (let ((.ldef|80 (def.rhs .def|70))) (difference (lambda.f .ldef|80) (lambda.args .ldef|80))))) .defs|9) (let* ((.newenv|83 (cgenv-bindprocs .env|3 (let () (let ((.loop|98|101|104 (unspecified))) (begin (set! .loop|98|101|104 (lambda (.y1|93|94|105 .results|93|97|105) (if (null? .y1|93|94|105) (reverse .results|93|97|105) (begin #t (.loop|98|101|104 (let ((.x|109|112 .y1|93|94|105)) (begin (.check! (pair? .x|109|112) 1 .x|109|112) (cdr:pair .x|109|112))) (cons (def.lhs (let ((.x|113|116 .y1|93|94|105)) (begin (.check! (pair? .x|113|116) 0 .x|113|116) (car:pair .x|113|116)))) .results|93|97|105)))))) (.loop|98|101|104 .defs|9 '())))))) (.l|86 (make-label)) (.r|89 (cg0 .output|3 .exp|6 .target|3 .regs|3 .frame|3 .newenv|83 .tail?|3))) (let () (begin (if (not .tail?|3) (gen! .output|3 $skip .l|86 (cgreg-live .regs|3 .r|89)) (unspecified)) (cg-defs .output|3 .defs|9 .newenv|83) (if (not .tail?|3) (gen! .output|3 $.label .l|86) (unspecified)) .r|89))) (let ((.free|120 (cg-sort-vars .free|12 .regs|3 .frame|3 .env|3))) (begin (cg-eval-vars .output|3 .free|120 .regs|3 .frame|3 .env|3) '(if (not (ignore-space-leaks)) (begin (gen! output $const #f) (gen! output $setreg 0))) (let ((.t0|123 (cgreg-lookup-reg .regs|3 0)) (.t1|123 (newtemp)) (.newenv|123 (cgenv-extend .env|3 (cons #t .free|120) (let () (let ((.loop|129|132|135 (unspecified))) (begin (set! .loop|129|132|135 (lambda (.y1|124|125|136 .results|124|128|136) (if (null? .y1|124|125|136) (reverse .results|124|128|136) (begin #t (.loop|129|132|135 (let ((.x|140|143 .y1|124|125|136)) (begin (.check! (pair? .x|140|143) 1 .x|140|143) (cdr:pair .x|140|143))) (cons (def.lhs (let ((.x|144|147 .y1|124|125|136)) (begin (.check! (pair? .x|144|147) 0 .x|144|147) (car:pair .x|144|147)))) .results|124|128|136)))))) (.loop|129|132|135 .defs|9 '())))))) (.l|123 (make-label))) (begin (gen! .output|3 $lexes (length .free|120) .free|120) (gen! .output|3 $setreg 0) (cgreg-bind! .regs|3 0 .t1|123) (if .tail?|3 (begin (cgframe-release! .frame|3 .t0|123) (gen-store! .output|3 .frame|3 0 .t1|123) (cg0 .output|3 .exp|6 'result .regs|3 .frame|3 .newenv|123 #t) (cg-defs .output|3 .defs|9 .newenv|123) 'result) (begin (gen-store! .output|3 .frame|3 0 .t1|123) (cg0 .output|3 .exp|6 'result .regs|3 .frame|3 .newenv|123 #f) (gen! .output|3 $skip .l|123 (cgreg-tos .regs|3)) (cg-defs .output|3 .defs|9 .newenv|123) (gen! .output|3 $.label .l|123) (gen-load! .output|3 .frame|3 0 .t0|123) (cgreg-bind! .regs|3 0 .t0|123) (cgframe-release! .frame|3 .t1|123) (cg-move .output|3 .frame|3 .regs|3 'result .target|3)))))))))))))) (.cg-body|2 .output|1 .l|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-body))
(let () (begin (set! cg-defs (lambda (.output|1 .defs|1 .env|1) (let ((.cg-defs|2 0)) (begin (set! .cg-defs|2 (lambda (.output|3 .defs|3 .env|3) (let ((.f|4|7|10 (lambda (.def|30) (begin (gen! .output|3 $.align 4) (gen! .output|3 $.label (entry.label (cgenv-lookup .env|3 (def.lhs .def|30)))) (gen! .output|3 $.proc) (gen! .output|3 $.proc-doc (lambda.doc (def.rhs .def|30))) (cg-known-lambda .output|3 (def.rhs .def|30) .env|3))))) (let () (let ((.loop|12|14|17 (unspecified))) (begin (set! .loop|12|14|17 (lambda (.y1|4|5|18) (if (null? .y1|4|5|18) (if #f #f (unspecified)) (begin (begin #t (.f|4|7|10 (let ((.x|22|25 .y1|4|5|18)) (begin (.check! (pair? .x|22|25) 0 .x|22|25) (car:pair .x|22|25))))) (.loop|12|14|17 (let ((.x|26|29 .y1|4|5|18)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29)))))))) (.loop|12|14|17 .defs|3))))))) (.cg-defs|2 .output|1 .defs|1 .env|1))))) 'cg-defs))
(let () (begin (set! cg-assignment-result (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-assignment-result|2 0)) (begin (set! .cg-assignment-result|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (begin (gen! .output|3 $setglbl (assignment.lhs .exp|3)) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (cg-move .output|3 .frame|3 .regs|3 'result .target|3))))) (.cg-assignment-result|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-assignment-result))
(let () (begin (set! cg-if (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-if|2 0)) (begin (set! .cg-if|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (constant? (if.test .exp|3)) (cg0 .output|3 (if (constant.value (if.test .exp|3)) (if.then .exp|3) (if.else .exp|3)) .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (begin (cg0 .output|3 (if.test .exp|3) 'result .regs|3 .frame|3 .env|3 #f) (cg-if-result .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3))))) (.cg-if|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-if))
(let () (begin (set! cg-if-result (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-if-result|2 0)) (begin (set! .cg-if-result|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.l1|6 (make-label)) (.l2|6 (make-label))) (begin (gen! .output|3 $branchf .l1|6 (cgreg-tos .regs|3)) (let* ((.regs2|9 (cgreg-copy .regs|3)) (.frame1|12 (if (if .tail?|3 (< (cgframe-size .frame|3) 0) #f) (cgframe-initial) .frame|3)) (.frame2|15 (if (eq? .frame|3 .frame1|12) (cgframe-copy .frame1|12) (cgframe-initial))) (.t0|18 (cgreg-lookup-reg .regs|3 0))) (let () (begin (if (not (eq? .frame|3 .frame1|12)) (let ((.live|24 (cgframe-livevars .frame|3))) (begin (cgframe-livevars-set! .frame1|12 .live|24) (cgframe-livevars-set! .frame2|15 .live|24) (gen-save! .output|3 .frame1|12 .t0|18) (cg-saveregs .output|3 .regs|3 .frame1|12))) (unspecified)) (let ((.r|27 (cg0 .output|3 (if.then .exp|3) .target|3 .regs|3 .frame1|12 .env|3 .tail?|3))) (begin (if (not .tail?|3) (gen! .output|3 $skip .l2|6 (cgreg-live .regs|3 .r|27)) (unspecified)) (gen! .output|3 $.label .l1|6) (if (not (eq? .frame|3 .frame1|12)) (begin (gen-save! .output|3 .frame2|15 .t0|18) (cg-saveregs .output|3 .regs2|9 .frame2|15)) (cgframe-update-stale! .frame2|15)) (cg0 .output|3 (if.else .exp|3) .r|27 .regs2|9 .frame2|15 .env|3 .tail?|3) (if (not .tail?|3) (begin (gen! .output|3 $.label .l2|6) (cgreg-join! .regs|3 .regs2|9) (cgframe-join! .frame1|12 .frame2|15)) (unspecified)) (if (if (not .target|3) (if (not (eq? .r|27 'result)) (not (cgreg-lookup-reg .regs|3 .r|27)) #f) #f) (cg-move .output|3 .frame|3 .regs|3 .r|27 'result) .r|27)))))))))) (.cg-if-result|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-if-result))
(let () (begin (set! cg-variable (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-variable|2 0)) (begin (set! .cg-variable|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.return-nostore|6 (unspecified)) (.return|6 (unspecified))) (begin (set! .return-nostore|6 (lambda (.id|7) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (if (if .target|3 (not (eq? 'result .target|3)) #f) (begin (gen! .output|3 $setreg .target|3) (cgreg-bind! .regs|3 .target|3 .id|7) .target|3) 'result)))) (set! .return|6 (lambda (.id|10) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (if (if .target|3 (not (eq? 'result .target|3)) #f) (begin (gen! .output|3 $setreg .target|3) (cgreg-bind! .regs|3 .target|3 .id|10) (gen-store! .output|3 .frame|3 .target|3 .id|10) .target|3) 'result)))) (let* ((.id|13 (variable.name .exp|3)) (.entry|16 (var-lookup .id|13 .regs|3 .frame|3 .env|3))) (let () (let ((.temp|20|23 (entry.kind .entry|16))) (if (memv .temp|20|23 '(global integrable)) (begin (gen! .output|3 $global .id|13) (.return|6 (newtemp))) (if (memv .temp|20|23 '(lexical)) (let ((.m|28 (entry.rib .entry|16)) (.n|28 (entry.offset .entry|16))) (begin (gen! .output|3 $lexical .m|28 .n|28 .id|13) (if (let ((.temp|29|32 (zero? .m|28))) (if .temp|29|32 .temp|29|32 (< (cgframe-size .frame|3) 0))) (.return-nostore|6 .id|13) (.return|6 .id|13)))) (if (memv .temp|20|23 '(procedure)) (error "Bug in cg-variable" .exp|3) (if (memv .temp|20|23 '(register)) (let ((.r|39 (entry.regnum .entry|16))) (if (let ((.temp|40|43 .tail?|3)) (if .temp|40|43 .temp|40|43 (if .target|3 (not (eqv? .target|3 .r|39)) #f))) (begin (gen! .output|3 $reg (entry.regnum .entry|16) .id|13) (.return-nostore|6 .id|13)) .r|39)) (if (memv .temp|20|23 '(frame)) (if (eq? .target|3 'result) (begin (gen-stack! .output|3 .frame|3 .id|13) (.return|6 .id|13)) (if .target|3 (begin (gen-load! .output|3 .frame|3 .target|3 .id|13) (cgreg-bind! .regs|3 .target|3 .id|13) .target|3) (let ((.r|54 (choose-register .regs|3 .frame|3))) (begin (gen-load! .output|3 .frame|3 .r|54 .id|13) (cgreg-bind! .regs|3 .r|54 .id|13) .r|54)))) (error "Bug in cg-variable" .exp|3))))))))))))) (.cg-variable|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-variable))
(let () (begin (set! cg-sequential (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-sequential|2 0)) (begin (set! .cg-sequential|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (cg-sequential-loop .output|3 (begin.exprs .exp|3) .target|3 .regs|3 .frame|3 .env|3 .tail?|3))) (.cg-sequential|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-sequential))
(let () (begin (set! cg-sequential-loop (lambda (.output|1 .exprs|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-sequential-loop|2 0)) (begin (set! .cg-sequential-loop|2 (lambda (.output|3 .exprs|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (null? .exprs|3) (begin (gen! .output|3 $const unspecified) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (cg-move .output|3 .frame|3 .regs|3 'result .target|3))) (if (null? (let ((.x|6|9 .exprs|3)) (begin (.check! (pair? .x|6|9) 1 .x|6|9) (cdr:pair .x|6|9)))) (cg0 .output|3 (let ((.x|10|13 .exprs|3)) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13))) .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (begin (cg0 .output|3 (let ((.x|15|18 .exprs|3)) (begin (.check! (pair? .x|15|18) 0 .x|15|18) (car:pair .x|15|18))) #f .regs|3 .frame|3 .env|3 #f) (.cg-sequential-loop|2 .output|3 (let ((.x|19|22 .exprs|3)) (begin (.check! (pair? .x|19|22) 1 .x|19|22) (cdr:pair .x|19|22))) .target|3 .regs|3 .frame|3 .env|3 .tail?|3)))))) (.cg-sequential-loop|2 .output|1 .exprs|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-sequential-loop))
(let () (begin (set! cg-saveregs (lambda (.output|1 .regs|1 .frame|1) (let ((.cg-saveregs|2 0)) (begin (set! .cg-saveregs|2 (lambda (.output|3 .regs|3 .frame|3) (let () (let ((.loop|5|8|11 (unspecified))) (begin (set! .loop|5|8|11 (lambda (.i|12 .vars|12) (if (null? .vars|12) (if #f #f (unspecified)) (begin (begin #t (let ((.t|17 (let ((.x|18|21 .vars|12)) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))))) (if .t|17 (gen-store! .output|3 .frame|3 .i|12 .t|17) (unspecified)))) (.loop|5|8|11 (+ .i|12 1) (let ((.x|22|25 .vars|12)) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25)))))))) (.loop|5|8|11 1 (let ((.x|26|29 (cgreg-vars .regs|3))) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))))))))) (.cg-saveregs|2 .output|1 .regs|1 .frame|1))))) 'cg-saveregs))
(let () (begin (set! cg-move (lambda (.output|1 .frame|1 .regs|1 .src|1 .dst|1) (let ((.cg-move|2 0)) (begin (set! .cg-move|2 (lambda (.output|3 .frame|3 .regs|3 .src|3 .dst|3) (let ((.bind|5 (unspecified))) (begin (set! .bind|5 (lambda (.dst|6) (let ((.temp|9 (newtemp))) (begin (cgreg-bind! .regs|3 .dst|6 .temp|9) (gen-store! .output|3 .frame|3 .dst|6 .temp|9) .dst|6)))) (if (not .dst|3) .src|3 (if (eqv? .src|3 .dst|3) .dst|3 (if (eq? .dst|3 'result) (begin (gen! .output|3 $reg .src|3) .dst|3) (if (eq? .src|3 'result) (begin (gen! .output|3 $setreg .dst|3) (.bind|5 .dst|3)) (if (if (not (zero? .src|3)) (not (zero? .dst|3)) #f) (begin (gen! .output|3 $movereg .src|3 .dst|3) (.bind|5 .dst|3)) (begin (gen! .output|3 $reg .src|3) (gen! .output|3 $setreg .dst|3) (.bind|5 .dst|3))))))))))) (.cg-move|2 .output|1 .frame|1 .regs|1 .src|1 .dst|1))))) 'cg-move))
(let () (begin (set! choose-register (lambda (.regs|1 .frame|1) (let ((.choose-register|2 0)) (begin (set! .choose-register|2 (lambda (.regs|3 .frame|3) (let ((.x|4|7 (choose-registers .regs|3 .frame|3 1))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))))) (.choose-register|2 .regs|1 .frame|1))))) 'choose-register))
(let () (begin (set! choose-registers (lambda (.regs|1 .frame|1 .n|1) (let ((.choose-registers|2 0)) (begin (set! .choose-registers|2 (lambda (.regs|3 .frame|3 .n|3) (let ((.hardcase|4 (unspecified)) (.loop2|4 (unspecified)) (.loop1|4 (unspecified))) (begin (set! .hardcase|4 (lambda () (let* ((.frame-exists?|8 (not (< (cgframe-size .frame|3) 0))) (.stufftosort|11 (let () (let ((.loop|172|175|178 (unspecified))) (begin (set! .loop|172|175|178 (lambda (.y1|167|168|179 .results|167|171|179) (if (null? .y1|167|168|179) (reverse .results|167|171|179) (begin #t (.loop|172|175|178 (let ((.x|183|186 .y1|167|168|179)) (begin (.check! (pair? .x|183|186) 1 .x|183|186) (cdr:pair .x|183|186))) (cons (let* ((.r|187 (let ((.x|220|223 .y1|167|168|179)) (begin (.check! (pair? .x|220|223) 0 .x|220|223) (car:pair .x|220|223)))) (.t|190 (cgreg-lookup-reg .regs|3 .r|187)) (.spilled?|193 (if .t|190 (cgframe-spilled? .frame|3 .t|190) #f))) (let () (let* ((.t1|197|200 .r|187) (.t2|197|203 (let* ((.t1|207|210 .t|190) (.t2|207|213 (cons .spilled?|193 '()))) (let () (cons .t1|207|210 .t2|207|213))))) (let () (cons .t1|197|200 .t2|197|203))))) .results|167|171|179)))))) (.loop|172|175|178 (let ((.x|224|227 (iota *nregs*))) (begin (.check! (pair? .x|224|227) 1 .x|224|227) (cdr:pair .x|224|227))) '()))))) (.registers|14 (twobit-sort (lambda (.x1|65 .x2|65) (let ((.r1|68 (let ((.x|141|144 .x1|65)) (begin (.check! (pair? .x|141|144) 0 .x|141|144) (car:pair .x|141|144)))) (.r2|68 (let ((.x|145|148 .x2|65)) (begin (.check! (pair? .x|145|148) 0 .x|145|148) (car:pair .x|145|148)))) (.t1|68 (let ((.x|150|153 (let ((.x|154|157 .x1|65)) (begin (.check! (pair? .x|154|157) 1 .x|154|157) (cdr:pair .x|154|157))))) (begin (.check! (pair? .x|150|153) 0 .x|150|153) (car:pair .x|150|153)))) (.t2|68 (let ((.x|159|162 (let ((.x|163|166 .x2|65)) (begin (.check! (pair? .x|163|166) 1 .x|163|166) (cdr:pair .x|163|166))))) (begin (.check! (pair? .x|159|162) 0 .x|159|162) (car:pair .x|159|162))))) (if (< .r1|68 *nhwregs*) (if (not .t1|68) #t (if (< .r2|68 *nhwregs*) (if (not .t2|68) #f (if (let ((.x|75|78 (let ((.x|79|82 (let ((.x|83|86 .x1|65)) (begin (.check! (pair? .x|83|86) 1 .x|83|86) (cdr:pair .x|83|86))))) (begin (.check! (pair? .x|79|82) 1 .x|79|82) (cdr:pair .x|79|82))))) (begin (.check! (pair? .x|75|78) 0 .x|75|78) (car:pair .x|75|78))) #t (if (let ((.x|89|92 (let ((.x|93|96 (let ((.x|97|100 .x2|65)) (begin (.check! (pair? .x|97|100) 1 .x|97|100) (cdr:pair .x|97|100))))) (begin (.check! (pair? .x|93|96) 1 .x|93|96) (cdr:pair .x|93|96))))) (begin (.check! (pair? .x|89|92) 0 .x|89|92) (car:pair .x|89|92))) #f #t))) (if .frame-exists?|8 #t (if .t2|68 #t #f)))) (if (< .r2|68 *nhwregs*) (if .frame-exists?|8 #f (if .t1|68 #f (if .t2|68 #t #f))) (if .t1|68 (if (if (let ((.x|113|116 (let ((.x|117|120 (let ((.x|121|124 .x1|65)) (begin (.check! (pair? .x|121|124) 1 .x|121|124) (cdr:pair .x|121|124))))) (begin (.check! (pair? .x|117|120) 1 .x|117|120) (cdr:pair .x|117|120))))) (begin (.check! (pair? .x|113|116) 0 .x|113|116) (car:pair .x|113|116))) (if .t2|68 (not (let ((.x|128|131 (let ((.x|132|135 (let ((.x|136|139 .x2|65)) (begin (.check! (pair? .x|136|139) 1 .x|136|139) (cdr:pair .x|136|139))))) (begin (.check! (pair? .x|132|135) 1 .x|132|135) (cdr:pair .x|132|135))))) (begin (.check! (pair? .x|128|131) 0 .x|128|131) (car:pair .x|128|131)))) #f) #f) #t #f) #t))))) .stufftosort|11))) (let () (begin '(for-each (lambda (register) (let ((t (cadr register)) (spilled? (caddr register))) (if (and t (not spilled?)) (cgframe-touch! frame t)))) registers) (let () (let ((.loop|18|22|25 (unspecified))) (begin (set! .loop|18|22|25 (lambda (.sorted|26 .rs|26 .n|26) (if (zero? .n|26) (reverse .rs|26) (begin #t (.loop|18|22|25 (let ((.x|29|32 .sorted|26)) (begin (.check! (pair? .x|29|32) 1 .x|29|32) (cdr:pair .x|29|32))) (cons (let ((.x|33|36 .sorted|26)) (begin (.check! (pair? .x|33|36) 0 .x|33|36) (car:pair .x|33|36))) .rs|26) (- .n|26 1)))))) (.loop|18|22|25 (let () (let ((.loop|42|45|48 (unspecified))) (begin (set! .loop|42|45|48 (lambda (.y1|37|38|49 .results|37|41|49) (if (null? .y1|37|38|49) (reverse .results|37|41|49) (begin #t (.loop|42|45|48 (let ((.x|53|56 .y1|37|38|49)) (begin (.check! (pair? .x|53|56) 1 .x|53|56) (cdr:pair .x|53|56))) (cons (let ((.x|57|60 (let ((.x|61|64 .y1|37|38|49)) (begin (.check! (pair? .x|61|64) 0 .x|61|64) (car:pair .x|61|64))))) (begin (.check! (pair? .x|57|60) 0 .x|57|60) (car:pair .x|57|60))) .results|37|41|49)))))) (.loop|42|45|48 .registers|14 '())))) '() .n|3))))))))) (set! .loop2|4 (lambda (.i|229 .n|229 .good|229) (if (zero? .n|229) .good|229 (if (zero? .i|229) (.hardcase|4) (let ((.t|235 (cgreg-lookup-reg .regs|3 .i|229))) (if (if .t|235 (cgframe-spilled? .frame|3 .t|235) #f) (.loop2|4 (- .i|229 1) (- .n|229 1) (cons .i|229 .good|229)) (.loop2|4 (- .i|229 1) .n|229 .good|229))))))) (set! .loop1|4 (lambda (.i|238 .n|238 .good|238) (if (zero? .n|238) .good|238 (if (zero? .i|238) (if (< (cgframe-size .frame|3) 0) (.hardcase|4) (.loop2|4 (- *nhwregs* 1) .n|238 .good|238)) (if (cgreg-lookup-reg .regs|3 .i|238) (.loop1|4 (- .i|238 1) .n|238 .good|238) (.loop1|4 (- .i|238 1) (- .n|238 1) (cons .i|238 .good|238))))))) (if (< .n|3 *nregs*) (.loop1|4 (- *nhwregs* 1) .n|3 '()) (error (string-append "Compiler bug: can't allocate " (number->string .n|3) " registers on this target."))))))) (.choose-registers|2 .regs|1 .frame|1 .n|1))))) 'choose-registers))
(let () (begin (set! cg-call (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-call|2 0)) (begin (set! .cg-call|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.proc|6 (call.proc .exp|3))) (if (if (lambda? .proc|6) (list? (lambda.args .proc|6)) #f) (cg-let .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (not (variable? .proc|6)) (cg-unknown-call .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.entry|14 (var-lookup (variable.name .proc|6) .regs|3 .frame|3 .env|3)) (.temp|15|18 (entry.kind .entry|14))) (if (memv .temp|15|18 '(global lexical frame register)) (cg-unknown-call .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (memv .temp|15|18 '(integrable)) (cg-integrable-call .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (memv .temp|15|18 '(procedure)) (cg-known-call .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (error "Bug in cg-call" .exp|3)))))))))) (.cg-call|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-call))
(let () (begin (set! cg-unknown-call (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-unknown-call|2 0)) (begin (set! .cg-unknown-call|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.proc|6 (call.proc .exp|3)) (.args|9 (call.args .exp|3)) (.n|12 (length .args|9)) (.l|15 (make-label))) (let () (if (>= (+ .n|12 1) *lastreg*) (cg-big-call .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.r0|23 (cgreg-lookup-reg .regs|3 0))) (begin (if (variable? .proc|6) (let ((.entry|26 (cgreg-lookup .regs|3 (variable.name .proc|6)))) (begin (if (if .entry|26 (<= (entry.regnum .entry|26) .n|12) #f) (begin (cg-arguments .output|3 (iota1 (+ .n|12 1)) (append .args|9 (cons .proc|6 '())) .regs|3 .frame|3 .env|3) (gen! .output|3 $reg (+ .n|12 1))) (begin (cg-arguments .output|3 (iota1 .n|12) .args|9 .regs|3 .frame|3 .env|3) (cg0 .output|3 .proc|6 'result .regs|3 .frame|3 .env|3 #f))) (if .tail?|3 (gen-pop! .output|3 .frame|3) (begin (cgframe-used! .frame|3) (gen! .output|3 $setrtn .l|15))) (gen! .output|3 $invoke .n|12))) (begin (cg-arguments .output|3 (iota1 (+ .n|12 1)) (append .args|9 (cons .proc|6 '())) .regs|3 .frame|3 .env|3) (gen! .output|3 $reg (+ .n|12 1)) (if .tail?|3 (gen-pop! .output|3 .frame|3) (begin (cgframe-used! .frame|3) (gen! .output|3 $setrtn .l|15))) (gen! .output|3 $invoke .n|12))) (if .tail?|3 'result (begin (gen! .output|3 $.align 4) (gen! .output|3 $.label .l|15) (gen! .output|3 $.cont) (cgreg-clear! .regs|3) (cgreg-bind! .regs|3 0 .r0|23) (gen-load! .output|3 .frame|3 0 .r0|23) (cg-move .output|3 .frame|3 .regs|3 'result .target|3)))))))))) (.cg-unknown-call|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-unknown-call))
(let () (begin (set! cg-known-call (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-known-call|2 0)) (begin (set! .cg-known-call|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.args|6 (call.args .exp|3)) (.n|9 (length .args|6)) (.l|12 (make-label))) (let () (if (>= (+ .n|9 1) *lastreg*) (cg-big-call .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.r0|20 (cgreg-lookup-reg .regs|3 0))) (begin (cg-arguments .output|3 (iota1 .n|9) .args|6 .regs|3 .frame|3 .env|3) (if .tail?|3 (gen-pop! .output|3 .frame|3) (begin (cgframe-used! .frame|3) (gen! .output|3 $setrtn .l|12))) (let* ((.entry|23 (cgenv-lookup .env|3 (variable.name (call.proc .exp|3)))) (.label|26 (entry.label .entry|23)) (.m|29 (entry.rib .entry|23))) (let () (if (zero? .m|29) (gen! .output|3 $branch .label|26 .n|9) (gen! .output|3 $jump .m|29 .label|26 .n|9)))) (if .tail?|3 'result (begin (gen! .output|3 $.align 4) (gen! .output|3 $.label .l|12) (gen! .output|3 $.cont) (cgreg-clear! .regs|3) (cgreg-bind! .regs|3 0 .r0|20) (gen-load! .output|3 .frame|3 0 .r0|20) (cg-move .output|3 .frame|3 .regs|3 'result .target|3)))))))))) (.cg-known-call|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-known-call))
(let () (begin (set! cg-big-call (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-big-call|2 0)) (begin (set! .cg-big-call|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.proc|6 (call.proc .exp|3)) (.args|9 (call.args .exp|3)) (.n|12 (length .args|9)) (.argslots|15 (newtemps .n|12)) (.procslot|18 (newtemp)) (.r0|21 (cgreg-lookup-reg .regs|3 0)) (.r-1|24 (- *nregs* 1)) (.entry|27 (if (variable? .proc|6) (let ((.entry|103 (var-lookup (variable.name .proc|6) .regs|3 .frame|3 .env|3))) (if (eq? (entry.kind .entry|103) 'procedure) .entry|103 #f)) #f)) (.l|30 (make-label))) (let () (begin (if (not .entry|27) (begin (cg0 .output|3 .proc|6 'result .regs|3 .frame|3 .env|3 #f) (gen-setstk! .output|3 .frame|3 .procslot|18)) (unspecified)) (let ((.f|34|38|41 (lambda (.arg|74 .argslot|74) (begin (cg0 .output|3 .arg|74 'result .regs|3 .frame|3 .env|3 #f) (gen-setstk! .output|3 .frame|3 .argslot|74))))) (let () (let ((.loop|43|46|49 (unspecified))) (begin (set! .loop|43|46|49 (lambda (.y1|34|36|50 .y1|34|35|50) (if (let ((.temp|52|55 (null? .y1|34|36|50))) (if .temp|52|55 .temp|52|55 (null? .y1|34|35|50))) (if #f #f (unspecified)) (begin (begin #t (.f|34|38|41 (let ((.x|58|61 .y1|34|36|50)) (begin (.check! (pair? .x|58|61) 0 .x|58|61) (car:pair .x|58|61))) (let ((.x|62|65 .y1|34|35|50)) (begin (.check! (pair? .x|62|65) 0 .x|62|65) (car:pair .x|62|65))))) (.loop|43|46|49 (let ((.x|66|69 .y1|34|36|50)) (begin (.check! (pair? .x|66|69) 1 .x|66|69) (cdr:pair .x|66|69))) (let ((.x|70|73 .y1|34|35|50)) (begin (.check! (pair? .x|70|73) 1 .x|70|73) (cdr:pair .x|70|73)))))))) (.loop|43|46|49 .args|9 .argslots|15))))) (cgreg-clear! .regs|3) (gen! .output|3 $const '()) (gen! .output|3 $setreg .r-1|24) (let () (let ((.loop|76|79|82 (unspecified))) (begin (set! .loop|76|79|82 (lambda (.i|83 .slots|83) (if (zero? .i|83) (if #f #f (unspecified)) (begin (begin #t (if (< .i|83 .r-1|24) (gen-load! .output|3 .frame|3 .i|83 (let ((.x|86|89 .slots|83)) (begin (.check! (pair? .x|86|89) 0 .x|86|89) (car:pair .x|86|89)))) (begin (gen-stack! .output|3 .frame|3 (let ((.x|90|93 .slots|83)) (begin (.check! (pair? .x|90|93) 0 .x|90|93) (car:pair .x|90|93)))) (gen! .output|3 $op2 $cons .r-1|24) (gen! .output|3 $setreg .r-1|24)))) (.loop|76|79|82 (- .i|83 1) (let ((.x|94|97 .slots|83)) (begin (.check! (pair? .x|94|97) 1 .x|94|97) (cdr:pair .x|94|97)))))))) (.loop|76|79|82 .n|12 (reverse .argslots|15))))) (if (not .entry|27) (gen-stack! .output|3 .frame|3 .procslot|18) (unspecified)) (if .tail?|3 (gen-pop! .output|3 .frame|3) (begin (cgframe-used! .frame|3) (gen! .output|3 $setrtn .l|30))) (if .entry|27 (let ((.label|100 (entry.label .entry|27)) (.m|100 (entry.rib .entry|27))) (if (zero? .m|100) (gen! .output|3 $branch .label|100 .n|12) (gen! .output|3 $jump .m|100 .label|100 .n|12))) (gen! .output|3 $invoke .n|12)) (if .tail?|3 'result (begin (gen! .output|3 $.align 4) (gen! .output|3 $.label .l|30) (gen! .output|3 $.cont) (cgreg-clear! .regs|3) (cgreg-bind! .regs|3 0 .r0|21) (gen-load! .output|3 .frame|3 0 .r0|21) (cg-move .output|3 .frame|3 .regs|3 'result .target|3)))))))) (.cg-big-call|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-big-call))
(let () (begin (set! cg-integrable-call (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-integrable-call|2 0)) (begin (set! .cg-integrable-call|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.args|6 (call.args .exp|3)) (.entry|6 (var-lookup (variable.name (call.proc .exp|3)) .regs|3 .frame|3 .env|3))) (if (= (entry.arity .entry|6) (length .args|6)) (begin (let ((.temp|7|10 (entry.arity .entry|6))) (if (memv .temp|7|10 '(0)) (gen! .output|3 $op1 (entry.op .entry|6)) (if (memv .temp|7|10 '(1)) (begin (cg0 .output|3 (let ((.x|13|16 .args|6)) (begin (.check! (pair? .x|13|16) 0 .x|13|16) (car:pair .x|13|16))) 'result .regs|3 .frame|3 .env|3 #f) (gen! .output|3 $op1 (entry.op .entry|6))) (if (memv .temp|7|10 '(2)) (cg-integrable-call2 .output|3 .entry|6 .args|6 .regs|3 .frame|3 .env|3) (if (memv .temp|7|10 '(3)) (cg-integrable-call3 .output|3 .entry|6 .args|6 .regs|3 .frame|3 .env|3) (error "Bug detected by cg-integrable-call" (make-readable .exp|3))))))) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (cg-move .output|3 .frame|3 .regs|3 'result .target|3))) (if (< (entry.arity .entry|6) 0) (cg-special .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (error "Wrong number of arguments to integrable procedure" (make-readable .exp|3))))))) (.cg-integrable-call|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-integrable-call))
(let () (begin (set! cg-integrable-call2 (lambda (.output|1 .entry|1 .args|1 .regs|1 .frame|1 .env|1) (let ((.cg-integrable-call2|2 0)) (begin (set! .cg-integrable-call2|2 (lambda (.output|3 .entry|3 .args|3 .regs|3 .frame|3 .env|3) (begin (let ((.op|6 (entry.op .entry|3))) (if (if (entry.imm .entry|3) (if (constant? (let ((.x|10|13 (let ((.x|14|17 .args|3)) (begin (.check! (pair? .x|14|17) 1 .x|14|17) (cdr:pair .x|14|17))))) (begin (.check! (pair? .x|10|13) 0 .x|10|13) (car:pair .x|10|13)))) ((entry.imm .entry|3) (constant.value (let ((.x|20|23 (let ((.x|24|27 .args|3)) (begin (.check! (pair? .x|24|27) 1 .x|24|27) (cdr:pair .x|24|27))))) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))))) #f) #f) (begin (cg0 .output|3 (let ((.x|28|31 .args|3)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31))) 'result .regs|3 .frame|3 .env|3 #f) (gen! .output|3 $op2imm .op|6 (constant.value (let ((.x|33|36 (let ((.x|37|40 .args|3)) (begin (.check! (pair? .x|37|40) 1 .x|37|40) (cdr:pair .x|37|40))))) (begin (.check! (pair? .x|33|36) 0 .x|33|36) (car:pair .x|33|36)))))) (let* ((.reg2|43 (cg0 .output|3 (let ((.x|78|81 (let ((.x|82|85 .args|3)) (begin (.check! (pair? .x|82|85) 1 .x|82|85) (cdr:pair .x|82|85))))) (begin (.check! (pair? .x|78|81) 0 .x|78|81) (car:pair .x|78|81))) #f .regs|3 .frame|3 .env|3 #f)) (.r2|46 (choose-register .regs|3 .frame|3)) (.t2|49 (if (eq? .reg2|43 'result) (let ((.t2|76 (newtemp))) (begin (gen! .output|3 $setreg .r2|46) (cgreg-bind! .regs|3 .r2|46 .t2|76) (gen-store! .output|3 .frame|3 .r2|46 .t2|76) .t2|76)) (cgreg-lookup-reg .regs|3 .reg2|43)))) (let () (begin (cg0 .output|3 (let ((.x|53|56 .args|3)) (begin (.check! (pair? .x|53|56) 0 .x|53|56) (car:pair .x|53|56))) 'result .regs|3 .frame|3 .env|3 #f) (let ((.r2|59 (let ((.temp|63|66 (let ((.entry|73 (cgreg-lookup .regs|3 .t2|49))) (if .entry|73 (entry.regnum .entry|73) #f)))) (if .temp|63|66 .temp|63|66 (let ((.r2|70 (choose-register .regs|3 .frame|3))) (begin (cgreg-bind! .regs|3 .r2|70 .t2|49) (gen-load! .output|3 .frame|3 .r2|70 .t2|49) .r2|70)))))) (let () (begin (gen! .output|3 $op2 (entry.op .entry|3) .r2|59) (if (eq? .reg2|43 'result) (begin (cgreg-release! .regs|3 .r2|59) (cgframe-release! .frame|3 .t2|49)) (unspecified)))))))))) 'result))) (.cg-integrable-call2|2 .output|1 .entry|1 .args|1 .regs|1 .frame|1 .env|1))))) 'cg-integrable-call2))
(let () (begin (set! cg-integrable-call3 (lambda (.output|1 .entry|1 .args|1 .regs|1 .frame|1 .env|1) (let ((.cg-integrable-call3|2 0)) (begin (set! .cg-integrable-call3|2 (lambda (.output|3 .entry|3 .args|3 .regs|3 .frame|3 .env|3) (begin (let* ((.reg2|6 (cg0 .output|3 (let ((.x|121|124 (let ((.x|125|128 .args|3)) (begin (.check! (pair? .x|125|128) 1 .x|125|128) (cdr:pair .x|125|128))))) (begin (.check! (pair? .x|121|124) 0 .x|121|124) (car:pair .x|121|124))) #f .regs|3 .frame|3 .env|3 #f)) (.r2|9 (choose-register .regs|3 .frame|3)) (.t2|12 (if (eq? .reg2|6 'result) (let ((.t2|119 (newtemp))) (begin (gen! .output|3 $setreg .r2|9) (cgreg-bind! .regs|3 .r2|9 .t2|119) (gen-store! .output|3 .frame|3 .r2|9 .t2|119) .t2|119)) (cgreg-lookup-reg .regs|3 .reg2|6))) (.reg3|15 (cg0 .output|3 (let ((.x|105|108 (let ((.x|109|112 (let ((.x|113|116 .args|3)) (begin (.check! (pair? .x|113|116) 1 .x|113|116) (cdr:pair .x|113|116))))) (begin (.check! (pair? .x|109|112) 1 .x|109|112) (cdr:pair .x|109|112))))) (begin (.check! (pair? .x|105|108) 0 .x|105|108) (car:pair .x|105|108))) #f .regs|3 .frame|3 .env|3 #f)) (.spillregs|18 (choose-registers .regs|3 .frame|3 2)) (.t3|21 (if (eq? .reg3|15 'result) (let ((.t3|86 (newtemp)) (.r3|86 (if (eq? .t2|12 (cgreg-lookup-reg .regs|3 (let ((.x|87|90 .spillregs|18)) (begin (.check! (pair? .x|87|90) 0 .x|87|90) (car:pair .x|87|90))))) (let ((.x|92|95 (let ((.x|96|99 .spillregs|18)) (begin (.check! (pair? .x|96|99) 1 .x|96|99) (cdr:pair .x|96|99))))) (begin (.check! (pair? .x|92|95) 0 .x|92|95) (car:pair .x|92|95))) (let ((.x|100|103 .spillregs|18)) (begin (.check! (pair? .x|100|103) 0 .x|100|103) (car:pair .x|100|103)))))) (begin (gen! .output|3 $setreg .r3|86) (cgreg-bind! .regs|3 .r3|86 .t3|86) (gen-store! .output|3 .frame|3 .r3|86 .t3|86) .t3|86)) (cgreg-lookup-reg .regs|3 .reg3|15)))) (let () (begin (cg0 .output|3 (let ((.x|25|28 .args|3)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28))) 'result .regs|3 .frame|3 .env|3 #f) (let* ((.spillregs|31 (choose-registers .regs|3 .frame|3 2)) (.r2|34 (let ((.temp|69|72 (let ((.entry|83 (cgreg-lookup .regs|3 .t2|12))) (if .entry|83 (entry.regnum .entry|83) #f)))) (if .temp|69|72 .temp|69|72 (let ((.r2|76 (let ((.x|77|80 .spillregs|31)) (begin (.check! (pair? .x|77|80) 0 .x|77|80) (car:pair .x|77|80))))) (begin (cgreg-bind! .regs|3 .r2|76 .t2|12) (gen-load! .output|3 .frame|3 .r2|76 .t2|12) .r2|76))))) (.r3|37 (let ((.temp|41|44 (let ((.entry|68 (cgreg-lookup .regs|3 .t3|21))) (if .entry|68 (entry.regnum .entry|68) #f)))) (if .temp|41|44 .temp|41|44 (let ((.r3|48 (if (eq? .r2|34 (let ((.x|49|52 .spillregs|31)) (begin (.check! (pair? .x|49|52) 0 .x|49|52) (car:pair .x|49|52)))) (let ((.x|54|57 (let ((.x|58|61 .spillregs|31)) (begin (.check! (pair? .x|58|61) 1 .x|58|61) (cdr:pair .x|58|61))))) (begin (.check! (pair? .x|54|57) 0 .x|54|57) (car:pair .x|54|57))) (let ((.x|62|65 .spillregs|31)) (begin (.check! (pair? .x|62|65) 0 .x|62|65) (car:pair .x|62|65)))))) (begin (cgreg-bind! .regs|3 .r3|48 .t3|21) (gen-load! .output|3 .frame|3 .r3|48 .t3|21) .r3|48)))))) (let () (begin (gen! .output|3 $op3 (entry.op .entry|3) .r2|34 .r3|37) (if (eq? .reg2|6 'result) (begin (cgreg-release! .regs|3 .r2|34) (cgframe-release! .frame|3 .t2|12)) (unspecified)) (if (eq? .reg3|15 'result) (begin (cgreg-release! .regs|3 .r3|37) (cgframe-release! .frame|3 .t3|21)) (unspecified)))))))) 'result))) (.cg-integrable-call3|2 .output|1 .entry|1 .args|1 .regs|1 .frame|1 .env|1))))) 'cg-integrable-call3))
(let () (begin (set! cg-primop-args (lambda (.output|1 .args|1 .regs|1 .frame|1 .env|1) (let ((.cg-primop-args|2 0)) (begin (set! .cg-primop-args|2 (lambda (.output|3 .args|3 .regs|3 .frame|3 .env|3) (let ((.finish-loop|4 (unspecified)) (.eval-first-into-result|4 (unspecified)) (.eval-loop|4 (unspecified))) (begin (set! .finish-loop|4 (lambda (.disjoint|5 .temps|5 .mask|5 .registers|5) (if (null? .temps|5) .registers|5 (let* ((.t|8 (let ((.x|54|57 .temps|5)) (begin (.check! (pair? .x|54|57) 0 .x|54|57) (car:pair .x|54|57)))) (.entry|11 (cgreg-lookup .regs|3 .t|8))) (let () (if .entry|11 (let ((.r|17 (entry.regnum .entry|11))) (begin (if (let ((.x|18|21 .mask|5)) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))) (begin (cgreg-release! .regs|3 .r|17) (cgframe-release! .frame|3 .t|8)) (unspecified)) (.finish-loop|4 .disjoint|5 (let ((.x|22|25 .temps|5)) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))) (let ((.x|26|29 .mask|5)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))) (cons .r|17 .registers|5)))) (let ((.r|32 (let ((.x|50|53 .disjoint|5)) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53))))) (if (memv .r|32 .registers|5) (.finish-loop|4 (let ((.x|34|37 .disjoint|5)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37))) .temps|5 .mask|5 .registers|5) (begin (gen-load! .output|3 .frame|3 .r|32 .t|8) (cgreg-bind! .regs|3 .r|32 .t|8) (if (let ((.x|38|41 .mask|5)) (begin (.check! (pair? .x|38|41) 0 .x|38|41) (car:pair .x|38|41))) (begin (cgreg-release! .regs|3 .r|32) (cgframe-release! .frame|3 .t|8)) (unspecified)) (.finish-loop|4 .disjoint|5 (let ((.x|42|45 .temps|5)) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45))) (let ((.x|46|49 .mask|5)) (begin (.check! (pair? .x|46|49) 1 .x|46|49) (cdr:pair .x|46|49))) (cons .r|32 .registers|5))))))))))) (set! .eval-first-into-result|4 (lambda (.temps|58 .mask|58) (begin (cg0 .output|3 (let ((.x|59|62 .args|3)) (begin (.check! (pair? .x|59|62) 0 .x|59|62) (car:pair .x|59|62))) 'result .regs|3 .frame|3 .env|3 #f) (.finish-loop|4 (choose-registers .regs|3 .frame|3 (length .temps|58)) .temps|58 .mask|58 '())))) (set! .eval-loop|4 (lambda (.args|63 .temps|63 .mask|63) (if (null? .args|63) (.eval-first-into-result|4 .temps|63 .mask|63) (let ((.reg|66 (cg0 .output|3 (let ((.x|84|87 .args|63)) (begin (.check! (pair? .x|84|87) 0 .x|84|87) (car:pair .x|84|87))) #f .regs|3 .frame|3 .env|3 #f))) (if (eq? .reg|66 'result) (let* ((.r|69 (choose-register .regs|3 .frame|3)) (.t|72 (newtemp))) (let () (begin (gen! .output|3 $setreg .r|69) (cgreg-bind! .regs|3 .r|69 .t|72) (gen-store! .output|3 .frame|3 .r|69 .t|72) (.eval-loop|4 (let ((.x|76|79 .args|63)) (begin (.check! (pair? .x|76|79) 1 .x|76|79) (cdr:pair .x|76|79))) (cons .t|72 .temps|63) (cons #t .mask|63))))) (.eval-loop|4 (let ((.x|80|83 .args|63)) (begin (.check! (pair? .x|80|83) 1 .x|80|83) (cdr:pair .x|80|83))) (cons (cgreg-lookup-reg .regs|3 .reg|66) .temps|63) (cons #f .mask|63))))))) (if (< (length .args|3) *nregs*) (.eval-loop|4 (let ((.x|88|91 .args|3)) (begin (.check! (pair? .x|88|91) 1 .x|88|91) (cdr:pair .x|88|91))) '() '()) (error "Bug detected by cg-primop-args" .args|3)))))) (.cg-primop-args|2 .output|1 .args|1 .regs|1 .frame|1 .env|1))))) 'cg-primop-args))
(let () (begin (set! cg-arguments (lambda (.output|1 .targets|1 .args|1 .regs|1 .frame|1 .env|1) (let ((.cg-arguments|2 0)) (begin (set! .cg-arguments|2 (lambda (.output|3 .targets|3 .args|3 .regs|3 .frame|3 .env|3) (let ((.evalargs0|4 (unspecified)) (.evalargs|4 (unspecified)) (.sortargs|4 (unspecified))) (begin (set! .evalargs0|4 (lambda (.targets|5 .args|5 .temps|5) (if (not (null? .targets|5)) (let ((.para|8 (let ((.regvars|92 (let () (let ((.loop|139|142|145 (unspecified))) (begin (set! .loop|139|142|145 (lambda (.y1|134|135|146 .results|134|138|146) (if (null? .y1|134|135|146) (reverse .results|134|138|146) (begin #t (.loop|139|142|145 (let ((.x|150|153 .y1|134|135|146)) (begin (.check! (pair? .x|150|153) 1 .x|150|153) (cdr:pair .x|150|153))) (cons (let ((.reg|154 (let ((.x|155|158 .y1|134|135|146)) (begin (.check! (pair? .x|155|158) 0 .x|155|158) (car:pair .x|155|158))))) (cgreg-lookup-reg .regs|3 .reg|154)) .results|134|138|146)))))) (.loop|139|142|145 .targets|5 '())))))) (let () (parallel-assignment .targets|5 (let () (let ((.loop|102|106|109 (unspecified))) (begin (set! .loop|102|106|109 (lambda (.y1|96|98|110 .y1|96|97|110 .results|96|101|110) (if (let ((.temp|112|115 (null? .y1|96|98|110))) (if .temp|112|115 .temp|112|115 (null? .y1|96|97|110))) (reverse .results|96|101|110) (begin #t (.loop|102|106|109 (let ((.x|118|121 .y1|96|98|110)) (begin (.check! (pair? .x|118|121) 1 .x|118|121) (cdr:pair .x|118|121))) (let ((.x|122|125 .y1|96|97|110)) (begin (.check! (pair? .x|122|125) 1 .x|122|125) (cdr:pair .x|122|125))) (cons (cons (let ((.x|126|129 .y1|96|98|110)) (begin (.check! (pair? .x|126|129) 0 .x|126|129) (car:pair .x|126|129))) (let ((.x|130|133 .y1|96|97|110)) (begin (.check! (pair? .x|130|133) 0 .x|130|133) (car:pair .x|130|133)))) .results|96|101|110)))))) (.loop|102|106|109 .regvars|92 .targets|5 '())))) .args|5))))) (if .para|8 (let ((.targets|11 .para|8) (.args|11 (cg-permute .args|5 .targets|5 .para|8)) (.temps|11 (cg-permute .temps|5 .targets|5 .para|8))) (let ((.f|12|17|20 (lambda (.arg|66 .r|66 .t|66) (begin (cg0 .output|3 .arg|66 .r|66 .regs|3 .frame|3 .env|3 #f) (cgreg-bind! .regs|3 .r|66 .t|66) (gen-store! .output|3 .frame|3 .r|66 .t|66))))) (let () (let ((.loop|22|26|29 (unspecified))) (begin (set! .loop|22|26|29 (lambda (.y1|12|15|30 .y1|12|14|30 .y1|12|13|30) (if (let ((.temp|32|35 (null? .y1|12|15|30))) (if .temp|32|35 .temp|32|35 (let ((.temp|36|39 (null? .y1|12|14|30))) (if .temp|36|39 .temp|36|39 (null? .y1|12|13|30))))) (if #f #f (unspecified)) (begin (begin #t (.f|12|17|20 (let ((.x|42|45 .y1|12|15|30)) (begin (.check! (pair? .x|42|45) 0 .x|42|45) (car:pair .x|42|45))) (let ((.x|46|49 .y1|12|14|30)) (begin (.check! (pair? .x|46|49) 0 .x|46|49) (car:pair .x|46|49))) (let ((.x|50|53 .y1|12|13|30)) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53))))) (.loop|22|26|29 (let ((.x|54|57 .y1|12|15|30)) (begin (.check! (pair? .x|54|57) 1 .x|54|57) (cdr:pair .x|54|57))) (let ((.x|58|61 .y1|12|14|30)) (begin (.check! (pair? .x|58|61) 1 .x|58|61) (cdr:pair .x|58|61))) (let ((.x|62|65 .y1|12|13|30)) (begin (.check! (pair? .x|62|65) 1 .x|62|65) (cdr:pair .x|62|65)))))))) (.loop|22|26|29 .args|11 .para|8 .temps|11)))))) (let ((.r|69 (choose-register .regs|3 .frame|3)) (.t|69 (let ((.x|86|89 .temps|5)) (begin (.check! (pair? .x|86|89) 0 .x|86|89) (car:pair .x|86|89))))) (begin (cg0 .output|3 (let ((.x|70|73 .args|5)) (begin (.check! (pair? .x|70|73) 0 .x|70|73) (car:pair .x|70|73))) .r|69 .regs|3 .frame|3 .env|3 #f) (cgreg-bind! .regs|3 .r|69 .t|69) (gen-store! .output|3 .frame|3 .r|69 .t|69) (.evalargs0|4 (let ((.x|74|77 .targets|5)) (begin (.check! (pair? .x|74|77) 1 .x|74|77) (cdr:pair .x|74|77))) (let ((.x|78|81 .args|5)) (begin (.check! (pair? .x|78|81) 1 .x|78|81) (cdr:pair .x|78|81))) (let ((.x|82|85 .temps|5)) (begin (.check! (pair? .x|82|85) 1 .x|82|85) (cdr:pair .x|82|85)))))))) (unspecified)))) (set! .evalargs|4 (lambda (.targets1|159 .args1|159 .targets2|159 .args2|159) (let* ((.temps1|162 (newtemps (length .targets1|159))) (.temps2|165 (newtemps (length .targets2|159)))) (let () (begin (if (not (null? .args1|159)) (let ((.f|169|173|176 (lambda (.arg|217 .temp|217) (begin (cg0 .output|3 .arg|217 'result .regs|3 .frame|3 .env|3 #f) (gen-setstk! .output|3 .frame|3 .temp|217))))) (let () (let ((.loop|178|181|184 (unspecified))) (begin (set! .loop|178|181|184 (lambda (.y1|169|171|185 .y1|169|170|185) (if (let ((.temp|187|190 (null? .y1|169|171|185))) (if .temp|187|190 .temp|187|190 (null? .y1|169|170|185))) (if #f #f (unspecified)) (begin (begin #t (.f|169|173|176 (let ((.x|193|196 .y1|169|171|185)) (begin (.check! (pair? .x|193|196) 0 .x|193|196) (car:pair .x|193|196))) (let ((.x|197|200 .y1|169|170|185)) (begin (.check! (pair? .x|197|200) 0 .x|197|200) (car:pair .x|197|200))))) (.loop|178|181|184 (let ((.x|201|204 .y1|169|171|185)) (begin (.check! (pair? .x|201|204) 1 .x|201|204) (cdr:pair .x|201|204))) (let ((.x|205|208 .y1|169|170|185)) (begin (.check! (pair? .x|205|208) 1 .x|205|208) (cdr:pair .x|205|208)))))))) (.loop|178|181|184 (let ((.x|209|212 .args1|159)) (begin (.check! (pair? .x|209|212) 1 .x|209|212) (cdr:pair .x|209|212))) (let ((.x|213|216 .temps1|162)) (begin (.check! (pair? .x|213|216) 1 .x|213|216) (cdr:pair .x|213|216)))))))) (unspecified)) (if (not (null? .args1|159)) (.evalargs0|4 (cons (let ((.x|218|221 .targets1|159)) (begin (.check! (pair? .x|218|221) 0 .x|218|221) (car:pair .x|218|221))) .targets2|159) (cons (let ((.x|222|225 .args1|159)) (begin (.check! (pair? .x|222|225) 0 .x|222|225) (car:pair .x|222|225))) .args2|159) (cons (let ((.x|226|229 .temps1|162)) (begin (.check! (pair? .x|226|229) 0 .x|226|229) (car:pair .x|226|229))) .temps2|165)) (.evalargs0|4 .targets2|159 .args2|159 .temps2|165)) (let () (let ((.loop|236|239|242 (unspecified))) (begin (set! .loop|236|239|242 (lambda (.y1|230|232|243 .y1|230|231|243) (if (let ((.temp|245|248 (null? .y1|230|232|243))) (if .temp|245|248 .temp|245|248 (null? .y1|230|231|243))) (if #f #f (unspecified)) (begin (begin #t (let ((.r|251 (let ((.x|264|267 .y1|230|232|243)) (begin (.check! (pair? .x|264|267) 0 .x|264|267) (car:pair .x|264|267)))) (.t|251 (let ((.x|268|271 .y1|230|231|243)) (begin (.check! (pair? .x|268|271) 0 .x|268|271) (car:pair .x|268|271))))) (let ((.temp|254 (cgreg-lookup-reg .regs|3 .r|251))) (begin (if (not (eq? .temp|254 .t|251)) (let ((.entry|257 (var-lookup .t|251 .regs|3 .frame|3 .env|3))) (begin (let ((.temp|258|261 (entry.kind .entry|257))) (if (memv .temp|258|261 '(register)) (gen! .output|3 $movereg (entry.regnum .entry|257) .r|251) (if (memv .temp|258|261 '(frame)) (gen-load! .output|3 .frame|3 .r|251 .t|251) (unspecified)))) (cgreg-bind! .regs|3 .r|251 .t|251))) (unspecified)) (cgframe-release! .frame|3 .t|251))))) (.loop|236|239|242 (let ((.x|272|275 .y1|230|232|243)) (begin (.check! (pair? .x|272|275) 1 .x|272|275) (cdr:pair .x|272|275))) (let ((.x|276|279 .y1|230|231|243)) (begin (.check! (pair? .x|276|279) 1 .x|276|279) (cdr:pair .x|276|279)))))))) (.loop|236|239|242 (append .targets1|159 .targets2|159) (append .temps1|162 .temps2|165)))))))))) (set! .sortargs|4 (lambda (.targets|280 .args|280 .targets1|280 .args1|280 .targets2|280 .args2|280) (if (null? .args|280) (.evalargs|4 .targets1|280 .args1|280 .targets2|280 .args2|280) (let ((.target|283 (let ((.x|284|287 .targets|280)) (begin (.check! (pair? .x|284|287) 0 .x|284|287) (car:pair .x|284|287)))) (.arg|283 (let ((.x|288|291 .args|280)) (begin (.check! (pair? .x|288|291) 0 .x|288|291) (car:pair .x|288|291)))) (.targets|283 (let ((.x|292|295 .targets|280)) (begin (.check! (pair? .x|292|295) 1 .x|292|295) (cdr:pair .x|292|295)))) (.args|283 (let ((.x|296|299 .args|280)) (begin (.check! (pair? .x|296|299) 1 .x|296|299) (cdr:pair .x|296|299))))) (if (complicated? .arg|283 .env|3) (.sortargs|4 .targets|283 .args|283 (cons .target|283 .targets1|280) (cons .arg|283 .args1|280) .targets2|280 .args2|280) (.sortargs|4 .targets|283 .args|283 .targets1|280 .args1|280 (cons .target|283 .targets2|280) (cons .arg|283 .args2|280))))))) (if (parallel-assignment-optimization) (.sortargs|4 (reverse .targets|3) (reverse .args|3) '() '() '() '()) (cg-evalargs .output|3 .targets|3 .args|3 .regs|3 .frame|3 .env|3)))))) (.cg-arguments|2 .output|1 .targets|1 .args|1 .regs|1 .frame|1 .env|1))))) 'cg-arguments))
(let () (begin (set! cg-evalargs (lambda (.output|1 .targets|1 .args|1 .regs|1 .frame|1 .env|1) (let ((.cg-evalargs|2 0)) (begin (set! .cg-evalargs|2 (lambda (.output|3 .targets|3 .args|3 .regs|3 .frame|3 .env|3) (let ((.temps|6 (newtemps (length .targets|3)))) (begin (let ((.f|7|12|15 (lambda (.arg|61 .r|61 .t|61) (begin (cg0 .output|3 .arg|61 .r|61 .regs|3 .frame|3 .env|3 #f) (cgreg-bind! .regs|3 .r|61 .t|61) (gen-store! .output|3 .frame|3 .r|61 .t|61))))) (let () (let ((.loop|17|21|24 (unspecified))) (begin (set! .loop|17|21|24 (lambda (.y1|7|10|25 .y1|7|9|25 .y1|7|8|25) (if (let ((.temp|27|30 (null? .y1|7|10|25))) (if .temp|27|30 .temp|27|30 (let ((.temp|31|34 (null? .y1|7|9|25))) (if .temp|31|34 .temp|31|34 (null? .y1|7|8|25))))) (if #f #f (unspecified)) (begin (begin #t (.f|7|12|15 (let ((.x|37|40 .y1|7|10|25)) (begin (.check! (pair? .x|37|40) 0 .x|37|40) (car:pair .x|37|40))) (let ((.x|41|44 .y1|7|9|25)) (begin (.check! (pair? .x|41|44) 0 .x|41|44) (car:pair .x|41|44))) (let ((.x|45|48 .y1|7|8|25)) (begin (.check! (pair? .x|45|48) 0 .x|45|48) (car:pair .x|45|48))))) (.loop|17|21|24 (let ((.x|49|52 .y1|7|10|25)) (begin (.check! (pair? .x|49|52) 1 .x|49|52) (cdr:pair .x|49|52))) (let ((.x|53|56 .y1|7|9|25)) (begin (.check! (pair? .x|53|56) 1 .x|53|56) (cdr:pair .x|53|56))) (let ((.x|57|60 .y1|7|8|25)) (begin (.check! (pair? .x|57|60) 1 .x|57|60) (cdr:pair .x|57|60)))))))) (.loop|17|21|24 .args|3 .targets|3 .temps|6))))) (let () (let ((.loop|68|71|74 (unspecified))) (begin (set! .loop|68|71|74 (lambda (.y1|62|64|75 .y1|62|63|75) (if (let ((.temp|77|80 (null? .y1|62|64|75))) (if .temp|77|80 .temp|77|80 (null? .y1|62|63|75))) (if #f #f (unspecified)) (begin (begin #t (let ((.r|83 (let ((.x|87|90 .y1|62|64|75)) (begin (.check! (pair? .x|87|90) 0 .x|87|90) (car:pair .x|87|90)))) (.t|83 (let ((.x|91|94 .y1|62|63|75)) (begin (.check! (pair? .x|91|94) 0 .x|91|94) (car:pair .x|91|94))))) (let ((.temp|86 (cgreg-lookup-reg .regs|3 .r|83))) (begin (if (not (eq? .temp|86 .t|83)) (begin (gen-load! .output|3 .frame|3 .r|83 .t|83) (cgreg-bind! .regs|3 .r|83 .t|83)) (unspecified)) (cgframe-release! .frame|3 .t|83))))) (.loop|68|71|74 (let ((.x|95|98 .y1|62|64|75)) (begin (.check! (pair? .x|95|98) 1 .x|95|98) (cdr:pair .x|95|98))) (let ((.x|99|102 .y1|62|63|75)) (begin (.check! (pair? .x|99|102) 1 .x|99|102) (cdr:pair .x|99|102)))))))) (.loop|68|71|74 .targets|3 .temps|6)))))))) (.cg-evalargs|2 .output|1 .targets|1 .args|1 .regs|1 .frame|1 .env|1))))) 'cg-evalargs))
(let () (begin (set! complicated? (lambda (.exp|1 .env|1) (let ((.complicated?|2 0)) (begin (set! .complicated?|2 (lambda (.exp|3 .env|3) (let ((.temp|4|7 (let ((.x|33|36 .exp|3)) (begin (.check! (pair? .x|33|36) 0 .x|33|36) (car:pair .x|33|36))))) (if (memv .temp|4|7 '(quote)) #f (if (memv .temp|4|7 '(lambda)) #t (if (memv .temp|4|7 '(set!)) (.complicated?|2 (assignment.rhs .exp|3) .env|3) (if (memv .temp|4|7 '(if)) (let ((.temp|12|15 (.complicated?|2 (if.test .exp|3) .env|3))) (if .temp|12|15 .temp|12|15 (let ((.temp|16|19 (.complicated?|2 (if.then .exp|3) .env|3))) (if .temp|16|19 .temp|16|19 (.complicated?|2 (if.else .exp|3) .env|3))))) (if (memv .temp|4|7 '(begin)) (if (variable? .exp|3) #f (some? (lambda (.exp|22) (.complicated?|2 .exp|22 .env|3)) (begin.exprs .exp|3))) (let ((.proc|26 (call.proc .exp|3))) (if (if (variable? .proc|26) (let ((.entry|31 (cgenv-lookup .env|3 (variable.name .proc|26)))) (eq? (entry.kind .entry|31) 'integrable)) #f) (some? (lambda (.exp|32) (.complicated?|2 .exp|32 .env|3)) (call.args .exp|3)) #t)))))))))) (.complicated?|2 .exp|1 .env|1))))) 'complicated?))
(let () (begin (set! cg-permute (lambda (.src|1 .key|1 .newkey|1) (let ((.cg-permute|2 0)) (begin (set! .cg-permute|2 (lambda (.src|3 .key|3 .newkey|3) (let ((.alist|6 (let () (let ((.loop|35|39|42 (unspecified))) (begin (set! .loop|35|39|42 (lambda (.y1|29|31|43 .y1|29|30|43 .results|29|34|43) (if (let ((.temp|45|48 (null? .y1|29|31|43))) (if .temp|45|48 .temp|45|48 (null? .y1|29|30|43))) (reverse .results|29|34|43) (begin #t (.loop|35|39|42 (let ((.x|51|54 .y1|29|31|43)) (begin (.check! (pair? .x|51|54) 1 .x|51|54) (cdr:pair .x|51|54))) (let ((.x|55|58 .y1|29|30|43)) (begin (.check! (pair? .x|55|58) 1 .x|55|58) (cdr:pair .x|55|58))) (cons (cons (let ((.x|59|62 .y1|29|31|43)) (begin (.check! (pair? .x|59|62) 0 .x|59|62) (car:pair .x|59|62))) (let ((.x|63|66 .y1|29|30|43)) (begin (.check! (pair? .x|63|66) 0 .x|63|66) (car:pair .x|63|66)))) .results|29|34|43)))))) (.loop|35|39|42 .key|3 (iota (length .key|3)) '())))))) (let () (let ((.loop|7|10|13 (unspecified))) (begin (set! .loop|7|10|13 (lambda (.newkey|14 .dest|14) (if (null? .newkey|14) (reverse .dest|14) (begin #t (.loop|7|10|13 (let ((.x|17|20 .newkey|14)) (begin (.check! (pair? .x|17|20) 1 .x|17|20) (cdr:pair .x|17|20))) (cons (list-ref .src|3 (let ((.x|21|24 (assq (let ((.x|25|28 .newkey|14)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28))) .alist|6))) (begin (.check! (pair? .x|21|24) 1 .x|21|24) (cdr:pair .x|21|24)))) .dest|14)))))) (.loop|7|10|13 .newkey|3 '()))))))) (.cg-permute|2 .src|1 .key|1 .newkey|1))))) 'cg-permute))
(let () (begin (set! parallel-assignment (lambda (.regnums|1 .alist|1 .exps|1) (if (null? .regnums|1) #t (let ((.x|4 (toposort (dependency-graph .regnums|1 .alist|1 .exps|1)))) (if .x|4 (reverse .x|4) #f))))) 'parallel-assignment))
(let () (begin (set! dependency-graph (lambda (.regnums|1 .alist|1 .exps|1) (let ((.names|4 (let () (let ((.loop|66|69|72 (unspecified))) (begin (set! .loop|66|69|72 (lambda (.y1|61|62|73 .results|61|65|73) (if (null? .y1|61|62|73) (reverse .results|61|65|73) (begin #t (.loop|66|69|72 (let ((.x|77|80 .y1|61|62|73)) (begin (.check! (pair? .x|77|80) 1 .x|77|80) (cdr:pair .x|77|80))) (cons (let ((.x|81|84 (let ((.x|85|88 .y1|61|62|73)) (begin (.check! (pair? .x|85|88) 0 .x|85|88) (car:pair .x|85|88))))) (begin (.check! (pair? .x|81|84) 0 .x|81|84) (car:pair .x|81|84))) .results|61|65|73)))))) (.loop|66|69|72 .alist|1 '())))))) (let () (let ((.loop|5|9|12 (unspecified))) (begin (set! .loop|5|9|12 (lambda (.regnums|13 .exps|13 .l|13) (if (null? .regnums|13) .l|13 (begin #t (.loop|5|9|12 (let ((.x|16|19 .regnums|13)) (begin (.check! (pair? .x|16|19) 1 .x|16|19) (cdr:pair .x|16|19))) (let ((.x|20|23 .exps|13)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) (cons (cons (let ((.x|24|27 .regnums|13)) (begin (.check! (pair? .x|24|27) 0 .x|24|27) (car:pair .x|24|27))) (let () (let ((.loop|33|36|39 (unspecified))) (begin (set! .loop|33|36|39 (lambda (.y1|28|29|40 .results|28|32|40) (if (null? .y1|28|29|40) (reverse .results|28|32|40) (begin #t (.loop|33|36|39 (let ((.x|44|47 .y1|28|29|40)) (begin (.check! (pair? .x|44|47) 1 .x|44|47) (cdr:pair .x|44|47))) (cons (let* ((.var|48 (let ((.x|53|56 .y1|28|29|40)) (begin (.check! (pair? .x|53|56) 0 .x|53|56) (car:pair .x|53|56)))) (.x|49|52 (assq .var|48 .alist|1))) (begin (.check! (pair? .x|49|52) 1 .x|49|52) (cdr:pair .x|49|52))) .results|28|32|40)))))) (.loop|33|36|39 (intersection (freevariables (let ((.x|57|60 .exps|13)) (begin (.check! (pair? .x|57|60) 0 .x|57|60) (car:pair .x|57|60)))) .names|4) '()))))) .l|13)))))) (.loop|5|9|12 .regnums|1 .exps|1 '()))))))) 'dependency-graph))
(let () (begin (set! toposort (lambda (.graph|1) (if (null? (let ((.x|3|6 .graph|1)) (begin (.check! (pair? .x|3|6) 1 .x|3|6) (cdr:pair .x|3|6)))) (cons (let ((.x|9|12 (let ((.x|13|16 .graph|1)) (begin (.check! (pair? .x|13|16) 0 .x|13|16) (car:pair .x|13|16))))) (begin (.check! (pair? .x|9|12) 0 .x|9|12) (car:pair .x|9|12))) '()) (toposort2 .graph|1 '())))) 'toposort))
(let () (begin (set! toposort2 (lambda (.totry|1 .tried|1) (if (null? .totry|1) #f (if (let ((.temp|4|7 (null? (let ((.x|45|48 (let ((.x|49|52 .totry|1)) (begin (.check! (pair? .x|49|52) 0 .x|49|52) (car:pair .x|49|52))))) (begin (.check! (pair? .x|45|48) 1 .x|45|48) (cdr:pair .x|45|48)))))) (if .temp|4|7 .temp|4|7 (if (null? (let ((.x|11|14 (let ((.x|15|18 (let ((.x|19|22 .totry|1)) (begin (.check! (pair? .x|19|22) 0 .x|19|22) (car:pair .x|19|22))))) (begin (.check! (pair? .x|15|18) 1 .x|15|18) (cdr:pair .x|15|18))))) (begin (.check! (pair? .x|11|14) 1 .x|11|14) (cdr:pair .x|11|14)))) (eq? (let ((.x|25|28 (let ((.x|29|32 (let ((.x|33|36 .totry|1)) (begin (.check! (pair? .x|33|36) 0 .x|33|36) (car:pair .x|33|36))))) (begin (.check! (pair? .x|29|32) 1 .x|29|32) (cdr:pair .x|29|32))))) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28))) (let ((.x|37|40 (let ((.x|41|44 .totry|1)) (begin (.check! (pair? .x|41|44) 0 .x|41|44) (car:pair .x|41|44))))) (begin (.check! (pair? .x|37|40) 0 .x|37|40) (car:pair .x|37|40)))) #f))) (if (if (null? (let ((.x|54|57 .totry|1)) (begin (.check! (pair? .x|54|57) 1 .x|54|57) (cdr:pair .x|54|57)))) (null? .tried|1) #f) (cons (let ((.x|61|64 (let ((.x|65|68 .totry|1)) (begin (.check! (pair? .x|65|68) 0 .x|65|68) (car:pair .x|65|68))))) (begin (.check! (pair? .x|61|64) 0 .x|61|64) (car:pair .x|61|64))) '()) (let* ((.node|71 (let ((.x|116|119 (let ((.x|120|123 .totry|1)) (begin (.check! (pair? .x|120|123) 0 .x|120|123) (car:pair .x|120|123))))) (begin (.check! (pair? .x|116|119) 0 .x|116|119) (car:pair .x|116|119)))) (.x|74 (toposort2 (let () (let ((.loop|83|86|89 (unspecified))) (begin (set! .loop|83|86|89 (lambda (.y1|78|79|90 .results|78|82|90) (if (null? .y1|78|79|90) (reverse .results|78|82|90) (begin #t (.loop|83|86|89 (let ((.x|94|97 .y1|78|79|90)) (begin (.check! (pair? .x|94|97) 1 .x|94|97) (cdr:pair .x|94|97))) (cons (let ((.y|98 (let ((.x|107|110 .y1|78|79|90)) (begin (.check! (pair? .x|107|110) 0 .x|107|110) (car:pair .x|107|110))))) (cons (let ((.x|99|102 .y|98)) (begin (.check! (pair? .x|99|102) 0 .x|99|102) (car:pair .x|99|102))) (remove .node|71 (let ((.x|103|106 .y|98)) (begin (.check! (pair? .x|103|106) 1 .x|103|106) (cdr:pair .x|103|106)))))) .results|78|82|90)))))) (.loop|83|86|89 (append (let ((.x|111|114 .totry|1)) (begin (.check! (pair? .x|111|114) 1 .x|111|114) (cdr:pair .x|111|114))) .tried|1) '())))) '()))) (let () (if .x|74 (cons .node|71 .x|74) #f)))) (toposort2 (let ((.x|125|128 .totry|1)) (begin (.check! (pair? .x|125|128) 1 .x|125|128) (cdr:pair .x|125|128))) (cons (let ((.x|129|132 .totry|1)) (begin (.check! (pair? .x|129|132) 0 .x|129|132) (car:pair .x|129|132))) .tried|1)))))) 'toposort2))
(let () (begin (set! iota (lambda (.n|1) (iota2 .n|1 '()))) 'iota))
(let () (begin (set! iota1 (lambda (.n|1) (let ((.x|2|5 (iota2 (+ .n|1 1) '()))) (begin (.check! (pair? .x|2|5) 1 .x|2|5) (cdr:pair .x|2|5))))) 'iota1))
(let () (begin (set! iota2 (lambda (.n|1 .l|1) (if (zero? .n|1) .l|1 (let ((.n|4 (- .n|1 1))) (iota2 .n|4 (cons .n|4 .l|1)))))) 'iota2))
(let () (begin (set! freevariables (lambda (.exp|1) (let ((.freevariables|2 0)) (begin (set! .freevariables|2 (lambda (.exp|3) (freevars2 .exp|3 '()))) (.freevariables|2 .exp|1))))) 'freevariables))
(let () (begin (set! freevars2 (lambda (.exp|1 .env|1) (let ((.freevars2|2 0)) (begin (set! .freevars2|2 (lambda (.exp|3 .env|3) (if (symbol? .exp|3) (if (memq .exp|3 .env|3) '() (cons .exp|3 '())) (if (not (pair? .exp|3)) '() (let ((.keyword|10 (let ((.x|145|148 .exp|3)) (begin (.check! (pair? .x|145|148) 0 .x|145|148) (car:pair .x|145|148))))) (if (eq? .keyword|10 'quote) '() (if (eq? .keyword|10 'lambda) (let ((.env|15 (append (make-null-terminated (let ((.x|51|54 (let ((.x|55|58 .exp|3)) (begin (.check! (pair? .x|55|58) 1 .x|55|58) (cdr:pair .x|55|58))))) (begin (.check! (pair? .x|51|54) 0 .x|51|54) (car:pair .x|51|54)))) .env|3))) (apply-union (let () (let ((.loop|21|24|27 (unspecified))) (begin (set! .loop|21|24|27 (lambda (.y1|16|17|28 .results|16|20|28) (if (null? .y1|16|17|28) (reverse .results|16|20|28) (begin #t (.loop|21|24|27 (let ((.x|32|35 .y1|16|17|28)) (begin (.check! (pair? .x|32|35) 1 .x|32|35) (cdr:pair .x|32|35))) (cons (let ((.x|36 (let ((.x|37|40 .y1|16|17|28)) (begin (.check! (pair? .x|37|40) 0 .x|37|40) (car:pair .x|37|40))))) (.freevars2|2 .x|36 .env|15)) .results|16|20|28)))))) (.loop|21|24|27 (let ((.x|42|45 (let ((.x|46|49 .exp|3)) (begin (.check! (pair? .x|46|49) 1 .x|46|49) (cdr:pair .x|46|49))))) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45))) '())))))) (if (let ((.t0|60|61|64 .keyword|10) (.t1|60|61|64 '(if set! begin))) (if (eq? .t0|60|61|64 'if) .t1|60|61|64 (let ((.t1|60|61|68 (let ((.x|86|89 .t1|60|61|64)) (begin (.check! (pair? .x|86|89) 1 .x|86|89) (cdr:pair .x|86|89))))) (if (eq? .t0|60|61|64 'set!) .t1|60|61|68 (let ((.t1|60|61|72 (let ((.x|82|85 .t1|60|61|68)) (begin (.check! (pair? .x|82|85) 1 .x|82|85) (cdr:pair .x|82|85))))) (if (eq? .t0|60|61|64 'begin) .t1|60|61|72 (let ((.t1|60|61|76 (let ((.x|78|81 .t1|60|61|72)) (begin (.check! (pair? .x|78|81) 1 .x|78|81) (cdr:pair .x|78|81))))) #f))))))) (apply-union (let () (let ((.loop|95|98|101 (unspecified))) (begin (set! .loop|95|98|101 (lambda (.y1|90|91|102 .results|90|94|102) (if (null? .y1|90|91|102) (reverse .results|90|94|102) (begin #t (.loop|95|98|101 (let ((.x|106|109 .y1|90|91|102)) (begin (.check! (pair? .x|106|109) 1 .x|106|109) (cdr:pair .x|106|109))) (cons (let ((.x|110 (let ((.x|111|114 .y1|90|91|102)) (begin (.check! (pair? .x|111|114) 0 .x|111|114) (car:pair .x|111|114))))) (.freevars2|2 .x|110 .env|3)) .results|90|94|102)))))) (.loop|95|98|101 (let ((.x|115|118 .exp|3)) (begin (.check! (pair? .x|115|118) 1 .x|115|118) (cdr:pair .x|115|118))) '()))))) (apply-union (let () (let ((.loop|125|128|131 (unspecified))) (begin (set! .loop|125|128|131 (lambda (.y1|120|121|132 .results|120|124|132) (if (null? .y1|120|121|132) (reverse .results|120|124|132) (begin #t (.loop|125|128|131 (let ((.x|136|139 .y1|120|121|132)) (begin (.check! (pair? .x|136|139) 1 .x|136|139) (cdr:pair .x|136|139))) (cons (let ((.x|140 (let ((.x|141|144 .y1|120|121|132)) (begin (.check! (pair? .x|141|144) 0 .x|141|144) (car:pair .x|141|144))))) (.freevars2|2 .x|140 .env|3)) .results|120|124|132)))))) (.loop|125|128|131 .exp|3 '()))))))))))))) (.freevars2|2 .exp|1 .env|1))))) 'freevars2))
(let () (begin (set! cg-let (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-let|2 0)) (begin (set! .cg-let|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.proc|6 (call.proc .exp|3)) (.vars|9 (lambda.args .proc|6)) (.n|12 (length .vars|9)) (.free|15 (lambda.f .proc|6)) (.live|18 (cgframe-livevars .frame|3))) (let () (if (if (null? (lambda.defs .proc|6)) (= .n|12 1) #f) (cg-let1 .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.args|26 (call.args .exp|3)) (.temps|29 (newtemps .n|12)) (.alist|32 (let () (let ((.loop|83|87|90 (unspecified))) (begin (set! .loop|83|87|90 (lambda (.y1|77|79|91 .y1|77|78|91 .results|77|82|91) (if (let ((.temp|93|96 (null? .y1|77|79|91))) (if .temp|93|96 .temp|93|96 (null? .y1|77|78|91))) (reverse .results|77|82|91) (begin #t (.loop|83|87|90 (let ((.x|99|102 .y1|77|79|91)) (begin (.check! (pair? .x|99|102) 1 .x|99|102) (cdr:pair .x|99|102))) (let ((.x|103|106 .y1|77|78|91)) (begin (.check! (pair? .x|103|106) 1 .x|103|106) (cdr:pair .x|103|106))) (cons (cons (let ((.x|107|110 .y1|77|79|91)) (begin (.check! (pair? .x|107|110) 0 .x|107|110) (car:pair .x|107|110))) (let ((.x|111|114 .y1|77|78|91)) (begin (.check! (pair? .x|111|114) 0 .x|111|114) (car:pair .x|111|114)))) .results|77|82|91)))))) (.loop|83|87|90 .temps|29 .vars|9 '())))))) (let () (begin (let () (let ((.loop|42|45|48 (unspecified))) (begin (set! .loop|42|45|48 (lambda (.y1|36|38|49 .y1|36|37|49) (if (let ((.temp|51|54 (null? .y1|36|38|49))) (if .temp|51|54 .temp|51|54 (null? .y1|36|37|49))) (if #f #f (unspecified)) (begin (begin #t (let ((.arg|57 (let ((.x|61|64 .y1|36|38|49)) (begin (.check! (pair? .x|61|64) 0 .x|61|64) (car:pair .x|61|64)))) (.t|57 (let ((.x|65|68 .y1|36|37|49)) (begin (.check! (pair? .x|65|68) 0 .x|65|68) (car:pair .x|65|68))))) (let ((.r|60 (choose-register .regs|3 .frame|3))) (begin (cg0 .output|3 .arg|57 .r|60 .regs|3 .frame|3 .env|3 #f) (cgreg-bind! .regs|3 .r|60 .t|57) (gen-store! .output|3 .frame|3 .r|60 .t|57))))) (.loop|42|45|48 (let ((.x|69|72 .y1|36|38|49)) (begin (.check! (pair? .x|69|72) 1 .x|69|72) (cdr:pair .x|69|72))) (let ((.x|73|76 .y1|36|37|49)) (begin (.check! (pair? .x|73|76) 1 .x|73|76) (cdr:pair .x|73|76)))))))) (.loop|42|45|48 .args|26 .temps|29)))) (cgreg-rename! .regs|3 .alist|32) (cgframe-rename! .frame|3 .alist|32) (cg-let-release! .free|15 .live|18 .regs|3 .frame|3 .tail?|3) (cg-let-body .output|3 .proc|6 .target|3 .regs|3 .frame|3 .env|3 .tail?|3))))))))) (.cg-let|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-let))
(let () (begin (set! cg-let-release! (lambda (.free|1 .live|1 .regs|1 .frame|1 .tail?|1) (let ((.cg-let-release!|2 0)) (begin (set! .cg-let-release!|2 (lambda (.free|3 .live|3 .regs|3 .frame|3 .tail?|3) (if .tail?|3 (let ((.keepers|7 (cons (cgreg-lookup-reg .regs|3 0) .free|3))) (begin (cgreg-release-except! .regs|3 .keepers|7) (cgframe-release-except! .frame|3 .keepers|7))) (if .live|3 (let ((.keepers|11 (cons (cgreg-lookup-reg .regs|3 0) (union .live|3 .free|3)))) (begin (cgreg-release-except! .regs|3 .keepers|11) (cgframe-release-except! .frame|3 .keepers|11))) (unspecified))))) (.cg-let-release!|2 .free|1 .live|1 .regs|1 .frame|1 .tail?|1))))) 'cg-let-release!))
(let () (begin (set! cg-let-body (lambda (.output|1 .l|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-let-body|2 0)) (begin (set! .cg-let-body|2 (lambda (.output|3 .l|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.vars|6 (lambda.args .l|3)) (.free|6 (lambda.f .l|3)) (.live|6 (cgframe-livevars .frame|3))) (let ((.r|9 (cg-body .output|3 .l|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3))) (begin (let () (let ((.loop|15|17|20 (unspecified))) (begin (set! .loop|15|17|20 (lambda (.y1|10|11|21) (if (null? .y1|10|11|21) (if #f #f (unspecified)) (begin (begin #t (let* ((.v|25 (let ((.x|29|32 .y1|10|11|21)) (begin (.check! (pair? .x|29|32) 0 .x|29|32) (car:pair .x|29|32)))) (.entry|28 (cgreg-lookup .regs|3 .v|25))) (begin (if .entry|28 (cgreg-release! .regs|3 (entry.regnum .entry|28)) (unspecified)) (cgframe-release! .frame|3 .v|25)))) (.loop|15|17|20 (let ((.x|33|36 .y1|10|11|21)) (begin (.check! (pair? .x|33|36) 1 .x|33|36) (cdr:pair .x|33|36)))))))) (.loop|15|17|20 .vars|6)))) (if (if (not .target|3) (if (not (eq? .r|9 'result)) (not (cgreg-lookup-reg .regs|3 .r|9)) #f) #f) (cg-move .output|3 .frame|3 .regs|3 .r|9 'result) .r|9)))))) (.cg-let-body|2 .output|1 .l|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-let-body))
(let () (begin (set! cg-let1 (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-let1|2 0)) (begin (set! .cg-let1|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.proc|6 (call.proc .exp|3)) (.v|9 (let ((.x|41|44 (lambda.args .proc|6))) (begin (.check! (pair? .x|41|44) 0 .x|41|44) (car:pair .x|41|44)))) (.arg|12 (let ((.x|37|40 (call.args .exp|3))) (begin (.check! (pair? .x|37|40) 0 .x|37|40) (car:pair .x|37|40)))) (.free|15 (lambda.f .proc|6)) (.live|18 (cgframe-livevars .frame|3)) (.body|21 (lambda.body .proc|6))) (let () (let ((.finish|25 (unspecified)) (.release-registers!|25 (unspecified)) (.evaluate-into-register|25 (unspecified))) (begin (set! .finish|25 (lambda () (begin (.release-registers!|25) (cg-let-body .output|3 .proc|6 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)))) (set! .release-registers!|25 (lambda () (begin (cgframe-livevars-set! .frame|3 .live|18) (cg-let-release! .free|15 .live|18 .regs|3 .frame|3 .tail?|3)))) (set! .evaluate-into-register|25 (lambda (.r|28) (begin (cg0 .output|3 .arg|12 .r|28 .regs|3 .frame|3 .env|3 #f) (cgreg-bind! .regs|3 .r|28 .v|9) (gen-store! .output|3 .frame|3 .r|28 .v|9) .r|28))) (if .live|18 (cgframe-livevars-set! .frame|3 (union .live|18 .free|15)) (unspecified)) (if (assq .v|9 *regnames*) (begin (.evaluate-into-register|25 (let ((.x|30|33 (assq .v|9 *regnames*))) (begin (.check! (pair? .x|30|33) 1 .x|30|33) (cdr:pair .x|30|33)))) (.finish|25)) (if (not (memq .v|9 .free|15)) (begin (cg0 .output|3 .arg|12 #f .regs|3 .frame|3 .env|3 #f) (.finish|25)) (if .live|18 (begin (cg0 .output|3 .arg|12 'result .regs|3 .frame|3 .env|3 #f) (.release-registers!|25) (cg-let1-result .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)) (begin (.evaluate-into-register|25 (choose-register .regs|3 .frame|3)) (.finish|25))))))))))) (.cg-let1|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-let1))
(let () (begin (set! cg-let1-result (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-let1-result|2 0)) (begin (set! .cg-let1-result|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.proc|6 (call.proc .exp|3)) (.v|9 (let ((.x|63|66 (lambda.args .proc|6))) (begin (.check! (pair? .x|63|66) 0 .x|63|66) (car:pair .x|63|66)))) (.free|12 (lambda.f .proc|6)) (.live|15 (cgframe-livevars .frame|3)) (.body|18 (lambda.body .proc|6)) (.pattern|21 (cg-let-used-once .v|9 .body|18))) (let () (let ((.release-registers!|26 (unspecified)) (.move-to-register|26 (unspecified))) (begin (set! .release-registers!|26 (lambda () (begin (cgframe-livevars-set! .frame|3 .live|15) (cg-let-release! .free|12 .live|15 .regs|3 .frame|3 .tail?|3)))) (set! .move-to-register|26 (lambda (.r|28) (begin (gen! .output|3 $setreg .r|28) (cgreg-bind! .regs|3 .r|28 .v|9) (gen-store! .output|3 .frame|3 .r|28 .v|9) .r|28))) (let ((.temp|25|31 .pattern|21)) (if (memv .temp|25|31 '(if)) (cg-if-result .output|3 .body|18 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (memv .temp|25|31 '(let-if)) (begin (if .live|15 (cgframe-livevars-set! .frame|3 (union .live|15 .free|12)) (unspecified)) (cg-if-result .output|3 (let ((.x|34|37 (call.args .body|18))) (begin (.check! (pair? .x|34|37) 0 .x|34|37) (car:pair .x|34|37))) 'result .regs|3 .frame|3 .env|3 #f) (.release-registers!|26) (.cg-let1-result|2 .output|3 .body|18 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)) (if (memv .temp|25|31 '(set!)) (cg-assignment-result .output|3 .body|18 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (memv .temp|25|31 '(let-set!)) (begin (cg-assignment-result .output|3 (let ((.x|40|43 (call.args .body|18))) (begin (.check! (pair? .x|40|43) 0 .x|40|43) (car:pair .x|40|43))) 'result .regs|3 .frame|3 .env|3 #f) (.cg-let1-result|2 .output|3 .body|18 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)) (if (memv .temp|25|31 '(primop)) (cg-primop-result .output|3 .body|18 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (memv .temp|25|31 '(let-primop)) (begin (cg-primop-result .output|3 (let ((.x|46|49 (call.args .body|18))) (begin (.check! (pair? .x|46|49) 0 .x|46|49) (car:pair .x|46|49))) 'result .regs|3 .frame|3 .env|3 #f) (.cg-let1-result|2 .output|3 .body|18 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)) (if (memv .temp|25|31 '(_called)) (cg-call-result .output|3 .body|18 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (if (memv .temp|25|31 '(_let-called)) (begin (cg-call-result .output|3 (let ((.x|52|55 (call.args .body|18))) (begin (.check! (pair? .x|52|55) 0 .x|52|55) (car:pair .x|52|55))) 'result .regs|3 .frame|3 .env|3 #f) (.cg-let1-result|2 .output|3 .body|18 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)) (begin (if (assq .v|9 *regnames*) (.move-to-register|26 (let ((.x|58|61 (assq .v|9 *regnames*))) (begin (.check! (pair? .x|58|61) 1 .x|58|61) (cdr:pair .x|58|61)))) (if (memq .v|9 .free|12) (.move-to-register|26 (choose-register .regs|3 .frame|3)) (unspecified))) (cg-let-body .output|3 .proc|6 .target|3 .regs|3 .frame|3 .env|3 .tail?|3))))))))))))))))) (.cg-let1-result|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-let1-result))
(let () (begin (set! cg-primop-result (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-primop-result|2 0)) (begin (set! .cg-primop-result|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.args|6 (call.args .exp|3)) (.entry|6 (var-lookup (variable.name (call.proc .exp|3)) .regs|3 .frame|3 .env|3))) (if (= (entry.arity .entry|6) (length .args|6)) (begin (let ((.temp|7|10 (entry.arity .entry|6))) (if (memv .temp|7|10 '(0)) (gen! .output|3 $op1 (entry.op .entry|6)) (if (memv .temp|7|10 '(1)) (gen! .output|3 $op1 (entry.op .entry|6)) (if (memv .temp|7|10 '(2)) (cg-primop2-result! .output|3 .entry|6 .args|6 .regs|3 .frame|3 .env|3) (if (memv .temp|7|10 '(3)) (let ((.rs|17 (cg-result-args .output|3 .args|6 .regs|3 .frame|3 .env|3))) (gen! .output|3 $op3 (entry.op .entry|6) (let ((.x|18|21 .rs|17)) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))) (let ((.x|23|26 (let ((.x|27|30 .rs|17)) (begin (.check! (pair? .x|27|30) 1 .x|27|30) (cdr:pair .x|27|30))))) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26))))) (error "Bug detected by cg-primop-result" (make-readable .exp|3))))))) (if .tail?|3 (begin (gen-pop! .output|3 .frame|3) (gen! .output|3 $return) 'result) (cg-move .output|3 .frame|3 .regs|3 'result .target|3))) (if (< (entry.arity .entry|6) 0) (cg-special-result .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (error "Wrong number of arguments to integrable procedure" (make-readable .exp|3))))))) (.cg-primop-result|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-primop-result))
(let () (begin (set! cg-primop2-result! (lambda (.output|1 .entry|1 .args|1 .regs|1 .frame|1 .env|1) (let ((.cg-primop2-result!|2 0)) (begin (set! .cg-primop2-result!|2 (lambda (.output|3 .entry|3 .args|3 .regs|3 .frame|3 .env|3) (let ((.op|6 (entry.op .entry|3)) (.arg2|6 (let ((.x|18|21 (let ((.x|22|25 .args|3)) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))))) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))))) (if (if (constant? .arg2|6) (if (entry.imm .entry|3) ((entry.imm .entry|3) (constant.value .arg2|6)) #f) #f) (gen! .output|3 $op2imm .op|6 (constant.value .arg2|6)) (let ((.rs|12 (cg-result-args .output|3 .args|3 .regs|3 .frame|3 .env|3))) (gen! .output|3 $op2 .op|6 (let ((.x|13|16 .rs|12)) (begin (.check! (pair? .x|13|16) 0 .x|13|16) (car:pair .x|13|16))))))))) (.cg-primop2-result!|2 .output|1 .entry|1 .args|1 .regs|1 .frame|1 .env|1))))) 'cg-primop2-result!))
(let () (begin (set! cg-result-args (lambda (.output|1 .args|1 .regs|1 .frame|1 .env|1) (let ((.cg-result-args|2 0)) (begin (set! .cg-result-args|2 (lambda (.output|3 .args|3 .regs|3 .frame|3 .env|3) (let ((.save-result!|4 (unspecified)) (.loop|4 (unspecified))) (begin (set! .save-result!|4 (lambda (.args|5 .registers|5 .rr|5 .rs|5 .temps|5) (let ((.r|8 (let ((.x|13|16 .registers|5)) (begin (.check! (pair? .x|13|16) 0 .x|13|16) (car:pair .x|13|16))))) (begin (gen! .output|3 $setreg .r|8) (.loop|4 .args|5 (let ((.x|9|12 .registers|5)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12))) .r|8 .rs|5 .temps|5))))) (set! .loop|4 (lambda (.args|17 .registers|17 .rr|17 .rs|17 .temps|17) (if (null? .args|17) (begin (if (not (eq? .rr|17 'result)) (gen! .output|3 $reg .rr|17) (unspecified)) (let () (let ((.loop|23|25|28 (unspecified))) (begin (set! .loop|23|25|28 (lambda (.y1|18|19|29) (if (null? .y1|18|19|29) (if #f #f (unspecified)) (begin (begin #t (let ((.r|33 (let ((.x|34|37 .y1|18|19|29)) (begin (.check! (pair? .x|34|37) 0 .x|34|37) (car:pair .x|34|37))))) (cgreg-release! .regs|3 .r|33))) (.loop|23|25|28 (let ((.x|38|41 .y1|18|19|29)) (begin (.check! (pair? .x|38|41) 1 .x|38|41) (cdr:pair .x|38|41)))))))) (.loop|23|25|28 .temps|17)))) (reverse .rs|17)) (let ((.arg|44 (let ((.x|134|137 .args|17)) (begin (.check! (pair? .x|134|137) 0 .x|134|137) (car:pair .x|134|137))))) (if (constant? .arg|44) (let ((.r|48 (let ((.x|57|60 .registers|17)) (begin (.check! (pair? .x|57|60) 0 .x|57|60) (car:pair .x|57|60))))) (begin (gen! .output|3 $const/setreg (constant.value .arg|44) .r|48) (cgreg-bind! .regs|3 .r|48 #t) (.loop|4 (let ((.x|49|52 .args|17)) (begin (.check! (pair? .x|49|52) 1 .x|49|52) (cdr:pair .x|49|52))) (let ((.x|53|56 .registers|17)) (begin (.check! (pair? .x|53|56) 1 .x|53|56) (cdr:pair .x|53|56))) .rr|17 (cons .r|48 .rs|17) (cons .r|48 .temps|17)))) (if (variable? .arg|44) (let* ((.id|64 (variable.name .arg|44)) (.entry|67 (var-lookup .id|64 .regs|3 .frame|3 .env|3))) (let () (let ((.temp|71|74 (entry.kind .entry|67))) (if (memv .temp|71|74 '(global integrable)) (if (eq? .rr|17 'result) (.save-result!|4 .args|17 .registers|17 .rr|17 .rs|17 .temps|17) (let ((.r|78 (let ((.x|87|90 .registers|17)) (begin (.check! (pair? .x|87|90) 0 .x|87|90) (car:pair .x|87|90))))) (begin (gen! .output|3 $global .id|64) (gen! .output|3 $setreg .r|78) (cgreg-bind! .regs|3 .r|78 .id|64) (.loop|4 (let ((.x|79|82 .args|17)) (begin (.check! (pair? .x|79|82) 1 .x|79|82) (cdr:pair .x|79|82))) (let ((.x|83|86 .registers|17)) (begin (.check! (pair? .x|83|86) 1 .x|83|86) (cdr:pair .x|83|86))) .rr|17 (cons .r|78 .rs|17) (cons .r|78 .temps|17))))) (if (memv .temp|71|74 '(lexical)) (if (eq? .rr|17 'result) (.save-result!|4 .args|17 .registers|17 .rr|17 .rs|17 .temps|17) (let ((.m|94 (entry.rib .entry|67)) (.n|94 (entry.offset .entry|67)) (.r|94 (let ((.x|103|106 .registers|17)) (begin (.check! (pair? .x|103|106) 0 .x|103|106) (car:pair .x|103|106))))) (begin (gen! .output|3 $lexical .m|94 .n|94 .id|64) (gen! .output|3 $setreg .r|94) (cgreg-bind! .regs|3 .r|94 .id|64) (.loop|4 (let ((.x|95|98 .args|17)) (begin (.check! (pair? .x|95|98) 1 .x|95|98) (cdr:pair .x|95|98))) (let ((.x|99|102 .registers|17)) (begin (.check! (pair? .x|99|102) 1 .x|99|102) (cdr:pair .x|99|102))) .rr|17 (cons .r|94 .rs|17) (cons .r|94 .temps|17))))) (if (memv .temp|71|74 '(procedure)) (error "Bug in cg-variable" .arg|44) (if (memv .temp|71|74 '(register)) (let ((.r|111 (entry.regnum .entry|67))) (.loop|4 (let ((.x|112|115 .args|17)) (begin (.check! (pair? .x|112|115) 1 .x|112|115) (cdr:pair .x|112|115))) .registers|17 .rr|17 (cons .r|111 .rs|17) .temps|17)) (if (memv .temp|71|74 '(frame)) (let ((.r|119 (let ((.x|128|131 .registers|17)) (begin (.check! (pair? .x|128|131) 0 .x|128|131) (car:pair .x|128|131))))) (begin (gen-load! .output|3 .frame|3 .r|119 .id|64) (cgreg-bind! .regs|3 .r|119 .id|64) (.loop|4 (let ((.x|120|123 .args|17)) (begin (.check! (pair? .x|120|123) 1 .x|120|123) (cdr:pair .x|120|123))) (let ((.x|124|127 .registers|17)) (begin (.check! (pair? .x|124|127) 1 .x|124|127) (cdr:pair .x|124|127))) .rr|17 (cons .r|119 .rs|17) (cons .r|119 .temps|17)))) (error "Bug in cg-result-args" .arg|44))))))))) (error "Bug in cg-result-args"))))))) (.loop|4 (let ((.x|138|141 .args|3)) (begin (.check! (pair? .x|138|141) 1 .x|138|141) (cdr:pair .x|138|141))) (choose-registers .regs|3 .frame|3 (length .args|3)) 'result '() '()))))) (.cg-result-args|2 .output|1 .args|1 .regs|1 .frame|1 .env|1))))) 'cg-result-args))
(let () (begin (set! cg-let-used-once (lambda (.t1|1 .exp|1) (let ((.cg-let-used-once|2 0)) (begin (set! .cg-let-used-once|2 (lambda (.t1|3 .exp|3) (let ((.cg-let-used-once|4 (unspecified)) (.budget|4 (unspecified))) (begin (set! .cg-let-used-once|4 (lambda (.t1|5 .exp|5) (let ((.used-in-args?|6 (unspecified)) (.used?|6 (unspecified))) (begin (set! .used-in-args?|6 (lambda (.t1|7 .args|7) (if (null? .args|7) #f (let ((.temp|8|11 (.used?|6 .t1|7 (let ((.x|17|20 .args|7)) (begin (.check! (pair? .x|17|20) 0 .x|17|20) (car:pair .x|17|20)))))) (if .temp|8|11 .temp|8|11 (.used-in-args?|6 .t1|7 (let ((.x|13|16 .args|7)) (begin (.check! (pair? .x|13|16) 1 .x|13|16) (cdr:pair .x|13|16))))))))) (set! .used?|6 (lambda (.t1|21 .exp|21) (begin (set! .budget|4 (- .budget|4 1)) (if (< .budget|4 0) #t (if (constant? .exp|21) #f (if (variable? .exp|21) (eq? .t1|21 (variable.name .exp|21)) (if (lambda? .exp|21) (memq .t1|21 (lambda.f .exp|21)) (if (assignment? .exp|21) (.used?|6 .t1|21 (assignment.rhs .exp|21)) (if (call? .exp|21) (let ((.temp|29|32 (.used?|6 .t1|21 (call.proc .exp|21)))) (if .temp|29|32 .temp|29|32 (.used-in-args?|6 .t1|21 (call.args .exp|21)))) (if (conditional? .exp|21) (let ((.temp|35|38 (.used?|6 .t1|21 (if.test .exp|21)))) (if .temp|35|38 .temp|35|38 (let ((.temp|39|42 (.used?|6 .t1|21 (if.then .exp|21)))) (if .temp|39|42 .temp|39|42 (.used?|6 .t1|21 (if.else .exp|21)))))) #t)))))))))) (set! .budget|4 (- .budget|4 1)) (if (< .budget|4 0) #f (if (call? .exp|5) (let ((.proc|50 (call.proc .exp|5)) (.args|50 (call.args .exp|5))) (if (variable? .proc|50) (let ((.f|54 (variable.name .proc|50))) (if (eq? .f|54 .t1|5) (if (not (.used-in-args?|6 .t1|5 .args|50)) 'called #f) (if (if (integrable? .f|54) (if (not (null? .args|50)) (if (variable? (let ((.x|62|65 .args|50)) (begin (.check! (pair? .x|62|65) 0 .x|62|65) (car:pair .x|62|65)))) (eq? .t1|5 (variable.name (let ((.x|67|70 .args|50)) (begin (.check! (pair? .x|67|70) 0 .x|67|70) (car:pair .x|67|70))))) #f) #f) #f) (if (not (.used-in-args?|6 .t1|5 (let ((.x|72|75 .args|50)) (begin (.check! (pair? .x|72|75) 1 .x|72|75) (cdr:pair .x|72|75))))) 'primop #f) #f))) (if (lambda? .proc|50) (if (not (memq .t1|5 (lambda.f .proc|50))) (if (not (null? .args|50)) (if (null? (let ((.x|82|85 .args|50)) (begin (.check! (pair? .x|82|85) 1 .x|82|85) (cdr:pair .x|82|85)))) (let ((.temp|87|90 (.cg-let-used-once|4 .t1|5 (let ((.x|96|99 .args|50)) (begin (.check! (pair? .x|96|99) 0 .x|96|99) (car:pair .x|96|99)))))) (if (memv .temp|87|90 '(if)) 'let-if (if (memv .temp|87|90 '(primop)) 'let-primop (if (memv .temp|87|90 '(called)) 'let-called (if (memv .temp|87|90 '(set!)) 'let-set! #f))))) #f) #f) #f) #f))) (if (conditional? .exp|5) (let ((.e0|104 (if.test .exp|5))) (if (variable? .e0|104) (if (eq? .t1|5 (variable.name .e0|104)) (if (not (.used?|6 .t1|5 (if.then .exp|5))) (if (not (.used?|6 .t1|5 (if.else .exp|5))) 'if #f) #f) #f) #f)) (if (assignment? .exp|5) (let ((.rhs|113 (assignment.rhs .exp|5))) (if (variable? .rhs|113) (if (eq? .t1|5 (variable.name .rhs|113)) 'set! #f) #f)) #f)))))))) (set! .budget|4 20) (.cg-let-used-once|4 .t1|3 .exp|3))))) (.cg-let-used-once|2 .t1|1 .exp|1))))) 'cg-let-used-once))
(let () (begin (set! cg-let-transform (lambda (.pattern|1 .exp|1 .e1|1) (let ((.cg-let-transform|2 0)) (begin (set! .cg-let-transform|2 (lambda (.pattern|3 .exp|3 .e1|3) (let ((.temp|4|7 .pattern|3)) (if (memv .temp|4|7 '(if)) (make-conditional .e1|3 (if.then .exp|3) (if.else .exp|3)) (if (memv .temp|4|7 '(primop)) (make-call (call.proc .exp|3) (cons .e1|3 (let ((.x|10|13 (call.args .exp|3))) (begin (.check! (pair? .x|10|13) 1 .x|10|13) (cdr:pair .x|10|13))))) (if (memv .temp|4|7 '(called)) (make-call .e1|3 (call.args .exp|3)) (if (memv .temp|4|7 '(set!)) (make-assignment (assignment.lhs .exp|3) .e1|3) (if (memv .temp|4|7 '(let-if let-primop let-called let-set!)) (make-call (call.proc .exp|3) (cons (.cg-let-transform|2 (let ((.temp|18|21 .pattern|3)) (if (memv .temp|18|21 '(let-if)) 'if (if (memv .temp|18|21 '(let-primop)) 'primop (if (memv .temp|18|21 '(let-called)) 'called (if (memv .temp|18|21 '(let-set!)) 'set! (unspecified)))))) (let ((.x|26|29 (call.args .exp|3))) (begin (.check! (pair? .x|26|29) 0 .x|26|29) (car:pair .x|26|29))) .e1|3) '())) (error "Unrecognized pattern in cg-let-transform" .pattern|3))))))))) (.cg-let-transform|2 .pattern|1 .exp|1 .e1|1))))) 'cg-let-transform))
(let () (begin (set! cg-special (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-special|2 0)) (begin (set! .cg-special|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.name|6 (variable.name (call.proc .exp|3)))) (if (eq? .name|6 name:check!) (if (runtime-safety-checking) (cg-check .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (unspecified)) (error "Compiler bug: cg-special" (make-readable .exp|3)))))) (.cg-special|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-special))
(let () (begin (set! cg-special-result (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-special-result|2 0)) (begin (set! .cg-special-result|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let ((.name|6 (variable.name (call.proc .exp|3)))) (if (eq? .name|6 name:check!) (if (runtime-safety-checking) (cg-check-result .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (unspecified)) (error "Compiler bug: cg-special" (make-readable .exp|3)))))) (.cg-special-result|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-special-result))
(let () (begin (set! cg-check (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-check|2 0)) (begin (set! .cg-check|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (begin (cg0 .output|3 (let ((.x|4|7 (call.args .exp|3))) (begin (.check! (pair? .x|4|7) 0 .x|4|7) (car:pair .x|4|7))) 'result .regs|3 .frame|3 .env|3 #f) (cg-check-result .output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3)))) (.cg-check|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-check))
(let () (begin (set! cg-check-result (lambda (.output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1) (let ((.cg-check-result|2 0)) (begin (set! .cg-check-result|2 (lambda (.output|3 .exp|3 .target|3 .regs|3 .frame|3 .env|3 .tail?|3) (let* ((.args|6 (call.args .exp|3)) (.nargs|9 (length .args|6)) (.valexps|12 (let ((.x|173|176 (let ((.x|177|180 .args|6)) (begin (.check! (pair? .x|177|180) 1 .x|177|180) (cdr:pair .x|177|180))))) (begin (.check! (pair? .x|173|176) 1 .x|173|176) (cdr:pair .x|173|176))))) (let () (if (if (let ((.t|17|20 .nargs|9)) (if (<= 2 .t|17|20) (<= .t|17|20 5) #f)) (if (constant? (let ((.x|25|28 (let ((.x|29|32 .args|6)) (begin (.check! (pair? .x|29|32) 1 .x|29|32) (cdr:pair .x|29|32))))) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28)))) (every? (lambda (.exp|34) (let ((.temp|35|38 (constant? .exp|34))) (if .temp|35|38 .temp|35|38 (variable? .exp|34)))) .valexps|12) #f) #f) (let* ((.exn|42 (constant.value (let ((.x|164|167 (let ((.x|168|171 .args|6)) (begin (.check! (pair? .x|168|171) 1 .x|168|171) (cdr:pair .x|168|171))))) (begin (.check! (pair? .x|164|167) 0 .x|164|167) (car:pair .x|164|167))))) (.vars|45 (filter variable? .valexps|12)) (.rs|48 (cg-result-args .output|3 (cons (let ((.x|159|162 .args|6)) (begin (.check! (pair? .x|159|162) 0 .x|159|162) (car:pair .x|159|162))) .vars|45) .regs|3 .frame|3 .env|3))) (let () (let ((.registers|54 .rs|48) (.exps|54 .valexps|12) (.operands|54 '())) (let () (let ((.loop|57 (unspecified))) (begin (set! .loop|57 (lambda (.registers|58 .exps|58 .operands|58) (if (null? .exps|58) (let* ((.situation|62 (cons .exn|42 (reverse .operands|58))) (.ht|65 (assembly-stream-info .output|3)) (.l1|68 (let ((.temp|125|128 (hashtable-get .ht|65 .situation|62))) (if .temp|125|128 .temp|125|128 (let ((.l1|132 (make-label))) (begin (hashtable-put! .ht|65 .situation|62 .l1|132) .l1|132)))))) (let () (let ((.translate|73 (unspecified))) (begin (set! .translate|73 (lambda (.r|74) (if (number? .r|74) .r|74 0))) (let ((.temp|72|77 (length .operands|58))) (if (memv .temp|72|77 '(0)) (gen! .output|3 $check 0 0 0 .l1|68) (if (memv .temp|72|77 '(1)) (gen! .output|3 $check (.translate|73 (let ((.x|80|83 .operands|58)) (begin (.check! (pair? .x|80|83) 0 .x|80|83) (car:pair .x|80|83)))) 0 0 .l1|68) (if (memv .temp|72|77 '(2)) (gen! .output|3 $check (.translate|73 (let ((.x|85|88 .operands|58)) (begin (.check! (pair? .x|85|88) 0 .x|85|88) (car:pair .x|85|88)))) (.translate|73 (let ((.x|90|93 (let ((.x|94|97 .operands|58)) (begin (.check! (pair? .x|94|97) 1 .x|94|97) (cdr:pair .x|94|97))))) (begin (.check! (pair? .x|90|93) 0 .x|90|93) (car:pair .x|90|93)))) 0 .l1|68) (if (memv .temp|72|77 '(3)) (gen! .output|3 $check (.translate|73 (let ((.x|99|102 .operands|58)) (begin (.check! (pair? .x|99|102) 0 .x|99|102) (car:pair .x|99|102)))) (.translate|73 (let ((.x|104|107 (let ((.x|108|111 .operands|58)) (begin (.check! (pair? .x|108|111) 1 .x|108|111) (cdr:pair .x|108|111))))) (begin (.check! (pair? .x|104|107) 0 .x|104|107) (car:pair .x|104|107)))) (.translate|73 (let ((.x|113|116 (let ((.x|117|120 (let ((.x|121|124 .operands|58)) (begin (.check! (pair? .x|121|124) 1 .x|121|124) (cdr:pair .x|121|124))))) (begin (.check! (pair? .x|117|120) 1 .x|117|120) (cdr:pair .x|117|120))))) (begin (.check! (pair? .x|113|116) 0 .x|113|116) (car:pair .x|113|116)))) .l1|68) (unspecified)))))))))) (if (constant? (let ((.x|134|137 .exps|58)) (begin (.check! (pair? .x|134|137) 0 .x|134|137) (car:pair .x|134|137)))) (.loop|57 .registers|58 (let ((.x|138|141 .exps|58)) (begin (.check! (pair? .x|138|141) 1 .x|138|141) (cdr:pair .x|138|141))) (cons (let ((.x|142|145 .exps|58)) (begin (.check! (pair? .x|142|145) 0 .x|142|145) (car:pair .x|142|145))) .operands|58)) (.loop|57 (let ((.x|147|150 .registers|58)) (begin (.check! (pair? .x|147|150) 1 .x|147|150) (cdr:pair .x|147|150))) (let ((.x|151|154 .exps|58)) (begin (.check! (pair? .x|151|154) 1 .x|151|154) (cdr:pair .x|151|154))) (cons (let ((.x|155|158 .registers|58)) (begin (.check! (pair? .x|155|158) 0 .x|155|158) (car:pair .x|155|158))) .operands|58)))))) (.loop|57 .registers|54 .exps|54 .operands|54))))))) (error "Compiler bug: runtime check" (make-readable .exp|3))))))) (.cg-check-result|2 .output|1 .exp|1 .target|1 .regs|1 .frame|1 .env|1 .tail?|1))))) 'cg-check-result))
(let () (begin (set! cg-trap (lambda (.output|1 .situation|1 .l1|1) (let ((.cg-trap|2 0)) (begin (set! .cg-trap|2 (lambda (.output|3 .situation|3 .l1|3) (let* ((.exn|6 (let ((.x|99|102 .situation|3)) (begin (.check! (pair? .x|99|102) 0 .x|99|102) (car:pair .x|99|102)))) (.operands|9 (let ((.x|95|98 .situation|3)) (begin (.check! (pair? .x|95|98) 1 .x|95|98) (cdr:pair .x|95|98))))) (let () (begin (gen! .output|3 $.label .l1|3) (let* ((.liveregs|15 (filter number? .operands|9)) (.loop|16 (unspecified))) (begin (set! .loop|16 (lambda (.operands|17 .registers|17 .r|17) (if (null? .operands|17) (let ((.temp|19|22 (length .registers|17))) (if (memv .temp|19|22 '(0)) (gen! .output|3 $trap 0 0 0 .exn|6) (if (memv .temp|19|22 '(1)) (gen! .output|3 $trap (let ((.x|25|28 .registers|17)) (begin (.check! (pair? .x|25|28) 0 .x|25|28) (car:pair .x|25|28))) 0 0 .exn|6) (if (memv .temp|19|22 '(2)) (gen! .output|3 $trap (let ((.x|30|33 .registers|17)) (begin (.check! (pair? .x|30|33) 0 .x|30|33) (car:pair .x|30|33))) (let ((.x|35|38 (let ((.x|39|42 .registers|17)) (begin (.check! (pair? .x|39|42) 1 .x|39|42) (cdr:pair .x|39|42))))) (begin (.check! (pair? .x|35|38) 0 .x|35|38) (car:pair .x|35|38))) 0 .exn|6) (if (memv .temp|19|22 '(3)) (gen! .output|3 $trap (let ((.x|44|47 .registers|17)) (begin (.check! (pair? .x|44|47) 0 .x|44|47) (car:pair .x|44|47))) (let ((.x|49|52 (let ((.x|53|56 .registers|17)) (begin (.check! (pair? .x|53|56) 1 .x|53|56) (cdr:pair .x|53|56))))) (begin (.check! (pair? .x|49|52) 0 .x|49|52) (car:pair .x|49|52))) (let ((.x|58|61 (let ((.x|62|65 (let ((.x|66|69 .registers|17)) (begin (.check! (pair? .x|66|69) 1 .x|66|69) (cdr:pair .x|66|69))))) (begin (.check! (pair? .x|62|65) 1 .x|62|65) (cdr:pair .x|62|65))))) (begin (.check! (pair? .x|58|61) 0 .x|58|61) (car:pair .x|58|61))) .exn|6) "Compiler bug: trap"))))) (if (number? (let ((.x|72|75 .operands|17)) (begin (.check! (pair? .x|72|75) 0 .x|72|75) (car:pair .x|72|75)))) (.loop|16 (let ((.x|76|79 .operands|17)) (begin (.check! (pair? .x|76|79) 1 .x|76|79) (cdr:pair .x|76|79))) (cons (let ((.x|80|83 .operands|17)) (begin (.check! (pair? .x|80|83) 0 .x|80|83) (car:pair .x|80|83))) .registers|17) .r|17) (if (memv .r|17 .liveregs|15) (.loop|16 .operands|17 .registers|17 (+ .r|17 1)) (begin (gen! .output|3 $const (constant.value (let ((.x|87|90 .operands|17)) (begin (.check! (pair? .x|87|90) 0 .x|87|90) (car:pair .x|87|90))))) (gen! .output|3 $setreg .r|17) (.loop|16 (let ((.x|91|94 .operands|17)) (begin (.check! (pair? .x|91|94) 1 .x|91|94) (cdr:pair .x|91|94))) (cons .r|17 .registers|17) (+ .r|17 1)))))))) (.loop|16 (reverse .operands|9) '() 1)))))))) (.cg-trap|2 .output|1 .situation|1 .l1|1))))) 'cg-trap))
(let () (begin (set! cg-check-args (lambda (.output|1 .args|1 .regs|1 .frame|1 .env|1) (let ((.cg-check-args|2 0)) (begin (set! .cg-check-args|2 (lambda (.output|3 .args|3 .regs|3 .frame|3 .env|3) (let ((.finish-loop|4 (unspecified)) (.eval-first-into-result|4 (unspecified)) (.eval-loop|4 (unspecified))) (begin (set! .finish-loop|4 (lambda (.disjoint|5 .temps|5 .mask|5 .registers|5) (if (null? .temps|5) .registers|5 (let* ((.t|8 (let ((.x|54|57 .temps|5)) (begin (.check! (pair? .x|54|57) 0 .x|54|57) (car:pair .x|54|57)))) (.entry|11 (cgreg-lookup .regs|3 .t|8))) (let () (if .entry|11 (let ((.r|17 (entry.regnum .entry|11))) (begin (if (let ((.x|18|21 .mask|5)) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))) (begin (cgreg-release! .regs|3 .r|17) (cgframe-release! .frame|3 .t|8)) (unspecified)) (.finish-loop|4 .disjoint|5 (let ((.x|22|25 .temps|5)) (begin (.check! (pair? .x|22|25) 1 .x|22|25) (cdr:pair .x|22|25))) (let ((.x|26|29 .mask|5)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29))) (cons .r|17 .registers|5)))) (let ((.r|32 (let ((.x|50|53 .disjoint|5)) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53))))) (if (memv .r|32 .registers|5) (.finish-loop|4 (let ((.x|34|37 .disjoint|5)) (begin (.check! (pair? .x|34|37) 1 .x|34|37) (cdr:pair .x|34|37))) .temps|5 .mask|5 .registers|5) (begin (gen-load! .output|3 .frame|3 .r|32 .t|8) (cgreg-bind! .regs|3 .r|32 .t|8) (if (let ((.x|38|41 .mask|5)) (begin (.check! (pair? .x|38|41) 0 .x|38|41) (car:pair .x|38|41))) (begin (cgreg-release! .regs|3 .r|32) (cgframe-release! .frame|3 .t|8)) (unspecified)) (.finish-loop|4 .disjoint|5 (let ((.x|42|45 .temps|5)) (begin (.check! (pair? .x|42|45) 1 .x|42|45) (cdr:pair .x|42|45))) (let ((.x|46|49 .mask|5)) (begin (.check! (pair? .x|46|49) 1 .x|46|49) (cdr:pair .x|46|49))) (cons .r|32 .registers|5))))))))))) (set! .eval-first-into-result|4 (lambda (.temps|58 .mask|58) (begin (cg0 .output|3 (let ((.x|59|62 .args|3)) (begin (.check! (pair? .x|59|62) 0 .x|59|62) (car:pair .x|59|62))) 'result .regs|3 .frame|3 .env|3 #f) (.finish-loop|4 (choose-registers .regs|3 .frame|3 (length .temps|58)) .temps|58 .mask|58 '())))) (set! .eval-loop|4 (lambda (.args|63 .temps|63 .mask|63) (if (null? .args|63) (.eval-first-into-result|4 .temps|63 .mask|63) (let ((.reg|66 (cg0 .output|3 (let ((.x|84|87 .args|63)) (begin (.check! (pair? .x|84|87) 0 .x|84|87) (car:pair .x|84|87))) #f .regs|3 .frame|3 .env|3 #f))) (if (eq? .reg|66 'result) (let* ((.r|69 (choose-register .regs|3 .frame|3)) (.t|72 (newtemp))) (let () (begin (gen! .output|3 $setreg .r|69) (cgreg-bind! .regs|3 .r|69 .t|72) (gen-store! .output|3 .frame|3 .r|69 .t|72) (.eval-loop|4 (let ((.x|76|79 .args|63)) (begin (.check! (pair? .x|76|79) 1 .x|76|79) (cdr:pair .x|76|79))) (cons .t|72 .temps|63) (cons #t .mask|63))))) (.eval-loop|4 (let ((.x|80|83 .args|63)) (begin (.check! (pair? .x|80|83) 1 .x|80|83) (cdr:pair .x|80|83))) (cons (cgreg-lookup-reg .regs|3 .reg|66) .temps|63) (cons #f .mask|63))))))) (if (< (length .args|3) *nregs*) (.eval-loop|4 (let ((.x|88|91 .args|3)) (begin (.check! (pair? .x|88|91) 1 .x|88|91) (cdr:pair .x|88|91))) '() '()) (error "Bug detected by cg-primop-args" .args|3)))))) (.cg-check-args|2 .output|1 .args|1 .regs|1 .frame|1 .env|1))))) 'cg-check-args))
(let () (begin (set! filter-basic-blocks (let* ((.suppression-message|3 "Local optimization detected a useless instruction.") (.forward:normal|6 0) (.forward:nop|9 1) (.forward:ends-block|12 2) (.forward:interesting|15 3) (.forward:kills-all-registers|18 4) (.forward:nop-if-arg1-is-negative|21 5) (.backward:normal|24 0) (.backward:ends-block|27 1) (.backward:begins-block|30 2) (.backward:uses-arg1|33 4) (.backward:uses-arg2|36 8) (.backward:uses-arg3|39 16) (.backward:kills-arg1|42 32) (.backward:kills-arg2|45 64) (.backward:uses-many|48 128) (.dispatch-table-size|51 *number-of-mnemonics*) (.forward-table|54 (make-bytevector .dispatch-table-size|51)) (.backward-table|57 (make-bytevector .dispatch-table-size|51))) (let () (begin (let () (let ((.loop|62|64|67 (unspecified))) (begin (set! .loop|62|64|67 (lambda (.i|68) (if (= .i|68 .dispatch-table-size|51) (if #f #f (unspecified)) (begin (begin #t (bytevector-set! .forward-table|54 .i|68 .forward:normal|6) (bytevector-set! .backward-table|57 .i|68 .backward:normal|24)) (.loop|62|64|67 (+ .i|68 1)))))) (.loop|62|64|67 0)))) (bytevector-set! .forward-table|54 $nop .forward:nop|9) (bytevector-set! .forward-table|54 $invoke .forward:ends-block|12) (bytevector-set! .forward-table|54 $return .forward:ends-block|12) (bytevector-set! .forward-table|54 $skip .forward:ends-block|12) (bytevector-set! .forward-table|54 $branch .forward:ends-block|12) (bytevector-set! .forward-table|54 $branchf .forward:ends-block|12) (bytevector-set! .forward-table|54 $jump .forward:ends-block|12) (bytevector-set! .forward-table|54 $.align .forward:ends-block|12) (bytevector-set! .forward-table|54 $.proc .forward:ends-block|12) (bytevector-set! .forward-table|54 $.cont .forward:ends-block|12) (bytevector-set! .forward-table|54 $.label .forward:ends-block|12) (bytevector-set! .forward-table|54 $store .forward:interesting|15) (bytevector-set! .forward-table|54 $load .forward:interesting|15) (bytevector-set! .forward-table|54 $setstk .forward:interesting|15) (bytevector-set! .forward-table|54 $setreg .forward:interesting|15) (bytevector-set! .forward-table|54 $movereg .forward:interesting|15) (bytevector-set! .forward-table|54 $const/setreg .forward:interesting|15) (bytevector-set! .forward-table|54 $args>= .forward:kills-all-registers|18) (bytevector-set! .forward-table|54 $popstk .forward:kills-all-registers|18) (bytevector-set! .forward-table|54 $save .forward:nop-if-arg1-is-negative|21) (bytevector-set! .forward-table|54 $restore .forward:nop-if-arg1-is-negative|21) (bytevector-set! .forward-table|54 $pop .forward:nop-if-arg1-is-negative|21) (bytevector-set! .backward-table|57 $invoke .backward:ends-block|27) (bytevector-set! .backward-table|57 $return .backward:ends-block|27) (bytevector-set! .backward-table|57 $skip .backward:ends-block|27) (bytevector-set! .backward-table|57 $branch .backward:ends-block|27) (bytevector-set! .backward-table|57 $branchf .backward:ends-block|27) (bytevector-set! .backward-table|57 $jump .backward:begins-block|30) (bytevector-set! .backward-table|57 $.align .backward:begins-block|30) (bytevector-set! .backward-table|57 $.proc .backward:begins-block|30) (bytevector-set! .backward-table|57 $.cont .backward:begins-block|30) (bytevector-set! .backward-table|57 $.label .backward:begins-block|30) (bytevector-set! .backward-table|57 $op2 .backward:uses-arg2|36) (bytevector-set! .backward-table|57 $op3 (logior .backward:uses-arg2|36 .backward:uses-arg3|39)) (bytevector-set! .backward-table|57 $check (logior .backward:uses-arg1|33 (logior .backward:uses-arg2|36 .backward:uses-arg3|39))) (bytevector-set! .backward-table|57 $trap (logior .backward:uses-arg1|33 (logior .backward:uses-arg2|36 .backward:uses-arg3|39))) (bytevector-set! .backward-table|57 $store .backward:uses-arg1|33) (bytevector-set! .backward-table|57 $reg .backward:uses-arg1|33) (bytevector-set! .backward-table|57 $load .backward:kills-arg1|42) (bytevector-set! .backward-table|57 $setreg .backward:kills-arg1|42) (bytevector-set! .backward-table|57 $movereg (logior .backward:uses-arg1|33 .backward:kills-arg2|45)) (bytevector-set! .backward-table|57 $const/setreg .backward:kills-arg2|45) (bytevector-set! .backward-table|57 $lambda .backward:uses-many|48) (bytevector-set! .backward-table|57 $lexes .backward:uses-many|48) (bytevector-set! .backward-table|57 $args>= .backward:uses-many|48) (lambda (.instructions|71) (let* ((.*nregs*|74 *nregs*) (.registers|77 (make-vector .*nregs*|74 #f)) (.label-table|80 (make-hashtable (lambda (.n|532) .n|532) assv))) (let () (let ((.local-optimization-error|84 (unspecified)) (.suppress-backwards|84 (unspecified)) (.suppress-forwards|84 (unspecified)) (.backwards0|84 (unspecified)) (.backwards|84 (unspecified)) (.forwards-label|84 (unspecified)) (.forwards|84 (unspecified)) (.kill-stack!|84 (unspecified)) (.subvector-fill!|84 (unspecified)) (.vector-fill!|84 (unspecified)) (.lookup-label|84 (unspecified)) (.compute-transitive-closure!|84 (unspecified))) (begin (set! .local-optimization-error|84 (lambda (.op|85) (error "Compiler bug: local optimization" .op|85))) (set! .suppress-backwards|84 (lambda (.instruction|86 .instructions|86 .filtered|86) (begin (if (issue-warnings) '(begin (display suppression-message) (newline)) (unspecified)) (.backwards|84 .instructions|86 .filtered|86)))) (set! .suppress-forwards|84 (lambda (.instruction|87 .instructions|87 .filtered|87) (begin (if (issue-warnings) '(begin (display suppression-message) (newline)) (unspecified)) (.forwards|84 .instructions|87 .filtered|87)))) (set! .backwards0|84 (lambda (.instructions|88 .filtered|88) (if (null? .instructions|88) .filtered|88 (let* ((.instruction|91 (let ((.x|233|236 .instructions|88)) (begin (.check! (pair? .x|233|236) 0 .x|233|236) (car:pair .x|233|236)))) (.mnemonic|94 (instruction.op .instruction|91))) (let () (if (let ((.temp|99|102 (eqv? .mnemonic|94 $.label))) (if .temp|99|102 .temp|99|102 (let ((.temp|103|106 (eqv? .mnemonic|94 $.proc))) (if .temp|103|106 .temp|103|106 (let ((.temp|107|110 (eqv? .mnemonic|94 $.cont))) (if .temp|107|110 .temp|107|110 (eqv? .mnemonic|94 $.align))))))) (.backwards0|84 (let ((.x|116|119 .instructions|88)) (begin (.check! (pair? .x|116|119) 1 .x|116|119) (cdr:pair .x|116|119))) (cons .instruction|91 .filtered|88)) (if (eqv? .mnemonic|94 $return) (begin (.vector-fill!|84 .registers|77 #f) (let ((.v|122|125 .registers|77) (.i|122|125 0) (.x|122|125 #t)) (begin (.check! (fixnum? .i|122|125) 41 .v|122|125 .i|122|125 .x|122|125) (.check! (vector? .v|122|125) 41 .v|122|125 .i|122|125 .x|122|125) (.check! (<:fix:fix .i|122|125 (vector-length:vec .v|122|125)) 41 .v|122|125 .i|122|125 .x|122|125) (.check! (>=:fix:fix .i|122|125 0) 41 .v|122|125 .i|122|125 .x|122|125) (vector-set!:trusted .v|122|125 .i|122|125 .x|122|125))) (.backwards|84 (let ((.x|126|129 .instructions|88)) (begin (.check! (pair? .x|126|129) 1 .x|126|129) (cdr:pair .x|126|129))) (cons .instruction|91 .filtered|88))) (if (eqv? .mnemonic|94 $invoke) (let ((.n+1|134 (min .*nregs*|74 (+ (instruction.arg1 .instruction|91) 1)))) (begin (.subvector-fill!|84 .registers|77 0 .n+1|134 #t) (.subvector-fill!|84 .registers|77 .n+1|134 .*nregs*|74 #f) (.backwards|84 (let ((.x|135|138 .instructions|88)) (begin (.check! (pair? .x|135|138) 1 .x|135|138) (cdr:pair .x|135|138))) (cons .instruction|91 .filtered|88)))) (if (let ((.temp|140|143 (eqv? .mnemonic|94 $skip))) (if .temp|140|143 .temp|140|143 (eqv? .mnemonic|94 $branch))) (let* ((.live|149 (instruction.arg2 .instruction|91)) (.n+1|152 (min .*nregs*|74 (+ .live|149 1)))) (let () (begin (.subvector-fill!|84 .registers|77 0 .n+1|152 #t) (.subvector-fill!|84 .registers|77 .n+1|152 .*nregs*|74 #f) (let ((.instruction|158 (let* ((.t1|163|166 .mnemonic|94) (.t2|163|169 (let* ((.t1|173|176 (.lookup-label|84 (instruction.arg1 .instruction|91))) (.t2|173|179 (cons .live|149 '()))) (let () (cons .t1|173|176 .t2|173|179))))) (let () (cons .t1|163|166 .t2|163|169))))) (.backwards|84 (let ((.x|159|162 .instructions|88)) (begin (.check! (pair? .x|159|162) 1 .x|159|162) (cdr:pair .x|159|162))) (cons .instruction|158 .filtered|88)))))) (if (eqv? .mnemonic|94 $jump) (let ((.n+1|188 (min .*nregs*|74 (+ (instruction.arg3 .instruction|91) 1)))) (begin (.subvector-fill!|84 .registers|77 0 .n+1|188 #t) (.subvector-fill!|84 .registers|77 .n+1|188 .*nregs*|74 #f) (.backwards|84 (let ((.x|189|192 .instructions|88)) (begin (.check! (pair? .x|189|192) 1 .x|189|192) (cdr:pair .x|189|192))) (cons .instruction|91 .filtered|88)))) (if (eqv? .mnemonic|94 $branchf) (let* ((.live|197 (instruction.arg2 .instruction|91)) (.n+1|200 (min .*nregs*|74 (+ .live|197 1)))) (let () (begin (.subvector-fill!|84 .registers|77 0 .n+1|200 #t) (let ((.instruction|206 (let* ((.t1|211|214 .mnemonic|94) (.t2|211|217 (let* ((.t1|221|224 (.lookup-label|84 (instruction.arg1 .instruction|91))) (.t2|221|227 (cons .live|197 '()))) (let () (cons .t1|221|224 .t2|221|227))))) (let () (cons .t1|211|214 .t2|211|217))))) (.backwards|84 (let ((.x|207|210 .instructions|88)) (begin (.check! (pair? .x|207|210) 1 .x|207|210) (cdr:pair .x|207|210))) (cons .instruction|206 .filtered|88)))))) (.backwards|84 .instructions|88 .filtered|88)))))))))))) (set! .backwards|84 (lambda (.instructions|237 .filtered|237) (if (null? .instructions|237) .filtered|237 (let* ((.instruction|240 (let ((.x|329|332 .instructions|237)) (begin (.check! (pair? .x|329|332) 0 .x|329|332) (car:pair .x|329|332)))) (.instructions|243 (let ((.x|325|328 .instructions|237)) (begin (.check! (pair? .x|325|328) 1 .x|325|328) (cdr:pair .x|325|328)))) (.op|246 (instruction.op .instruction|240)) (.flags|249 (bytevector-ref .backward-table|57 .op|246))) (let () (if (eqv? .flags|249 .backward:normal|24) (.backwards|84 .instructions|243 (cons .instruction|240 .filtered|237)) (if (eqv? .flags|249 .backward:ends-block|27) (.backwards0|84 (cons .instruction|240 .instructions|243) .filtered|237) (if (eqv? .flags|249 .backward:begins-block|30) (.backwards0|84 .instructions|243 (cons .instruction|240 .filtered|237)) (if (eqv? .flags|249 .backward:uses-many|48) (if (let ((.temp|262|265 (eqv? .op|246 $lambda))) (if .temp|262|265 .temp|262|265 (eqv? .op|246 $lexes))) (let ((.live|271 (if (eqv? .op|246 $lexes) (instruction.arg1 .instruction|240) (instruction.arg2 .instruction|240)))) (begin (.subvector-fill!|84 .registers|77 0 (min .*nregs*|74 (+ 1 .live|271)) #t) (.backwards|84 .instructions|243 (cons .instruction|240 .filtered|237)))) (if (eqv? .op|246 $args>=) (begin (.vector-fill!|84 .registers|77 #t) (.backwards|84 .instructions|243 (cons .instruction|240 .filtered|237))) (.local-optimization-error|84 .op|246))) (if (if (eqv? (logand .flags|249 .backward:kills-arg1|42) .backward:kills-arg1|42) (not (let ((.v|280|283 .registers|77) (.i|280|283 (instruction.arg1 .instruction|240))) (begin (.check! (fixnum? .i|280|283) 40 .v|280|283 .i|280|283) (.check! (vector? .v|280|283) 40 .v|280|283 .i|280|283) (.check! (<:fix:fix .i|280|283 (vector-length:vec .v|280|283)) 40 .v|280|283 .i|280|283) (.check! (>=:fix:fix .i|280|283 0) 40 .v|280|283 .i|280|283) (vector-ref:trusted .v|280|283 .i|280|283)))) #f) (.suppress-backwards|84 .instruction|240 .instructions|243 .filtered|237) (if (if (eqv? (logand .flags|249 .backward:kills-arg2|45) .backward:kills-arg2|45) (not (let ((.v|288|291 .registers|77) (.i|288|291 (instruction.arg2 .instruction|240))) (begin (.check! (fixnum? .i|288|291) 40 .v|288|291 .i|288|291) (.check! (vector? .v|288|291) 40 .v|288|291 .i|288|291) (.check! (<:fix:fix .i|288|291 (vector-length:vec .v|288|291)) 40 .v|288|291 .i|288|291) (.check! (>=:fix:fix .i|288|291 0) 40 .v|288|291 .i|288|291) (vector-ref:trusted .v|288|291 .i|288|291)))) #f) (.suppress-backwards|84 .instruction|240 .instructions|243 .filtered|237) (if (if (eqv? .op|246 $movereg) (= (instruction.arg1 .instruction|240) (instruction.arg2 .instruction|240)) #f) (.backwards|84 .instructions|243 .filtered|237) (let ((.filtered|299 (cons .instruction|240 .filtered|237))) (begin (if (eqv? (logand .flags|249 .backward:kills-arg1|42) .backward:kills-arg1|42) (let ((.v|301|304 .registers|77) (.i|301|304 (instruction.arg1 .instruction|240)) (.x|301|304 #f)) (begin (.check! (fixnum? .i|301|304) 41 .v|301|304 .i|301|304 .x|301|304) (.check! (vector? .v|301|304) 41 .v|301|304 .i|301|304 .x|301|304) (.check! (<:fix:fix .i|301|304 (vector-length:vec .v|301|304)) 41 .v|301|304 .i|301|304 .x|301|304) (.check! (>=:fix:fix .i|301|304 0) 41 .v|301|304 .i|301|304 .x|301|304) (vector-set!:trusted .v|301|304 .i|301|304 .x|301|304))) (unspecified)) (if (eqv? (logand .flags|249 .backward:kills-arg2|45) .backward:kills-arg2|45) (let ((.v|306|309 .registers|77) (.i|306|309 (instruction.arg2 .instruction|240)) (.x|306|309 #f)) (begin (.check! (fixnum? .i|306|309) 41 .v|306|309 .i|306|309 .x|306|309) (.check! (vector? .v|306|309) 41 .v|306|309 .i|306|309 .x|306|309) (.check! (<:fix:fix .i|306|309 (vector-length:vec .v|306|309)) 41 .v|306|309 .i|306|309 .x|306|309) (.check! (>=:fix:fix .i|306|309 0) 41 .v|306|309 .i|306|309 .x|306|309) (vector-set!:trusted .v|306|309 .i|306|309 .x|306|309))) (unspecified)) (if (eqv? (logand .flags|249 .backward:uses-arg1|33) .backward:uses-arg1|33) (let ((.v|311|314 .registers|77) (.i|311|314 (instruction.arg1 .instruction|240)) (.x|311|314 #t)) (begin (.check! (fixnum? .i|311|314) 41 .v|311|314 .i|311|314 .x|311|314) (.check! (vector? .v|311|314) 41 .v|311|314 .i|311|314 .x|311|314) (.check! (<:fix:fix .i|311|314 (vector-length:vec .v|311|314)) 41 .v|311|314 .i|311|314 .x|311|314) (.check! (>=:fix:fix .i|311|314 0) 41 .v|311|314 .i|311|314 .x|311|314) (vector-set!:trusted .v|311|314 .i|311|314 .x|311|314))) (unspecified)) (if (eqv? (logand .flags|249 .backward:uses-arg2|36) .backward:uses-arg2|36) (let ((.v|316|319 .registers|77) (.i|316|319 (instruction.arg2 .instruction|240)) (.x|316|319 #t)) (begin (.check! (fixnum? .i|316|319) 41 .v|316|319 .i|316|319 .x|316|319) (.check! (vector? .v|316|319) 41 .v|316|319 .i|316|319 .x|316|319) (.check! (<:fix:fix .i|316|319 (vector-length:vec .v|316|319)) 41 .v|316|319 .i|316|319 .x|316|319) (.check! (>=:fix:fix .i|316|319 0) 41 .v|316|319 .i|316|319 .x|316|319) (vector-set!:trusted .v|316|319 .i|316|319 .x|316|319))) (unspecified)) (if (eqv? (logand .flags|249 .backward:uses-arg3|39) .backward:uses-arg3|39) (let ((.v|321|324 .registers|77) (.i|321|324 (instruction.arg3 .instruction|240)) (.x|321|324 #t)) (begin (.check! (fixnum? .i|321|324) 41 .v|321|324 .i|321|324 .x|321|324) (.check! (vector? .v|321|324) 41 .v|321|324 .i|321|324 .x|321|324) (.check! (<:fix:fix .i|321|324 (vector-length:vec .v|321|324)) 41 .v|321|324 .i|321|324 .x|321|324) (.check! (>=:fix:fix .i|321|324 0) 41 .v|321|324 .i|321|324 .x|321|324) (vector-set!:trusted .v|321|324 .i|321|324 .x|321|324))) (unspecified)) (.backwards|84 .instructions|243 .filtered|299))))))))))))))) (set! .forwards-label|84 (lambda (.instruction1|333 .instructions|333 .filtered|333) (let ((.label1|336 (instruction.arg1 .instruction1|333))) (if (null? .instructions|333) (.forwards|84 .instructions|333 (let ((.x|337|340 .filtered|333)) (begin (.check! (pair? .x|337|340) 1 .x|337|340) (cdr:pair .x|337|340)))) (let ((.instructions|343 .instructions|333) (.filtered|343 (cons .instruction1|333 .filtered|333))) (let () (let ((.loop|346 (unspecified))) (begin (set! .loop|346 (lambda (.instructions|347 .filtered|347) (let* ((.instruction|350 (let ((.x|398|401 .instructions|347)) (begin (.check! (pair? .x|398|401) 0 .x|398|401) (car:pair .x|398|401)))) (.op|353 (instruction.op .instruction|350)) (.flags|356 (bytevector-ref .forward-table|54 .op|353))) (let () (if (eqv? .flags|356 .forward:nop|9) (.loop|346 (let ((.x|362|365 .instructions|347)) (begin (.check! (pair? .x|362|365) 1 .x|362|365) (cdr:pair .x|362|365))) .filtered|347) (if (if (eqv? .flags|356 .forward:nop-if-arg1-is-negative|21) (< (instruction.arg1 .instruction|350) 0) #f) (.loop|346 (let ((.x|371|374 .instructions|347)) (begin (.check! (pair? .x|371|374) 1 .x|371|374) (cdr:pair .x|371|374))) .filtered|347) (if (eqv? .op|353 $.label) (let ((.label2|379 (instruction.arg1 .instruction|350))) (begin (hashtable-put! .label-table|80 .label1|336 .label2|379) (.forwards-label|84 .instruction|350 (let ((.x|380|383 .instructions|347)) (begin (.check! (pair? .x|380|383) 1 .x|380|383) (cdr:pair .x|380|383))) (let ((.x|384|387 .filtered|347)) (begin (.check! (pair? .x|384|387) 1 .x|384|387) (cdr:pair .x|384|387)))))) (if (eqv? .op|353 $skip) (let ((.label2|392 (instruction.arg1 .instruction|350))) (begin (hashtable-put! .label-table|80 .label1|336 .label2|392) (.forwards|84 .instructions|347 (let ((.x|393|396 .filtered|347)) (begin (.check! (pair? .x|393|396) 1 .x|393|396) (cdr:pair .x|393|396)))))) (.forwards|84 .instructions|347 .filtered|347))))))))) (.loop|346 .instructions|343 .filtered|343))))))))) (set! .forwards|84 (lambda (.instructions|402 .filtered|402) (if (null? .instructions|402) (begin (.vector-fill!|84 .registers|77 #f) (let ((.v|403|406 .registers|77) (.i|403|406 0) (.x|403|406 #t)) (begin (.check! (fixnum? .i|403|406) 41 .v|403|406 .i|403|406 .x|403|406) (.check! (vector? .v|403|406) 41 .v|403|406 .i|403|406 .x|403|406) (.check! (<:fix:fix .i|403|406 (vector-length:vec .v|403|406)) 41 .v|403|406 .i|403|406 .x|403|406) (.check! (>=:fix:fix .i|403|406 0) 41 .v|403|406 .i|403|406 .x|403|406) (vector-set!:trusted .v|403|406 .i|403|406 .x|403|406))) (.compute-transitive-closure!|84) (.backwards0|84 .filtered|402 '())) (let* ((.instruction|409 (let ((.x|486|489 .instructions|402)) (begin (.check! (pair? .x|486|489) 0 .x|486|489) (car:pair .x|486|489)))) (.instructions|412 (let ((.x|482|485 .instructions|402)) (begin (.check! (pair? .x|482|485) 1 .x|482|485) (cdr:pair .x|482|485)))) (.op|415 (instruction.op .instruction|409)) (.flags|418 (bytevector-ref .forward-table|54 .op|415))) (let () (if (eqv? .flags|418 .forward:normal|6) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402)) (if (eqv? .flags|418 .forward:nop|9) (.forwards|84 .instructions|412 .filtered|402) (if (eqv? .flags|418 .forward:nop-if-arg1-is-negative|21) (if (< (instruction.arg1 .instruction|409) 0) (.forwards|84 .instructions|412 .filtered|402) (begin (.vector-fill!|84 .registers|77 #f) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402)))) (if (eqv? .flags|418 .forward:kills-all-registers|18) (begin (.vector-fill!|84 .registers|77 #f) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402))) (if (eqv? .flags|418 .forward:ends-block|12) (begin (.vector-fill!|84 .registers|77 #f) (if (eqv? .op|415 $.label) (.forwards-label|84 .instruction|409 .instructions|412 .filtered|402) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402)))) (if (eqv? .flags|418 .forward:interesting|15) (if (eqv? .op|415 $setreg) (begin (let ((.v|438|441 .registers|77) (.i|438|441 (instruction.arg1 .instruction|409)) (.x|438|441 #f)) (begin (.check! (fixnum? .i|438|441) 41 .v|438|441 .i|438|441 .x|438|441) (.check! (vector? .v|438|441) 41 .v|438|441 .i|438|441 .x|438|441) (.check! (<:fix:fix .i|438|441 (vector-length:vec .v|438|441)) 41 .v|438|441 .i|438|441 .x|438|441) (.check! (>=:fix:fix .i|438|441 0) 41 .v|438|441 .i|438|441 .x|438|441) (vector-set!:trusted .v|438|441 .i|438|441 .x|438|441))) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402))) (if (eqv? .op|415 $const/setreg) (begin (let ((.v|444|447 .registers|77) (.i|444|447 (instruction.arg2 .instruction|409)) (.x|444|447 #f)) (begin (.check! (fixnum? .i|444|447) 41 .v|444|447 .i|444|447 .x|444|447) (.check! (vector? .v|444|447) 41 .v|444|447 .i|444|447 .x|444|447) (.check! (<:fix:fix .i|444|447 (vector-length:vec .v|444|447)) 41 .v|444|447 .i|444|447 .x|444|447) (.check! (>=:fix:fix .i|444|447 0) 41 .v|444|447 .i|444|447 .x|444|447) (vector-set!:trusted .v|444|447 .i|444|447 .x|444|447))) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402))) (if (eqv? .op|415 $movereg) (begin (let ((.v|450|453 .registers|77) (.i|450|453 (instruction.arg2 .instruction|409)) (.x|450|453 #f)) (begin (.check! (fixnum? .i|450|453) 41 .v|450|453 .i|450|453 .x|450|453) (.check! (vector? .v|450|453) 41 .v|450|453 .i|450|453 .x|450|453) (.check! (<:fix:fix .i|450|453 (vector-length:vec .v|450|453)) 41 .v|450|453 .i|450|453 .x|450|453) (.check! (>=:fix:fix .i|450|453 0) 41 .v|450|453 .i|450|453 .x|450|453) (vector-set!:trusted .v|450|453 .i|450|453 .x|450|453))) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402))) (if (eqv? .op|415 $setstk) (begin (.kill-stack!|84 (instruction.arg1 .instruction|409)) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402))) (if (eqv? .op|415 $load) (let ((.i|460 (instruction.arg1 .instruction|409)) (.j|460 (instruction.arg2 .instruction|409))) (if (eqv? (let ((.v|462|465 .registers|77) (.i|462|465 .i|460)) (begin (.check! (fixnum? .i|462|465) 40 .v|462|465 .i|462|465) (.check! (vector? .v|462|465) 40 .v|462|465 .i|462|465) (.check! (<:fix:fix .i|462|465 (vector-length:vec .v|462|465)) 40 .v|462|465 .i|462|465) (.check! (>=:fix:fix .i|462|465 0) 40 .v|462|465 .i|462|465) (vector-ref:trusted .v|462|465 .i|462|465))) .j|460) (.suppress-forwards|84 .instruction|409 .instructions|412 .filtered|402) (begin (let ((.v|466|469 .registers|77) (.i|466|469 .i|460) (.x|466|469 .j|460)) (begin (.check! (fixnum? .i|466|469) 41 .v|466|469 .i|466|469 .x|466|469) (.check! (vector? .v|466|469) 41 .v|466|469 .i|466|469 .x|466|469) (.check! (<:fix:fix .i|466|469 (vector-length:vec .v|466|469)) 41 .v|466|469 .i|466|469 .x|466|469) (.check! (>=:fix:fix .i|466|469 0) 41 .v|466|469 .i|466|469 .x|466|469) (vector-set!:trusted .v|466|469 .i|466|469 .x|466|469))) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402))))) (if (eqv? .op|415 $store) (let ((.i|474 (instruction.arg1 .instruction|409)) (.j|474 (instruction.arg2 .instruction|409))) (if (eqv? (let ((.v|476|479 .registers|77) (.i|476|479 .i|474)) (begin (.check! (fixnum? .i|476|479) 40 .v|476|479 .i|476|479) (.check! (vector? .v|476|479) 40 .v|476|479 .i|476|479) (.check! (<:fix:fix .i|476|479 (vector-length:vec .v|476|479)) 40 .v|476|479 .i|476|479) (.check! (>=:fix:fix .i|476|479 0) 40 .v|476|479 .i|476|479) (vector-ref:trusted .v|476|479 .i|476|479))) .j|474) (.suppress-forwards|84 .instruction|409 .instructions|412 .filtered|402) (begin (.kill-stack!|84 .j|474) (.forwards|84 .instructions|412 (cons .instruction|409 .filtered|402))))) (.local-optimization-error|84 .op|415))))))) (.local-optimization-error|84 .op|415)))))))))))) (set! .kill-stack!|84 (lambda (.j|490) (let () (let ((.loop|492|494|497 (unspecified))) (begin (set! .loop|492|494|497 (lambda (.i|498) (if (= .i|498 .*nregs*|74) (if #f #f (unspecified)) (begin (begin #t (let ((.x|503 (let ((.v|510|513 .registers|77) (.i|510|513 .i|498)) (begin (.check! (fixnum? .i|510|513) 40 .v|510|513 .i|510|513) (.check! (vector? .v|510|513) 40 .v|510|513 .i|510|513) (.check! (<:fix:fix .i|510|513 (vector-length:vec .v|510|513)) 40 .v|510|513 .i|510|513) (.check! (>=:fix:fix .i|510|513 0) 40 .v|510|513 .i|510|513) (vector-ref:trusted .v|510|513 .i|510|513))))) (if (if .x|503 (= .x|503 .j|490) #f) (let ((.v|506|509 .registers|77) (.i|506|509 .i|498) (.x|506|509 #f)) (begin (.check! (fixnum? .i|506|509) 41 .v|506|509 .i|506|509 .x|506|509) (.check! (vector? .v|506|509) 41 .v|506|509 .i|506|509 .x|506|509) (.check! (<:fix:fix .i|506|509 (vector-length:vec .v|506|509)) 41 .v|506|509 .i|506|509 .x|506|509) (.check! (>=:fix:fix .i|506|509 0) 41 .v|506|509 .i|506|509 .x|506|509) (vector-set!:trusted .v|506|509 .i|506|509 .x|506|509))) (unspecified)))) (.loop|492|494|497 (+ .i|498 1)))))) (.loop|492|494|497 0)))))) (set! .subvector-fill!|84 (lambda (.v|514 .i|514 .j|514 .x|514) (if (< .i|514 .j|514) (begin (let ((.v|515|518 .v|514) (.i|515|518 .i|514) (.x|515|518 .x|514)) (begin (.check! (fixnum? .i|515|518) 41 .v|515|518 .i|515|518 .x|515|518) (.check! (vector? .v|515|518) 41 .v|515|518 .i|515|518 .x|515|518) (.check! (<:fix:fix .i|515|518 (vector-length:vec .v|515|518)) 41 .v|515|518 .i|515|518 .x|515|518) (.check! (>=:fix:fix .i|515|518 0) 41 .v|515|518 .i|515|518 .x|515|518) (vector-set!:trusted .v|515|518 .i|515|518 .x|515|518))) (.subvector-fill!|84 .v|514 (+ .i|514 1) .j|514 .x|514)) (unspecified)))) (set! .vector-fill!|84 (lambda (.v|519 .x|519) (.subvector-fill!|84 .v|519 0 (let ((.v|520|523 .v|519)) (begin (.check! (vector? .v|520|523) 42 .v|520|523) (vector-length:vec .v|520|523))) .x|519))) (set! .lookup-label|84 (lambda (.x|524) (hashtable-fetch .label-table|80 .x|524 .x|524))) (set! .compute-transitive-closure!|84 (lambda () (let ((.lookup|526 (unspecified))) (begin (set! .lookup|526 (lambda (.x|527) (let ((.y|530 (hashtable-get .label-table|80 .x|527))) (if .y|530 (.lookup|526 .y|530) .x|527)))) (hashtable-for-each (lambda (.x|531 .y|531) (hashtable-put! .label-table|80 .x|531 (.lookup|526 .y|531))) .label-table|80))))) (.vector-fill!|84 .registers|77 #f) (.forwards|84 .instructions|71 '())))))))))) 'filter-basic-blocks))
(let () (begin (set! *scheme-file-types* '(".sch" ".scm")) '*scheme-file-types*))
(let () (begin (set! *lap-file-type* ".lap") '*lap-file-type*))
(let () (begin (set! *mal-file-type* ".mal") '*mal-file-type*))
(let () (begin (set! *lop-file-type* ".lop") '*lop-file-type*))
(let () (begin (set! *fasl-file-type* ".fasl") '*fasl-file-type*))
(let () (begin (set! compile-file (lambda (.infilename|1 . .rest|1) (let ((.doit|2 (unspecified))) (begin (set! .doit|2 (lambda () (let ((.outfilename|6 (if (not (null? .rest|1)) (let ((.x|11|14 .rest|1)) (begin (.check! (pair? .x|11|14) 0 .x|11|14) (car:pair .x|11|14))) (rewrite-file-type .infilename|1 *scheme-file-types* *fasl-file-type*))) (.user|6 (assembly-user-data))) (begin (if (if (not (integrate-usual-procedures)) (issue-warnings) #f) (begin (display "WARNING from compiler: ") (display "integrate-usual-procedures is turned off") (newline) (display "Performance is likely to be poor.") (newline)) (unspecified)) (if (benchmark-block-mode) (process-file-block .infilename|1 .outfilename|6 dump-fasl-segment-to-port (lambda (.forms|9) (assemble (compile-block .forms|9) .user|6))) (process-file .infilename|1 .outfilename|6 dump-fasl-segment-to-port (lambda (.expr|10) (assemble (compile .expr|10) .user|6)))) (unspecified))))) (if (eq? (nbuild-parameter 'target-machine) 'standard-c) (error "Compile-file not supported on this target architecture.") (.doit|2)))))) 'compile-file))
(let () (begin (set! assemble-file (lambda (.infilename|1 . .rest|1) (let ((.doit|2 (unspecified))) (begin (set! .doit|2 (lambda () (let ((.outfilename|6 (if (not (null? .rest|1)) (let ((.x|8|11 .rest|1)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) (rewrite-file-type .infilename|1 (let* ((.t1|12|15 *lap-file-type*) (.t2|12|18 (cons *mal-file-type* '()))) (let () (cons .t1|12|15 .t2|12|18))) *fasl-file-type*))) (.malfile?|6 (file-type=? .infilename|1 *mal-file-type*)) (.user|6 (assembly-user-data))) (begin (process-file .infilename|1 .outfilename|6 dump-fasl-segment-to-port (lambda (.x|7) (assemble (if .malfile?|6 (eval .x|7) .x|7) .user|6))) (unspecified))))) (if (eq? (nbuild-parameter 'target-machine) 'standard-c) (error "Assemble-file not supported on this target architecture.") (.doit|2)))))) 'assemble-file))
(let () (begin (set! compile-expression (let () (let ((.compile-expression|4 (unspecified))) (begin (set! .compile-expression|4 (lambda (.expr|5 .env|5) (let* ((.syntax-env|8 (let ((.temp|15|18 (environment-tag .env|5))) (if (memv .temp|15|18 '(0 1)) (make-standard-syntactic-environment) (if (memv .temp|15|18 '(2)) global-syntactic-environment (begin (error "Invalid environment for compile-expression: " .env|5) #t))))) (.current-env|11 global-syntactic-environment)) (dynamic-wind (lambda () (set! global-syntactic-environment .syntax-env|8)) (lambda () (assemble (compile .expr|5))) (lambda () (set! global-syntactic-environment .current-env|11)))))) .compile-expression|4)))) 'compile-expression))
(let () (begin (set! macro-expand-expression (let () (let ((.macro-expand-expression|4 (unspecified))) (begin (set! .macro-expand-expression|4 (lambda (.expr|5 .env|5) (let* ((.syntax-env|8 (let ((.temp|15|18 (environment-tag .env|5))) (if (memv .temp|15|18 '(0 1)) (make-standard-syntactic-environment) (if (memv .temp|15|18 '(2)) global-syntactic-environment (begin (error "Invalid environment for compile-expression: " .env|5) #t))))) (.current-env|11 global-syntactic-environment)) (dynamic-wind (lambda () (set! global-syntactic-environment .syntax-env|8)) (lambda () (make-readable (macro-expand .expr|5))) (lambda () (set! global-syntactic-environment .current-env|11)))))) .macro-expand-expression|4)))) 'macro-expand-expression))
(let () (begin (set! compile313 (lambda (.infilename|1 . .rest|1) (let ((.outfilename|4 (if (not (null? .rest|1)) (let ((.x|5|8 .rest|1)) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8))) (rewrite-file-type .infilename|1 *scheme-file-types* *lap-file-type*))) (.write-lap|4 (lambda (.item|9 .port|9) (begin (write .item|9 .port|9) (newline .port|9) (newline .port|9))))) (begin (if (benchmark-block-mode) (process-file-block .infilename|1 .outfilename|4 .write-lap|4 compile-block) (process-file .infilename|1 .outfilename|4 .write-lap|4 compile)) (unspecified))))) 'compile313))
(let () (begin (set! assemble313 (lambda (.file|1 . .rest|1) (let ((.outputfile|4 (if (not (null? .rest|1)) (let ((.x|6|9 .rest|1)) (begin (.check! (pair? .x|6|9) 0 .x|6|9) (car:pair .x|6|9))) (rewrite-file-type .file|1 (let* ((.t1|10|13 *lap-file-type*) (.t2|10|16 (cons *mal-file-type* '()))) (let () (cons .t1|10|13 .t2|10|16))) *lop-file-type*))) (.malfile?|4 (file-type=? .file|1 *mal-file-type*)) (.user|4 (assembly-user-data))) (begin (process-file .file|1 .outputfile|4 write-lop (lambda (.x|5) (assemble (if .malfile?|4 (eval .x|5) .x|5) .user|4))) (unspecified))))) 'assemble313))
(let () (begin (set! compile-and-assemble313 (lambda (.input-file|1 . .rest|1) (let ((.output-file|4 (if (not (null? .rest|1)) (let ((.x|7|10 .rest|1)) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10))) (rewrite-file-type .input-file|1 *scheme-file-types* *lop-file-type*))) (.user|4 (assembly-user-data))) (begin (if (benchmark-block-mode) (process-file-block .input-file|1 .output-file|4 write-lop (lambda (.x|5) (assemble (compile-block .x|5) .user|4))) (process-file .input-file|1 .output-file|4 write-lop (lambda (.x|6) (assemble (compile .x|6) .user|4)))) (unspecified))))) 'compile-and-assemble313))
(let () (begin (set! make-fasl (lambda (.infilename|1 . .rest|1) (let ((.doit|2 (unspecified))) (begin (set! .doit|2 (lambda () (let ((.outfilename|6 (if (not (null? .rest|1)) (let ((.x|8|11 .rest|1)) (begin (.check! (pair? .x|8|11) 0 .x|8|11) (car:pair .x|8|11))) (rewrite-file-type .infilename|1 *lop-file-type* *fasl-file-type*)))) (begin (process-file .infilename|1 .outfilename|6 dump-fasl-segment-to-port (lambda (.x|7) .x|7)) (unspecified))))) (if (eq? (nbuild-parameter 'target-machine) 'standard-c) (error "Make-fasl not supported on this target architecture.") (.doit|2)))))) 'make-fasl))
(let () (begin (set! disassemble (lambda (.item|1 . .rest|1) (let ((.output-port|4 (if (null? .rest|1) (current-output-port) (let ((.x|5|8 .rest|1)) (begin (.check! (pair? .x|5|8) 0 .x|5|8) (car:pair .x|5|8)))))) (begin (disassemble-item .item|1 #f .output-port|4) (unspecified))))) 'disassemble))
(let () (begin (set! disassemble-item (lambda (.item|1 .segment-no|1 .port|1) (let ((.disassemble-item|2 0)) (begin (set! .disassemble-item|2 (lambda (.item|3 .segment-no|3 .port|3) (let ((.print-segment|5 (unspecified)) (.print-constvector|5 (unspecified)) (.print|5 (unspecified))) (begin (set! .print-segment|5 (lambda (.segment|6) (begin (.print|5 "Segment # " .segment-no|3) (print-instructions (disassemble-codevector (let ((.x|7|10 .segment|6)) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10)))) .port|3) (.print-constvector|5 (let ((.x|11|14 .segment|6)) (begin (.check! (pair? .x|11|14) 1 .x|11|14) (cdr:pair .x|11|14)))) (.print|5 "========================================")))) (set! .print-constvector|5 (lambda (.cv|15) (let () (let ((.loop|17|19|22 (unspecified))) (begin (set! .loop|17|19|22 (lambda (.i|23) (if (= .i|23 (let ((.v|25|28 .cv|15)) (begin (.check! (vector? .v|25|28) 42 .v|25|28) (vector-length:vec .v|25|28)))) (if #f #f (unspecified)) (begin (begin #t (.print|5 "------------------------------------------") (.print|5 "Constant vector element # " .i|23) (let ((.temp|30|33 (let ((.x|90|93 (let ((.v|94|97 .cv|15) (.i|94|97 .i|23)) (begin (.check! (fixnum? .i|94|97) 40 .v|94|97 .i|94|97) (.check! (vector? .v|94|97) 40 .v|94|97 .i|94|97) (.check! (<:fix:fix .i|94|97 (vector-length:vec .v|94|97)) 40 .v|94|97 .i|94|97) (.check! (>=:fix:fix .i|94|97 0) 40 .v|94|97 .i|94|97) (vector-ref:trusted .v|94|97 .i|94|97))))) (begin (.check! (pair? .x|90|93) 0 .x|90|93) (car:pair .x|90|93))))) (if (memv .temp|30|33 '(codevector)) (begin (.print|5 "Code vector") (print-instructions (disassemble-codevector (let ((.x|36|39 (let ((.x|40|43 (let ((.v|44|47 .cv|15) (.i|44|47 .i|23)) (begin (.check! (fixnum? .i|44|47) 40 .v|44|47 .i|44|47) (.check! (vector? .v|44|47) 40 .v|44|47 .i|44|47) (.check! (<:fix:fix .i|44|47 (vector-length:vec .v|44|47)) 40 .v|44|47 .i|44|47) (.check! (>=:fix:fix .i|44|47 0) 40 .v|44|47 .i|44|47) (vector-ref:trusted .v|44|47 .i|44|47))))) (begin (.check! (pair? .x|40|43) 1 .x|40|43) (cdr:pair .x|40|43))))) (begin (.check! (pair? .x|36|39) 0 .x|36|39) (car:pair .x|36|39)))) .port|3)) (if (memv .temp|30|33 '(constantvector)) (begin (.print|5 "Constant vector") (.print-constvector|5 (let ((.x|50|53 (let ((.x|54|57 (let ((.v|58|61 .cv|15) (.i|58|61 .i|23)) (begin (.check! (fixnum? .i|58|61) 40 .v|58|61 .i|58|61) (.check! (vector? .v|58|61) 40 .v|58|61 .i|58|61) (.check! (<:fix:fix .i|58|61 (vector-length:vec .v|58|61)) 40 .v|58|61 .i|58|61) (.check! (>=:fix:fix .i|58|61 0) 40 .v|58|61 .i|58|61) (vector-ref:trusted .v|58|61 .i|58|61))))) (begin (.check! (pair? .x|54|57) 1 .x|54|57) (cdr:pair .x|54|57))))) (begin (.check! (pair? .x|50|53) 0 .x|50|53) (car:pair .x|50|53))))) (if (memv .temp|30|33 '(global)) (.print|5 "Global: " (let ((.x|64|67 (let ((.x|68|71 (let ((.v|72|75 .cv|15) (.i|72|75 .i|23)) (begin (.check! (fixnum? .i|72|75) 40 .v|72|75 .i|72|75) (.check! (vector? .v|72|75) 40 .v|72|75 .i|72|75) (.check! (<:fix:fix .i|72|75 (vector-length:vec .v|72|75)) 40 .v|72|75 .i|72|75) (.check! (>=:fix:fix .i|72|75 0) 40 .v|72|75 .i|72|75) (vector-ref:trusted .v|72|75 .i|72|75))))) (begin (.check! (pair? .x|68|71) 1 .x|68|71) (cdr:pair .x|68|71))))) (begin (.check! (pair? .x|64|67) 0 .x|64|67) (car:pair .x|64|67)))) (if (memv .temp|30|33 '(data)) (.print|5 "Data: " (let ((.x|78|81 (let ((.x|82|85 (let ((.v|86|89 .cv|15) (.i|86|89 .i|23)) (begin (.check! (fixnum? .i|86|89) 40 .v|86|89 .i|86|89) (.check! (vector? .v|86|89) 40 .v|86|89 .i|86|89) (.check! (<:fix:fix .i|86|89 (vector-length:vec .v|86|89)) 40 .v|86|89 .i|86|89) (.check! (>=:fix:fix .i|86|89 0) 40 .v|86|89 .i|86|89) (vector-ref:trusted .v|86|89 .i|86|89))))) (begin (.check! (pair? .x|82|85) 1 .x|82|85) (cdr:pair .x|82|85))))) (begin (.check! (pair? .x|78|81) 0 .x|78|81) (car:pair .x|78|81)))) (unspecified))))))) (.loop|17|19|22 (+ .i|23 1)))))) (.loop|17|19|22 0)))))) (set! .print|5 (lambda .rest|98 (begin (let () (let ((.loop|104|106|109 (unspecified))) (begin (set! .loop|104|106|109 (lambda (.y1|99|100|110) (if (null? .y1|99|100|110) (if #f #f (unspecified)) (begin (begin #t (let ((.x|114 (let ((.x|115|118 .y1|99|100|110)) (begin (.check! (pair? .x|115|118) 0 .x|115|118) (car:pair .x|115|118))))) (display .x|114 .port|3))) (.loop|104|106|109 (let ((.x|119|122 .y1|99|100|110)) (begin (.check! (pair? .x|119|122) 1 .x|119|122) (cdr:pair .x|119|122)))))))) (.loop|104|106|109 .rest|98)))) (newline .port|3)))) (if (procedure? .item|3) (print-instructions (disassemble-codevector (procedure-ref .item|3 0)) .port|3) (if (if (pair? .item|3) (if (bytevector? (let ((.x|126|129 .item|3)) (begin (.check! (pair? .x|126|129) 0 .x|126|129) (car:pair .x|126|129)))) (vector? (let ((.x|131|134 .item|3)) (begin (.check! (pair? .x|131|134) 1 .x|131|134) (cdr:pair .x|131|134)))) #f) #f) (.print-segment|5 .item|3) (error "disassemble-item: " .item|3 " is not disassemblable."))))))) (.disassemble-item|2 .item|1 .segment-no|1 .port|1))))) 'disassemble-item))
(let () (begin (set! disassemble-file (lambda (.file|1 . .rest|1) (let ((.doit|2 (unspecified))) (begin (set! .doit|2 (lambda (.input-port|3 .output-port|3) (begin (display "\; From " .output-port|3) (display .file|1 .output-port|3) (newline .output-port|3) (let () (let ((.loop|5|8|11 (unspecified))) (begin (set! .loop|5|8|11 (lambda (.segment-no|12 .segment|12) (if (eof-object? .segment|12) (if #f #f (unspecified)) (begin (begin #t (disassemble-item .segment|12 .segment-no|12 .output-port|3)) (.loop|5|8|11 (+ .segment-no|12 1) (read .input-port|3)))))) (.loop|5|8|11 0 (read .input-port|3)))))))) (call-with-input-file .file|1 (lambda (.input-port|15) (if (null? .rest|1) (.doit|2 .input-port|15 (current-output-port)) (begin (delete-file (let ((.x|16|19 .rest|1)) (begin (.check! (pair? .x|16|19) 0 .x|16|19) (car:pair .x|16|19)))) (call-with-output-file (let ((.x|20|23 .rest|1)) (begin (.check! (pair? .x|20|23) 0 .x|20|23) (car:pair .x|20|23))) (lambda (.output-port|24) (.doit|2 .input-port|15 .output-port|24))))))) (unspecified))))) 'disassemble-file))
(let () (begin (set! compiler-switches (lambda .rest|1 (let ((.fast-unsafe-code|3 (unspecified)) (.fast-safe-code|3 (unspecified)) (.standard-code|3 (unspecified)) (.slow-code|3 (unspecified))) (begin (set! .fast-unsafe-code|3 (lambda () (begin (set-compiler-flags! 'fast-unsafe) (set-assembler-flags! 'fast-unsafe)))) (set! .fast-safe-code|3 (lambda () (begin (set-compiler-flags! 'fast-safe) (set-assembler-flags! 'fast-safe)))) (set! .standard-code|3 (lambda () (begin (set-compiler-flags! 'standard) (set-assembler-flags! 'standard)))) (set! .slow-code|3 (lambda () (begin (set-compiler-flags! 'no-optimization) (set-assembler-flags! 'no-optimization)))) (if (null? .rest|1) (begin (display "Debugging:") (newline) (display-twobit-flags 'debugging) (display-assembler-flags 'debugging) (newline) (display "Safety:") (newline) (display-twobit-flags 'safety) (display-assembler-flags 'safety) (newline) (display "Speed:") (newline) (display-twobit-flags 'optimization) (display-assembler-flags 'optimization) (if #f #f (unspecified))) (if (null? (let ((.x|9|12 .rest|1)) (begin (.check! (pair? .x|9|12) 1 .x|9|12) (cdr:pair .x|9|12)))) (begin (let ((.temp|13|16 (let ((.x|27|30 .rest|1)) (begin (.check! (pair? .x|27|30) 0 .x|27|30) (car:pair .x|27|30))))) (if (memv .temp|13|16 '(0 slow)) (.slow-code|3) (if (memv .temp|13|16 '(1 standard)) (.standard-code|3) (if (memv .temp|13|16 '(2 fast-safe)) (.fast-safe-code|3) (if (memv .temp|13|16 '(3 fast-unsafe)) (.fast-unsafe-code|3) (if (memv .temp|13|16 '(default factory-settings)) (begin (.fast-safe-code|3) (include-source-code #t) (benchmark-mode #f) (benchmark-block-mode #f) (common-subexpression-elimination #f) (representation-inference #f)) (error "Unrecognized flag " (let ((.x|23|26 .rest|1)) (begin (.check! (pair? .x|23|26) 0 .x|23|26) (car:pair .x|23|26))) " to compiler-switches."))))))) (unspecified)) (error "Too many arguments to compiler-switches."))))))) 'compiler-switches))
(let () (begin (set! process-file (lambda (.infilename|1 .outfilename|1 .writer|1 .processer|1) (let ((.process-file|2 0)) (begin (set! .process-file|2 (lambda (.infilename|3 .outfilename|3 .writer|3 .processer|3) (let ((.doit|6 (unspecified))) (begin (set! .doit|6 (lambda () (begin (delete-file .outfilename|3) (call-with-output-file .outfilename|3 (lambda (.outport|8) (call-with-input-file .infilename|3 (lambda (.inport|9) (let ((.x|12 (read .inport|9))) (let () (let ((.loop|15 (unspecified))) (begin (set! .loop|15 (lambda (.x|16) (if (eof-object? .x|16) #t (begin (.writer|3 (.processer|3 .x|16) .outport|8) (.loop|15 (read .inport|9)))))) (.loop|15 .x|12)))))))))))) (let ((.current-syntactic-environment|17 (syntactic-copy global-syntactic-environment))) (dynamic-wind (lambda () #t) (lambda () (.doit|6)) (lambda () (set! global-syntactic-environment .current-syntactic-environment|17)))))))) (.process-file|2 .infilename|1 .outfilename|1 .writer|1 .processer|1))))) 'process-file))
(let () (begin (set! process-file-block (lambda (.infilename|1 .outfilename|1 .writer|1 .processer|1) (let ((.process-file-block|2 0)) (begin (set! .process-file-block|2 (lambda (.infilename|3 .outfilename|3 .writer|3 .processer|3) (let ((.doit|6 (unspecified))) (begin (set! .doit|6 (lambda () (begin (delete-file .outfilename|3) (call-with-output-file .outfilename|3 (lambda (.outport|8) (call-with-input-file .infilename|3 (lambda (.inport|9) (let () (let ((.loop|10|13|16 (unspecified))) (begin (set! .loop|10|13|16 (lambda (.x|17 .forms|17) (if (eof-object? .x|17) (.writer|3 (.processer|3 (reverse .forms|17)) .outport|8) (begin #t (.loop|10|13|16 (read .inport|9) (cons .x|17 .forms|17)))))) (.loop|10|13|16 (read .inport|9) '()))))))))))) (let ((.current-syntactic-environment|20 (syntactic-copy global-syntactic-environment))) (dynamic-wind (lambda () #t) (lambda () (.doit|6)) (lambda () (set! global-syntactic-environment .current-syntactic-environment|20)))))))) (.process-file-block|2 .infilename|1 .outfilename|1 .writer|1 .processer|1))))) 'process-file-block))
(let () (begin (set! rewrite-file-type (lambda (.filename|1 .matches|1 .new|1) (let ((.rewrite-file-type|2 0)) (begin (set! .rewrite-file-type|2 (lambda (.filename|3 .matches|3 .new|3) (if (not (pair? .matches|3)) (.rewrite-file-type|2 .filename|3 (cons .matches|3 '()) .new|3) (let* ((.j|7 (string-length .filename|3)) (.m|10 .matches|3)) (let () (let ((.loop|13 (unspecified))) (begin (set! .loop|13 (lambda (.m|14) (if (null? .m|14) (string-append .filename|3 .new|3) (let* ((.n|19 (let ((.x|30|33 .m|14)) (begin (.check! (pair? .x|30|33) 0 .x|30|33) (car:pair .x|30|33)))) (.l|22 (string-length .n|19))) (let () (if (file-type=? .filename|3 .n|19) (string-append (substring .filename|3 0 (- .j|7 .l|22)) .new|3) (.loop|13 (let ((.x|26|29 .m|14)) (begin (.check! (pair? .x|26|29) 1 .x|26|29) (cdr:pair .x|26|29)))))))))) (.loop|13 .m|10)))))))) (.rewrite-file-type|2 .filename|1 .matches|1 .new|1))))) 'rewrite-file-type))
(let () (begin (set! file-type=? (lambda (.file-name|1 .type-name|1) (let ((.file-type=?|2 0)) (begin (set! .file-type=?|2 (lambda (.file-name|3 .type-name|3) (let ((.fl|6 (string-length .file-name|3)) (.tl|6 (string-length .type-name|3))) (if (>= .fl|6 .tl|6) (string-ci=? .type-name|3 (substring .file-name|3 (- .fl|6 .tl|6) .fl|6)) #f)))) (.file-type=?|2 .file-name|1 .type-name|1))))) 'file-type=?))
(let () (begin (set! readify-lap (lambda (.code|1) (let ((.readify-lap|2 0)) (begin (set! .readify-lap|2 (lambda (.code|3) (let () (let ((.loop|9|12|15 (unspecified))) (begin (set! .loop|9|12|15 (lambda (.y1|4|5|16 .results|4|8|16) (if (null? .y1|4|5|16) (reverse .results|4|8|16) (begin #t (.loop|9|12|15 (let ((.x|20|23 .y1|4|5|16)) (begin (.check! (pair? .x|20|23) 1 .x|20|23) (cdr:pair .x|20|23))) (cons (let* ((.x|24 (let ((.x|88|91 .y1|4|5|16)) (begin (.check! (pair? .x|88|91) 0 .x|88|91) (car:pair .x|88|91)))) (.iname|27 (let ((.x|79|82 (assv (let ((.x|84|87 .x|24)) (begin (.check! (pair? .x|84|87) 0 .x|84|87) (car:pair .x|84|87))) *mnemonic-names*))) (begin (.check! (pair? .x|79|82) 1 .x|79|82) (cdr:pair .x|79|82))))) (if (not (= (let ((.x|28|31 .x|24)) (begin (.check! (pair? .x|28|31) 0 .x|28|31) (car:pair .x|28|31))) $lambda)) (cons .iname|27 (let ((.x|32|35 .x|24)) (begin (.check! (pair? .x|32|35) 1 .x|32|35) (cdr:pair .x|32|35)))) (let* ((.t1|36|39 .iname|27) (.t2|36|42 (let* ((.t1|46|49 (.readify-lap|2 (let ((.x|71|74 (let ((.x|75|78 .x|24)) (begin (.check! (pair? .x|75|78) 1 .x|75|78) (cdr:pair .x|75|78))))) (begin (.check! (pair? .x|71|74) 0 .x|71|74) (car:pair .x|71|74))))) (.t2|46|52 (cons (let ((.x|58|61 (let ((.x|62|65 (let ((.x|66|69 .x|24)) (begin (.check! (pair? .x|66|69) 1 .x|66|69) (cdr:pair .x|66|69))))) (begin (.check! (pair? .x|62|65) 1 .x|62|65) (cdr:pair .x|62|65))))) (begin (.check! (pair? .x|58|61) 0 .x|58|61) (car:pair .x|58|61))) '()))) (let () (cons .t1|46|49 .t2|46|52))))) (let () (cons .t1|36|39 .t2|36|42))))) .results|4|8|16)))))) (.loop|9|12|15 .code|3 '())))))) (.readify-lap|2 .code|1))))) 'readify-lap))
(let () (begin (set! readify-file (lambda (.f|1 . .o|1) (let ((.doit|2 (unspecified))) (begin (set! .doit|2 (lambda () (let* ((.i|6 (open-input-file .f|1)) (.x|9 (read .i|6))) (let () (let ((.loop|12 (unspecified))) (begin (set! .loop|12 (lambda (.x|13) (if (not (eof-object? .x|13)) (begin (pretty-print (readify-lap .x|13)) (.loop|12 (read .i|6))) (unspecified)))) (.loop|12 .x|9))))))) (if (null? .o|1) (.doit|2) (begin (delete-file (let ((.x|14|17 .o|1)) (begin (.check! (pair? .x|14|17) 0 .x|14|17) (car:pair .x|14|17)))) (with-output-to-file (let ((.x|18|21 .o|1)) (begin (.check! (pair? .x|18|21) 0 .x|18|21) (car:pair .x|18|21))) .doit|2))))))) 'readify-file))
(let () (begin (set! twobit-benchmark (lambda .rest|1 (let ((.k|4 (if (null? .rest|1) 1 (let ((.x|7|10 .rest|1)) (begin (.check! (pair? .x|7|10) 0 .x|7|10) (car:pair .x|7|10)))))) (begin (compiler-switches 'fast-safe) (benchmark-block-mode #t) (run-benchmark "twobit" .k|4 (lambda () (compile-file "benchmarks/twobit-input.sch")) (lambda (.result|6) #t)))))) 'twobit-benchmark))
